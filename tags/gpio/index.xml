<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GPIO on Raspberry Pi Programming</title>
    <link>https://youngkin.github.io/tags/gpio/</link>
    <description>Recent content in GPIO on Raspberry Pi Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Apr 2022 08:08:42 -0600</lastBuildDate><atom:link href="https://youngkin.github.io/tags/gpio/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Raspberry Pi GPIO - Using SPI to display arbitrary patterns on a MAX7219 Dot Matrix Display Module</title>
      <link>https://youngkin.github.io/post/spidotmatrixmodule/</link>
      <pubDate>Sat, 23 Apr 2022 08:08:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/spidotmatrixmodule/</guid>
      <description>&lt;p&gt;This is the seventh article in a series that explores &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;GPIO programming on a Raspberry Pi&lt;/a&gt;. It describes how to control Serial Peripheral Interface (SPI) peripherals such as the &lt;a href=&#34;https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf&#34;&gt;MAX7219 LED Dot Matrix Display Module&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;There are 2 approaches to reading this article. The first is to focus only on the SPI and dot matrix display aspects of the article by skipping the &lt;a href=&#34;./#controlling-the-max7219---direct-interaction-with-the-bcm2835&#34;&gt;Controlling the MAX7219 - direct interaction with the BCM2835&lt;/a&gt; section. The second approach involves also learning how to control SPI peripherals by directly accessing the SPI register set instead of using a 3rd party library. This requires reading the &lt;a href=&#34;./#controlling-the-max7219---direct-interaction-with-the-bcm2835&#34;&gt;Controlling the MAX7219 - direct interaction with the BCM2835&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;If the second approach is taken, then the &lt;a href=&#34;https://youngkin.github.io/post/gpioprogramming/&#34;&gt;Raspberry Pi GPIO - Introduction To Programming Broadcom BCM2835 ARM Peripherals&lt;/a&gt; article should be considered a prerequisite of this article. That article introduces key techniques for directly controlling peripherals connected to the BCM2835, or more generally, the GPIO interface on the Raspberry Pi. Those key concepts include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BCM2835 I/O functions&lt;/li&gt;
&lt;li&gt;BCM2835 addressing&lt;/li&gt;
&lt;li&gt;Using BCM2835 registers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If all you&amp;rsquo;re interested in is learning SPI without learning the details of programming the BCM2835 then the first approach is best.&lt;/p&gt;
&lt;p&gt;The following topics will be covered:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Prerequisites&lt;/strong&gt; - describes the hardware and software libraries you&amp;rsquo;ll need for this article.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Overview of the Serial Peripheral Interface (SPI)&lt;/strong&gt; - provides an introduction to the SPI protocol and the MAX7219 Dot Matrix Display Module.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Using the BCM2835 board to control the MAX7219 Dot Matrix Display Module&lt;/strong&gt; - provides the details, including code, for controlling the MAX7219. It also includes a subsection that describes directly interacting with the SPI register set on the BCM2835.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Summary&lt;/strong&gt; - summarizes the important concepts covered in this article.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;References&lt;/strong&gt; - provides a list of references I found helpful and some that were used in the creation of this article.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;stretch&amp;rsquo; or later version of the Raspbian OS. The BCM2835 library referenced below supports Raspberry Pi models 1 through 4.&lt;/p&gt;
&lt;p&gt;Next you&amp;rsquo;ll need is a &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt;, some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;, and a &lt;a href=&#34;https://www.amazon.com/dp/B07VM6HXN5/ref=sspa_dk_detail_5?pf_rd_p=0c758152-61cd-452f-97a6-17f070f654b8&amp;amp;pd_rd_wg=wF4pR&amp;amp;pf_rd_r=8MBD40495EV7X8RR61NP&amp;amp;pd_rd_w=A5eiC&amp;amp;pd_rd_r=281b8d49-a176-4535-bc99-bd6108f5bc24&amp;amp;s=toys-and-games&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUE1NDJPSEtMOFRCWjImZW5jcnlwdGVkSWQ9QTA4MTEwODgyN0lZRFdWVkhIOFRaJmVuY3J5cHRlZEFkSWQ9QTA4NzU0NjYyQkE5UTNXTzM3SjIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ&amp;amp;th=1&#34;&gt;MAX7219 Dot Matrix Display&lt;/a&gt;. You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the adapter will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. However, a full electronics kit for a Raspberry Pi doesn&amp;rsquo;t cost much more than these 4 components. I recommend buying the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt;.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;You will need some basic C programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll also need familiarity with how to use an editor like Vi or nano. And you&amp;rsquo;ll need basic familiarity with the Linux command line.&lt;/p&gt;
&lt;p&gt;Finally, you&amp;rsquo;ll need to clone or fork &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;my GPIO repository&lt;/a&gt; as it contains underlying library code used to access GPIO capabilities on the BCM2835. As mentioned in other sections, this library code is based on the &lt;a href=&#34;http://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835 C library&lt;/a&gt; developed by Mike McCauley.&lt;/p&gt;
&lt;h2 id=&#34;spi-serial-peripheral-interface-overview&#34;&gt;SPI (Serial Peripheral Interface) Overview&lt;/h2&gt;
&lt;p&gt;SPI is used to send data serially to a peripheral that can accept or requires data in parallel. This is helpful because a relatively large set of parallel inputs can be written to using just 3 GPIO pins, excluding the power (VCC) and ground (GND) pins. If SPI wasn&amp;rsquo;t used, one GPIO pin would be required for each parallel input. This could easily be prohibitive since pins are a limited resource. Let&amp;rsquo;s see how this works with an example.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/MAX7219_Transparent.jpg&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: Author&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The diagram above shows the MAX7219 LED Dot Matrix Display. It&amp;rsquo;s commonly used to display arbitrary shapes such as letters, numbers, and smiley faces.
In addition to the MAX7219, SPI can be used to control a variety of peripherals to display images, take input from touchscreens, and interact with various sensors. &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Wikipedia has a good article&lt;/a&gt; describing SPI in more detail.&lt;/p&gt;
&lt;p&gt;The MAX7219 controls an 8x8 matrix of LEDs. Controlling an LED requires 1 pin excluding power or ground. An 8x8 LED matrix has 64 LEDs. This number is well in excess of the 26 or 40 GPIO pins available on a standard Raspberry Pis. As explained below, utilizing SPI requires considerably fewer GPIO pins.&lt;/p&gt;
&lt;p&gt;The MAX7219 has the following input pins:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DIN - this is the serial data input pin.&lt;/li&gt;
&lt;li&gt;CS - This is commonly called a chip select (CS) or chip enable (CE) pin, or occasionally slave select (SS).&lt;/li&gt;
&lt;li&gt;CLK - This pin connects to a clock pin on the Raspberry Pi that synchronizes data transfers between the Raspberry Pi and the MAX7219.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are 2 more pins that aren&amp;rsquo;t used to control the MAX7219.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VCC - This is the power-in pin. It connects to a power source on the Raspberry Pi, usually a 5 volt source.&lt;/li&gt;
&lt;li&gt;GND - This is the ground pin. It connects to a ground pin of the Raspberry Pi.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A minimum of 3 GPIO pins are required to connect from the Raspberry Pi to the MAX7219, specifically to the DIN, CS, and CLK pins. A Raspberry Pi can control all 64 LEDs in a cost efficient (pin-wise) manner using only these three pins. The usual approach is to use the SPI specific Raspberry Pi pins that can drive the DIN, CS, and CLK pins. These 3 pins are named:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(SPI)MOSI - This stands for Master Out Slave In. The MOSI pin will be connected to the MAX7219 DIN pin and is used to send a serial data signal to the MAX7219 (or any SPI peripheral).&lt;/li&gt;
&lt;li&gt;(SPI)SCLK - This stands for SPI Clock. This pin will be connected to the MAX7219 CLK pin. It is used as the source of the clock signal used to synchronize the data transfer between the BCM2835 and the MAX7219 (or any SPI peripheral). The data transfer will occur when both the MOSI pin and the SCLK pin are set to HIGH.&lt;/li&gt;
&lt;li&gt;(SPI)CS or (SPI)CE - These stands for Chip Select or Chip Enable. In either case, setting the pin to LOW directs the MAX7219 to accept data as described in the previous bullet.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;I reluctantly use the terms &amp;ldquo;master&amp;rdquo; and &amp;ldquo;slave&amp;rdquo;. However these terms are used in all of the documents I&amp;rsquo;ve read on SPI. I&amp;rsquo;ll continue to use them in order to avoid confusion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The SPI capability on the Raspberry Pi may require as many as 5 GPIO pins. The 2 additional pins are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(SPI)MISO - This stands for Master In Slave Out. This pin allows for the MAX7219 (or any SPI peripheral) to send data back to the BCM2835.&lt;/li&gt;
&lt;li&gt;(SPI)CS or (SPI)CE - This is a second chip select/chip enable pin. Having a second CS/CE pin allows the BCM2835 to control 2 SPI peripherals. As stated above, when the CS/CE pin is set to LOW the SPI peripheral will accept data from the BCM2835. So by setting one of the CS/CE pins to HIGH and the other to LOW we can control which slave can receive and send data. The article &lt;a href=&#34;https://adikedia.com/2016/08/10/using-multiple-spi-slave-devices-with-wiringpi/&#34;&gt;Using Multiple SPI Slave Devices with the Raspberry Pi&lt;/a&gt; provides more information about how the 2 CE/CS pins are used. The following schematic illustrates how utilize 2 CE/CS pins:&lt;/li&gt;
&lt;/ol&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/SPIMasterSlave.jpg&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: BCM2835 ARM Peripherals Guide&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;In the image above this schematic you may have noticed the 5 pins on the right-hand side of the MAX7219. These pins output the signals on the corresponding input pins to other MAX7219s. This allows more than two MAX7219s to be &amp;ldquo;chained&amp;rdquo; together to create larger displays, e.g., 128 LED or 256 LED displays. This process is called daisy-chaining. This can be done by connecting the output pins on the primary SPI peripheral to the corresponding input pins on the next peripheral in the chain. Daisy chaining can be used to display multiple characters on a logically larger LED matrix, or to create scrolling displays. This &lt;a href=&#34;https://forum.arduino.cc/t/daisy-chaining-multiple-max7219-chips/3305&#34;&gt;Arduino forum thread&lt;/a&gt; provides a high level explanation about how to accomplish this. &lt;a href=&#34;https://thesolaruniverse.wordpress.com/2016/05/10/news-ticker-with-three-max7219-8x8-dot-led-matrix-devices/&#34;&gt;News ticker with three MAX7219 8×8 dot led matrix devices&lt;/a&gt; is the best article I could find for implementing a specific project. However, it describes how to accomplish this with Sketch (a way to write Python based code snippets), not C. Between these 2 sources there might be enough hints about how to accomplish this using C. I may write a future article that describes how to do this in C.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is possible to &lt;a href=&#34;https://www.amazon.com/HiLetgo-MAX7219-Arduino-Microcontroller-Display/dp/B07FFV537V/ref=sr_1_9?crid=DWVTBTEX09G8&amp;amp;keywords=8x64+led+matrix+module&amp;amp;qid=1650744886&amp;amp;sprefix=8x64+led+matrix+module%2Caps%2C117&amp;amp;sr=8-9&#34;&gt;purchase LED matrix modules that are larger than 8x8&lt;/a&gt; which avoids having to manually daisy-chain multiple devices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The primary SPI interface on the BCM2835, SPI0, is implemented on GPIO pins 7-11. Pins 7 &amp;amp; 8 are the 2 CE/CS pins available on the BCM2835. Pin 9 is MISO, 10 is MOSI, and 11 is the clock (SPICLK/SCLK). The BCM2835 has 2 auxilary SPI interfaces, SPI1 (AKA AUX_SPI0) and SPI2 (AKA AUX_SPI1). From the BCM2835 ARM Peripherals Guide, SPI1 is available on pins 16-21 and SPI2 on pins 35-39. These auxilary interfaces are available via the AUX I/O function.&lt;/p&gt;
&lt;p&gt;The following diagram shows a GPIO extension board frequently used to connect the BCM2835 GPIO pins to a breadboard (if you&amp;rsquo;re not familiar with breadboards there&amp;rsquo;ll be more on them later). The pins are labeled with their GPIO pin numbers or the I/O function (e.g., SPI) they support. Note the SPI pins are labeled on the board using the same terms as above:&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/GPIOExtensionBoard.jpg&#34; align=&#34;center&#34; width=&#34;500&#34; height=&#34;250&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: BCM2835 ARM Peripherals Guide&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The following is a timing diagram that shows the actual signals being sent to the MAX7219 dot matrix display. It&amp;rsquo;s a screenshot from the &lt;a href=&#34;https://sigrok.org/wiki/PulseView&#34;&gt;PulseView/sigrok logic analyzer&lt;/a&gt; application. I used an inexpensive &lt;a href=&#34;https://www.amazon.com/dp/B07K6HXDH1?psc=1&amp;amp;ref=ppx_yo2ov_dt_b_product_details&#34;&gt;logic analyzer device&lt;/a&gt; to capture the signals displayed in PulseView.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/SPITimingLetterY.jpg&#34; align=&#34;center&#34; width=&#34;1000&#34; height=&#34;500&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: Author&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;This diagram shows the values for the first 3 rows of the LED matrix for the letter &amp;ldquo;Y&amp;rdquo;. Here&amp;rsquo;s how to interpret it:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;There are 5 rows/lines going across from left to right labeled CS0, MOSI, SCLK, MAX7219/SPI MOSI bits, and MAX7219/SPI MOSI data. The top three lines are the actual digital signals. Spikes indicate a HIGH signal. The bottom 2 lines are a SPI specific decoding from the 3 line signals above. MAX7219/SPI MOSI bits displays the bit values, 0 (LOW) or 1 (HIGH), associated with the signals above. MAX7219/SPI MOSI data represents the hexidecimal values for the bit values above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CS0 is the chip select line. It&amp;rsquo;s hard to see, but at the far left of the diagram it starts out set to HIGH. It&amp;rsquo;s set to LOW where the vertical line appears. This indicates the data transmission to the SPI peripheral attached to CS0 is about to start. While this signal is set to LOW the following happens:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The SCLK line pulses between HIGH and LOW 16 times while CS0 is set to LOW. This is the timing signal that, when set to HIGH, indicates to the SPI peripheral to accept the current value on the MOSI line.&lt;/li&gt;
&lt;li&gt;For the first 7 pulses of SCLK the MOSI line is set to LOW. Just prior to the 8th pulse the MOSI line is set to HIGH.&lt;/li&gt;
&lt;li&gt;The MAX7219/SPI MOSI bits line shows the binary interpretation of the combination of the SCLK and MOSI lines. Consistent with the first 7 pulses of the SCLK line the MOSI line is interpreted as zeros (0). The 8th bit is interpreted as a 1. So the binary value of the 8 bits sent is &lt;code&gt;0000 0001&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The MAX7219/SPI MOSI data line shows the hexidecimal interpretation which is &lt;code&gt;0x1&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second 8 bits sent while the CS0 line is set to LOW are &lt;code&gt;0100 0001&lt;/code&gt; which is the hex number &lt;code&gt;0x41&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The MAX7219 shift register is 16 bits wide. So each data transmission consists of 16 bits, which is what we see in the timing diagram above. 16 bits are transmitted while the CS0 line is set to LOW. For the MAX7219 the first 8 bits are the address of the register that will be set. The value used to populate this register is sent in the next 8 bits. So this first data transmission sets the the register located at offset &lt;code&gt;0x1&lt;/code&gt; to the value &lt;code&gt;0x41&lt;/code&gt;. The register at offset &lt;code&gt;0x1&lt;/code&gt; controls the first/top row of the dot matrix module. Notice that there are 8 LEDs in each row. Each LED corresponds to a bit in the binary value contained in the register. That value is &lt;code&gt;0x41&lt;/code&gt;, &lt;code&gt;0100 0001&lt;/code&gt;, which will cause the first row of the LED to look like this (&lt;code&gt;-&lt;/code&gt;s are 0, &lt;code&gt;*&lt;/code&gt;s are 1):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-*-----*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The next set of 8 bits is &lt;code&gt;0000 0010&lt;/code&gt; which equates to &lt;code&gt;0x2&lt;/code&gt;. So the value in the 2nd 8 bits will be written to the register at offset &lt;code&gt;0x2&lt;/code&gt;, which corresponds to the 2nd row of 8 LEDS in the dot matrix display. The binary value of the next 8 bits is &lt;code&gt;0010 0010&lt;/code&gt;. The target register will be set to this value. After this transmission the first 2 rows of the LED matrix look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-*-----*
--*---*-
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the next set of 16 bits have the values &lt;code&gt;0000 0011&lt;/code&gt; and &lt;code&gt;0001 0100&lt;/code&gt;. The first 8 bits are the address of the target register. Which, following the pattern above, specifies the target register is at offset &lt;code&gt;0x3&lt;/code&gt; which corresponds to the 3rd line of the LED matrix. After the second 8 bits are written to the register the LED matrix will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-*-----*
--*---*-
---*-*--
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The next 5 sets of 16 bits, not shown in the diagram above, specify registers &lt;code&gt;0x4&lt;/code&gt; through &lt;code&gt;0x7&lt;/code&gt;, corresponding to the remaining rows of the LED matrix. The values written to those registers, &lt;code&gt;0000 1000&lt;/code&gt;, result in the following pattern which represents the letter &amp;ldquo;Y&amp;rdquo;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-*-----*
--*---*-
---*-*--
----*---
----*---
----*---
----*---
----*---
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The next section will provide some additional details about the SPI protocol and how to program the MAX7219.&lt;/p&gt;
&lt;h2 id=&#34;setup-and-code&#34;&gt;Setup and Code&lt;/h2&gt;
&lt;p&gt;The diagram below illustrates how to wire the breadboard to work with the MAX7219 LED dot matrix module example. If you&amp;rsquo;re unfamiliar  with breadboards and breadboard diagrams this &lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;breadboard tutorial&lt;/a&gt; should be helpful.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/spiwiringdiagram.png&#34; align=&#34;center&#34; width=&#34;700&#34; height=&#34;350&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: Sunfounder&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The yellow wire is connected to the SPIMOSI pin (GPIO pin 10) on the Raspberry Pi and the DIN pin on the MAX7219. The blue wire is connected to SPISCLK or SCLK (GPIO pin 11) on the Raspberry Pi and the CLK pin on the MAX7219. The green wire is connected to SPICE0 or CE0 (GPIO pin 8) on the Raspberry Pi and the CS pin on the MAX7219. The red and black wires are connected to 5 volt power/VCC and ground/GND respectively.&lt;/p&gt;
&lt;p&gt;The next section will describe the main program that controls the MAX7219. The section following that describes the code that directly controls the I/O functions using the BCM2835 registers.&lt;/p&gt;
&lt;h3 id=&#34;controlling-the-max7219---main-program&#34;&gt;Controlling the MAX7219 - main program&lt;/h3&gt;
&lt;p&gt;I mentioned earlier that there are 2 approaches to reading this article. The first approach, the simplist, just involves reading this section. The next section, &lt;a href=&#34;./#controlling-a-dot-matrix-display---interacting-with-the-bcm2835&#34;&gt;Controlling a dot matrix display - interacting with the BCM2835&lt;/a&gt;, is more advanced and may be skipped.&lt;/p&gt;
&lt;p&gt;The code in this section and the next references functions prefixed by &lt;code&gt;bcm_&lt;/code&gt;. All of these functions, with very minor changes, were taken from the &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835 C Library&lt;/a&gt; written by Mike McCauley. When using that library with this code simply substitute all instances of &lt;code&gt;bcm_&lt;/code&gt; with &lt;code&gt;bcm2835_&lt;/code&gt;. The &lt;code&gt;bcm_&lt;/code&gt; funcs were created so I could add explanatory comments and to  make the BCM2835 code more easily accessible in this article. The &lt;code&gt;bcm_&lt;/code&gt; functions are described in more detail in the following section.&lt;/p&gt;
&lt;h4 id=&#34;global-variables&#34;&gt;Global variables&lt;/h4&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/94636963e3658ff55944c8e4e7faa139.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This first code snippet shows how to create a character to be displayed on the MAX7219 dot matrix display module. The 2 dimensional matrix &lt;code&gt;disp1&lt;/code&gt; contains a set of rows, &lt;code&gt;NUM_CHARS&lt;/code&gt;, each of which define a particular character to be displayed. Each column in the matrix, &lt;code&gt;MATRIX_ROW&lt;/code&gt;, defines which LEDs in a single MAX7219 LED row to turn on in the dot matrix display module. The MAX7219 display module is an 8X8 array of LEDs. In the code snippet above the matrix contains 3 rows with 8 columns. The first cell at &lt;code&gt;disp1[0][0]&lt;/code&gt; contains the hex value &lt;code&gt;0x3C&lt;/code&gt;. This defines which LEDs to turn on in the first row, of 8 rows, of the display module. &lt;code&gt;0x3C&lt;/code&gt; translates to &lt;code&gt;0011 1100&lt;/code&gt;. Each digit specifies which LED in the row will be turned on. &lt;code&gt;0x3C&lt;/code&gt; specifies that the middle 4 LEDs in the first row of 8 LED rows will be turned on. &lt;code&gt;disp[0][1]&lt;/code&gt; contains the hex value &lt;code&gt;0x42&lt;/code&gt; which converts to the binary number &lt;code&gt;0100 0010&lt;/code&gt; which specifies that the 2nd and 7th LEDs in the second row of 8 LED rows will be turned on. The dot matrix display will look like this after these 2 cells are displayed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--****--
-*----*-
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LED cells with &lt;code&gt;-&lt;/code&gt;s are turned off, cells with &lt;code&gt;*&lt;/code&gt;s are turned on. Once all 8 cells from &lt;code&gt;disp1[0][0]&lt;/code&gt; to &lt;code&gt;disp1[0][7]&lt;/code&gt; are displayed the following character, a zero, will be displayed on the dot matrix module:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--****--
-*----*-
-*----*-
-*----*-
-*----*-
-*----*-
-*----*-
--****--
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The remaining &lt;code&gt;disp1&lt;/code&gt; rows define the rest of the characters and shapes that will be displayed by the program.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;http://robojax.com/learn/arduino/8x8LED/&#34;&gt;Sprint Generator for LED Matrix 8x8&lt;/a&gt; is a tool that helps generate the hex numbers needed to cause an LED matrix to display a given shape.&lt;/p&gt;
&lt;h4 id=&#34;main&#34;&gt;main()&lt;/h4&gt;
&lt;p&gt;This next code snippet shows the code for the &lt;code&gt;main&lt;/code&gt; function. Each of the significant lines will be explained below the snippet.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/93f04126727ece94481a7d56d9daab9b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 1&lt;/strong&gt; explains that the GPIO pins are hardcoded. This is because the program is using the &lt;code&gt;SPIO&lt;/code&gt; interface. The other 2 interfaces, &lt;code&gt;SPI1&lt;/code&gt; and &lt;code&gt;SPI2&lt;/code&gt; are auxilary SPI interfaces. Section 2.3, page 20, of the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;The BCM2835 ARM Peripherals guide&lt;/a&gt; states the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The two universal SPI masters are secondary low throughput SPI interfaces.
&amp;hellip;
The universal SPI master has been developed to work even with the most &amp;lsquo;non-standard&amp;rsquo; SPI devices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Reading between the lines, &amp;lsquo;secondary&amp;rsquo;, low-throughput&amp;rsquo; and &amp;lsquo;non-standard&amp;rsquo; don&amp;rsquo;t seem to be attributes we want to work with. The &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835&lt;/a&gt; library, which is the basis for the code presented in this article, supports &lt;code&gt;SPI0&lt;/code&gt; as the primary interface. It has auxilary functions to support the &lt;code&gt;SPI1&lt;/code&gt; interface, and no functions to support &lt;code&gt;SPI2&lt;/code&gt;. Given all this I elected to hard-code the &lt;code&gt;SPI0&lt;/code&gt; interface. Note, the BCM2835 ARM Peripherals guide specifies that GPIO pins 7-11 are dedicated to &lt;code&gt;SPI0&lt;/code&gt; when the ALT0 function is specified.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; defines a signal handler to provide graceful shutdown of the application if it is killed (e.g., ^C).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 8&lt;/strong&gt;, the call to &lt;a href=&#34;./#bcm_init&#34;&gt;bcm_init()&lt;/a&gt;, initializes the the BCM2835. Among other things, it finds the appropriate memory offsets for the I/O peripheral&amp;rsquo;s address space and maps &lt;code&gt;/dev/mem&lt;/code&gt; so that it is usable for programming the I/O functions. &lt;code&gt;bcm_init()&lt;/code&gt; is a low-level function that will be described in detail in the next section, &lt;a href=&#34;./#controlling-a-dot-matrix-display---interacting-with-the-bcm2835&#34;&gt;Controlling a dot matrix display - interacting with the BCM2835&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 13&lt;/strong&gt;, &lt;a href=&#34;./#init_spi&#34;&gt;init_spi()&lt;/a&gt;, initializes the SPI interface which includes setting the I/O function on the GPIO pins to ALT0 (enables SPI0).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 14&lt;/strong&gt;, &lt;code&gt;Delay_xms(50);&lt;/code&gt;, causes a short delay, 50ms, to give the spi interface time to complete initializing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 15&lt;/strong&gt;, &lt;a href=&#34;./#init_max7219&#34;&gt;Init_MAX7219()&lt;/a&gt;, initializes the MAX7219 display module. Among other things it sets the brightness of the display. Like the BCM2835, its functionality is controlled by a set of registers. Comments in the function definition below provide additional information about what it does.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 18-37&lt;/strong&gt; are the heart of the &lt;code&gt;main&lt;/code&gt; function. For each row in the &lt;code&gt;disp1&lt;/code&gt; and &lt;code&gt;scrollDisp&lt;/code&gt; arrays, it writes an entire row&amp;rsquo;s values to the display module resulting in a character being displayed (e.g., &lt;code&gt;0&lt;/code&gt;). &lt;strong&gt;Lines 29-36&lt;/strong&gt; demonstrate how to create a simple scrolling display.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 40 ad 41&lt;/strong&gt;, &lt;a href=&#34;./#bcm_spi_end&#34;&gt;bcm_spi_end()&lt;/a&gt; and &lt;a href=&#34;./#bcm_close&#34;&gt;bcm_close()&lt;/a&gt; reset the BCM2835 GPIO functionality and release resources (e.g., &lt;code&gt;/dev/mem&lt;/code&gt;).&lt;/p&gt;
&lt;h4 id=&#34;init_spi&#34;&gt;init_spi()&lt;/h4&gt;
&lt;p&gt;This code snippet shows how the SPI interface is initialized.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/f57bf0d0d8282a0db0eea46515db895c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt;, &lt;a href=&#34;./#bcm_spi_begin&#34;&gt;bcm_spi_begin()&lt;/a&gt;, is another low level function that interfaces with the BCM2835. As the comments state, it&amp;rsquo;s responsible for setting GPIO pins 7-11 to alternate function 0, which for those pins, enables the SPI0 interface. It&amp;rsquo;ll be covered in more detail in the next section.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 6&lt;/strong&gt;, &lt;a href=&#34;./#bcm_spi_setbitorder&#34;&gt;bcm_spi_setBitOrder()&lt;/a&gt;, is more complicated depending on whether you understand the concept of most significant and least significant bit ordering (MSB and LSB). Simplistically, the most significant bit in a binary number is the left-most bit. Likewise the least significant bit in a binary number is the right-most bit. In the binary number &lt;code&gt;100&lt;/code&gt; the MSB is &lt;code&gt;1&lt;/code&gt; and the LSB is &lt;code&gt;0&lt;/code&gt;. What&amp;rsquo;s significant about this is when data is transferred serially bit ordering specifies which bit is sent first. In MSB the most significant bit is sent first. So thinking of the receiving end of a serial data transfer as a stack, the MSB gets pushed to the stack first. The rest of the bits are transferred moving from the MSB to the LSB. So if the number &lt;code&gt;100&lt;/code&gt; is tranferred serially in MSB order it would be represented as &lt;code&gt;001&lt;/code&gt; on the receiving end. Different devices expect data in either MSB or LSB.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s important to know what the device you&amp;rsquo;re interacting with expects with regard to bit order. The BCM2835 SPI0 expects bits in MSB. SPI1 and SPI2 can acccept either MSB or LSB as specified in bit 6 of the AUXSPI0/1_CNTL0 Register (see &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 ARM Peripherals guide&lt;/a&gt;, page 22-23 for details). &lt;code&gt;bcm_spi_setBitOrder()&lt;/code&gt; allows the specification of either MSB or LSB. However, for SPI data transfers the data must be sent in MSB. So for SPI, this function is basically a no-op. For a visual representation of how data is transmitted to the MAX7219 see the &lt;a href=&#34;https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf&#34;&gt;MAX7219 datasheet&lt;/a&gt;, &lt;em&gt;Functional Diagram&lt;/em&gt;, at the bottom of page 5. At the very bottom-middle of the page there is a diagram of how data is transmitted via the &lt;code&gt;DIN&lt;/code&gt; pin into the bit positions of the MAX7219&amp;rsquo;s internal shift register. At the last clock pulse (the &lt;code&gt;CLK&lt;/code&gt; pin) the LSB is located in bit offset &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;D0&lt;/code&gt; and the MSB is at bit offset &lt;code&gt;15&lt;/code&gt;, &lt;code&gt;D15&lt;/code&gt;. If you&amp;rsquo;d like to see a more complete example of bit ordering see my article &lt;a href=&#34;http://youngkin.github.io/post/shiftregistersevensegdisplay/#what-is-a-shift-register-and-what-is-it-good-for&#34;&gt;Raspberry Pi GPIO in Go and C - Using a Shift Register &amp;amp; 7 Segment Display&lt;/a&gt;. It describes in detail how bit ordering is used in conjunction with a shift register. If you&amp;rsquo;d like more information on forcing the BCM2835 SPI interface to send data in LSB see this Google Groups thread on &lt;a href=&#34;https://groups.google.com/g/bcm2835/c/9H6rDEKTru0?pli=1&#34;&gt;BCM2835 SPI communication - LSB first&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 9&lt;/strong&gt;, &lt;a href=&#34;./#bcm_spi_setdatamode&#34;&gt;bcm_spi_setDataMode(BCM_SPI_MODE0)&lt;/a&gt; sets the clock polarity and phase. If you don&amp;rsquo;t understand what this means, just accept this setting and move on. It is the default in most cases. If you&amp;rsquo;d like more detail on this see &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 ARM Peripherals guide&lt;/a&gt;, section 10 - SPI, figure 10-3, on page 149.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 10&lt;/strong&gt;, &lt;a href=&#34;./#bcm_spi_setclockdivider&#34;&gt;bcm_spi_setClockDivider(BCM_SPI_CLOCK_DIVIDER_256)&lt;/a&gt; sets the frequency of the SPI clock (SPISCLK, GPIO pin 11 on the Rasberry Pi). In a nutshell, the Raspberry Pi&amp;rsquo;s system clock is divided by the parameter in this function to set the frequency of the SPI clock. 256 is a good default value to use in most cases. See &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h&#34;&gt;bcmfuncs.h&lt;/a&gt; or the &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/group__constants.html#gaf2e0ca069b8caef24602a02e8a00884e&#34;&gt;BCM2835 C library documentation&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 12&lt;/strong&gt;, &lt;a href=&#34;./#bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel()&lt;/a&gt; sets the &lt;code&gt;Max7219_pinCS&lt;/code&gt; pin, the SPICE0/GPIO pin 8, to the GPIO output function. This allows the program to write values, HIGH or LOW, to the pin. This is the SPI chip select/chip enable pin. This pin directs the MAX7219 to accept data from the Raspberry Pi. This pin needs to be set to LOW when sending data to the MAX7219. The &lt;code&gt;bcm_gpio_fsel()&lt;/code&gt; function will be described in more detail below.&lt;/p&gt;
&lt;h4 id=&#34;init_max7219&#34;&gt;Init_MAX7219()&lt;/h4&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/f21fea670065c66ee7378375a4cf79ec.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This code snippet initializes the MAX7219 display module. Like the BCM2835, the MAX7219&amp;rsquo;s capability is controlled via a set of registers. &lt;strong&gt;Lines 3 thru 9&lt;/strong&gt; set the various control registers to various values.&lt;/p&gt;
&lt;p&gt;Taking &lt;strong&gt;line 1&lt;/strong&gt; as an example, it sets the MAX7219 register at offset &lt;code&gt;0x09&lt;/code&gt; to the value &lt;code&gt;0x00&lt;/code&gt;. The first parameter in &lt;a href=&#34;./#write_max7219&#34;&gt;Write_Max7219()&lt;/a&gt; specifies the address offset of the register. The second parameter specifies the value to write to the register. The registers with their offsets are described in the &lt;a href=&#34;https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf&#34;&gt;MAX7219 datasheet&lt;/a&gt;, &lt;em&gt;Table 2. Register Address Map&lt;/em&gt;, on page 7. &lt;em&gt;Table 1. Serial Data Format&lt;/em&gt; on page 6 describes how the data is laid out in each register. Each register is 16 bits long as described Table 1. There are 14 control registers. The name of each register is given in column 1 of Table 2 titled &lt;em&gt;Register&lt;/em&gt;. The offset of each register is given in the &lt;em&gt;Hex Code&lt;/em&gt; column. Looking again at the first argument to &lt;code&gt;Write_Max7219()&lt;/code&gt;, &lt;code&gt;0x09&lt;/code&gt;, we can see that this address refers to the &lt;em&gt;Decode Mode&lt;/em&gt; register which is at offset &lt;code&gt;0xX9&lt;/code&gt; as given in the &lt;em&gt;Hex Code&lt;/em&gt; column. The various LED rows associated with creating a character, symbol, or shape are controlled by registers &lt;em&gt;Digit 0&lt;/em&gt; through &lt;em&gt;Digit 7&lt;/em&gt;. The meaning of the values for each register, except the &lt;em&gt;Digitn&lt;/em&gt; registers, are provided in tables 3, 4, 7, 8, and 10. The second paramater of &lt;code&gt;Write_Max7219()&lt;/code&gt; is &lt;code&gt;0x00&lt;/code&gt;. Looking in table 4 we see this value means there is no decode set for digits 0-7.&lt;/p&gt;
&lt;p&gt;In a similar manner, &lt;strong&gt;lines 4 thru 9&lt;/strong&gt; will initialze the remaining registers as described in the comments.&lt;/p&gt;
&lt;h4 id=&#34;write_max7219&#34;&gt;Write_Max7219()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Write_Max7219()&lt;/code&gt; writes the data, &lt;code&gt;dat1&lt;/code&gt;, to the register located at address, &lt;code&gt;address1&lt;/code&gt;. Writes to the MAX7219 only take place a byte at a time. The first byte written is the register address. The second byte is the data.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/f4c4aa7d4c252ae8f7a6f208b1ae3876.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 1&lt;/strong&gt;, &lt;a href=&#34;#bcm_gpio_write&#34;&gt;bcm_gpio_write()&lt;/a&gt; uses the regular GPIO write method to set the chip select pin, &lt;code&gt;Max7219_pinCS&lt;/code&gt;, to LOW so the MAX7219 will accept data from the Raspberry Pi.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 6&lt;/strong&gt;, &lt;a href=&#34;#write_max7219_byte&#34;&gt;Write_Max7219_byte()&lt;/a&gt;, sends the &lt;code&gt;address1&lt;/code&gt; parameter to the MAX7219. As shown in the &lt;a href=&#34;https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf&#34;&gt;MAX7219 datasheet&lt;/a&gt;, &lt;em&gt;Functional Diagram&lt;/em&gt;, at the bottom of page 5, the target register&amp;rsquo;s address will be written to bit offsets 8 thru 11 (as documented in the datasheet, bits 12 through 15 will be ignored).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 7&lt;/strong&gt;, &lt;a href=&#34;#write_max7219_byte&#34;&gt;Write_Max7219_byte()&lt;/a&gt;, sends the &lt;code&gt;dat1&lt;/code&gt; parameter to the MAX7219. The &lt;code&gt;dat1&lt;/code&gt; bits will be written to the least significant bits, offsets 0 thru 7, in the MAX7219 shift register.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 8&lt;/strong&gt;, &lt;a href=&#34;#bcm_gpio_write&#34;&gt;bcm_gpio_write()&lt;/a&gt;, resets the &lt;code&gt;Max7219_pinCS&lt;/code&gt; pin back to HIGH to signal the end of the data transmission and to prevent the MAX7219 from accepting data.&lt;/p&gt;
&lt;h4 id=&#34;write_max7219_byte&#34;&gt;Write_Max7219_byte()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Write_Max7219_byte()&lt;/code&gt; is pretty straightforward. It takes the &lt;code&gt;data&lt;/code&gt; parameter and sends it to the SPI peripheral vi the &lt;a href=&#34;#bcm_spi_transfer&#34;&gt;bcm_spi_transfer()&lt;/a&gt; call. &lt;code&gt;bcm_spi_transfer()&lt;/code&gt; will be covered in more detail below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/55d94b43ae0c95cc1fec138de6166c44.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;controlling-the-max7219---direct-interaction-with-the-bcm2835&#34;&gt;Controlling the MAX7219 - direct interaction with the BCM2835&lt;/h3&gt;
&lt;p&gt;This section describes how the code interacts with and controls the GPIO peripherals, specifically setting the values of the various registers associated with the SPI I/O functionality of the BCM2835. Setting register values is used to control GPIO peripherals and reading register values allow the current state of the associated GPIO peripherals to be accessed.&lt;/p&gt;
&lt;p&gt;Many of these function descriptions are copied from the &lt;a href=&#34;https://youngkin.github.io/post/gpioprogramming/&#34;&gt;Raspberry Pi GPIO - Introduction To Programming Broadcom BCM2835 ARM Peripherals&lt;/a&gt; article. This is done to avoid constant cross referencing back to that article.&lt;/p&gt;
&lt;p&gt;The code for the file that contains this code can be found at &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.c&#34;&gt;gpio/ledblink/bcmfuncs.c&lt;/a&gt;. The associated header file can be found at &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h&#34;&gt;gpio/ledblink/bcmfuncs.h&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_init&#34;&gt;bcm_init()&lt;/h4&gt;
&lt;p&gt;The  &lt;a href=&#34;https://youngkin.github.io/post/gpioprogramming/#registers&#34;&gt;Registers in the Raspberry Pi GPIO&lt;/a&gt; section in the  &lt;em&gt;Introduction To Programming Broadcom BCM2835 ARM Peripherals&lt;/em&gt; article mentions that all operations on BCM2835 peripherals are accomplished by manipulating the registers associated for that type of peripheral. The purpose of &lt;code&gt;bcm_init()&lt;/code&gt; is to determine the address offsets for all the types of registers, e.g., GPIO, PWM, SPI, etc. so that the their associated peripherals can be controlled.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/5eb96cc009b06a09d61aca92f031896f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This snippet shows the beginning of the &lt;code&gt;bcm_init()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 10&lt;/strong&gt; opens the &lt;code&gt;BCM_RPI2_DT_FILENAME&lt;/code&gt;. As indicated in the comment, the &lt;code&gt;rb&lt;/code&gt; in the &lt;code&gt;fopen()&lt;/code&gt; call opens a binary file for reading. &lt;code&gt;BCM_RPI2_DT_FILENAME&lt;/code&gt; is defined in the associated &lt;code&gt;bcmfuncs.h&lt;/code&gt; header file. It&amp;rsquo;s value is &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt;. As stated in &lt;a href=&#34;https://www.kernel.org/doc/html/latest/devicetree/usage-model.html&#34;&gt;Linux and the Devicetree&lt;/a&gt;,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An operating system used the Device Tree to discover the topology of the hardware at runtime, and thereby support a majority of available hardware without hard coded information (assuming drivers were available for all devices).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;One of the pieces of information the device tree holds, and is important for our purposes, is the location and length of the I/O Peripherals partition in the BCM2835&amp;rsquo;s physical address space (see &lt;a href=&#34;https://youngkin.github.io/post/gpioprogramming/#addressing&#34;&gt;Introduction To Programming Broadcom BCM2835 ARM Peripherals - Addressing&lt;/a&gt; for details). Here&amp;rsquo;s a hex dump of the contents of &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt; on a Raspberry Pi 3B+ (the first 8 zeros are the address offset within /proc/device-tree/soc/ranges):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pi@pi-node1:/ $ hexdump -C /proc/device-tree/soc/ranges
00000000  7e 00 00 00 3f 00 00 00  01 00 00 00 40 00 00 00  |~...?.......@...|
00000010  40 00 00 00 00 00 10 00                           |@.......|
00000018
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We&amp;rsquo;ll refer back to this in this next code snippet. Per &lt;a href=&#34;https://www.devicetree.org/specifications/&#34;&gt;devicetree.org&lt;/a&gt;, in &lt;a href=&#34;https://github.com/devicetree-org/devicetree-specification/releases/download/v0.4-rc1/devicetree-specification-v0.4-rc1.pdf&#34;&gt;v0.4-rc1 of the Devicetree Specification&lt;/a&gt;, the &lt;code&gt;soc/ranges&lt;/code&gt; property is defined as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The ranges property provides a means of defining a mapping or translation between the address space of the bus (the child address space) and the address space of the bus node’s parent (the parent address space).
The format of the value of the ranges property is an arbitrary number of triplets of (child-bus-address, parent-bus-address, length)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the case of the I/O Peripherals address block, as described in &lt;a href=&#34;https://youngkin.github.io/post/gpioprogramming/#addressing&#34;&gt;Introduction To Programming Broadcom BCM2835 ARM Peripherals - Addressing&lt;/a&gt;, the &lt;em&gt;&amp;ldquo;child-bus-address&amp;rdquo;&lt;/em&gt; refers to the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;VC CPU Bus Addresses&amp;rdquo;&lt;/em&gt; memory space. The &lt;em&gt;&amp;ldquo;parent-bus-address&amp;rdquo;&lt;/em&gt; refers to the the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;ARM Physical Addresses&amp;rdquo;&lt;/em&gt; block. And the &lt;em&gt;&amp;ldquo;length&amp;rdquo;&lt;/em&gt; refers to the actual length of the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block. The Raspberry Pi 3B+ has a 32 bit address space so each of the values in the triple are 32 bits or 4 bytes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/40c162eaeef54c259d1345f18d9b85e1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet finds the &lt;em&gt;parent-bus-address&lt;/em&gt; and &lt;em&gt;length&lt;/em&gt; of the I/O peripherals block using the data from &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt;. Recall that the parent bus address is the second entry in the triplet that also defines the child bus address and length. From the hex dump above, here is that triplet (array cell 0 is at the far left, array cell 11 is at the far right):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7e 00 00 00 3f 00 00 00  01 00 00 00
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Note: The output of the command is somewhat different on a Raspberry Pi 4. It will look more like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pi@kubemaster:~ $ hexdump -C /proc/device-tree/soc/ranges
00000000  7e 00 00 00 00 00 00 00  fe 00 00 00 01 80 00 00  |~...............|
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this dump the starting address of the parent bus address is at offset 8, the value is &lt;code&gt;fe 00 00 00&lt;/code&gt;. For the Raspberry Pi 3 it&amp;rsquo;s at offset 4. In both cases the length of the the address is 4 bytes or 32 bits. The length of the I/O Peripherals partition starts at offset 12 and the value is &lt;code&gt;01 80 00 00&lt;/code&gt;. Although the code snippet above doesn&amp;rsquo;t reflect this difference, the code for the complete function does take this into account.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Lines 1 thru 4&lt;/strong&gt; shift the contents of the &lt;em&gt;parent-bus-address&lt;/em&gt;, &lt;code&gt;3f 00 00 00&lt;/code&gt;, the bytes at &lt;code&gt;buf&lt;/code&gt; offsets 4 thru 7, into &lt;code&gt;base_address&lt;/code&gt;. &lt;code&gt;3F&lt;/code&gt; is shifted into the high order byte of &lt;code&gt;base_address&lt;/code&gt;. The remaining &lt;code&gt;buf&lt;/code&gt; cells are likewise shifted into &lt;code&gt;base_address&lt;/code&gt; from left (most significant) to right (least significant byte). After shifting is complete &lt;code&gt;base_address&lt;/code&gt; will be set to &lt;code&gt;0x3F000000&lt;/code&gt;. Looking back at the diagram in &lt;a href=&#34;https://youngkin.github.io/post/gpioprogramming/#addressing&#34;&gt;Introduction To Programming Broadcom BCM2835 ARM Peripherals - Addressing&lt;/a&gt; you&amp;rsquo;ll notice it &lt;strong&gt;DOESN&amp;rsquo;T MATCH&lt;/strong&gt; the base address of &lt;code&gt;0x20000000&lt;/code&gt; in the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block in &lt;em&gt;ARM Physical Addresses&lt;/em&gt;. This is because the diagram in the Addressing section is for the Raspberry Pi 1. This offset is different in the Raspberry Pi models 2 &amp;amp; 3. And it&amp;rsquo;s different yet again in the Raspberry Pi 4 model.&lt;/p&gt;
&lt;p&gt;Moving on, in a similar manner to &lt;code&gt;base_address&lt;/code&gt;, &lt;strong&gt;lines 6 thru 9&lt;/strong&gt; get the &lt;em&gt;length&lt;/em&gt; by shifting from &lt;code&gt;buf&lt;/code&gt; offsets 8 thru 11 into &lt;code&gt;peri-size&lt;/code&gt;. For the Raspberry Pi 3B+, &lt;code&gt;0x01000000&lt;/code&gt; is the expected length of the address block.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/3f8ae5656e480195f3d7293061711016.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet completes obtaining the addressing information from &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt;. Specifically it validates that the &lt;em&gt;&amp;ldquo;child-bus-address&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;parent-bus-address&amp;rdquo;&lt;/em&gt; have the expected values. Recall that the &lt;em&gt;&amp;ldquo;child-bus-address&amp;rdquo;&lt;/em&gt; is the first value in the addresses/length triplet, &lt;code&gt;buf&lt;/code&gt; offsets 0 thru 3. Lines 1 thru 6 do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Lines 1 thru 4&lt;/strong&gt; verify that the first 4 bytes of &lt;code&gt;buf&lt;/code&gt;, the &lt;em&gt;child-bus-address&lt;/em&gt;, is &lt;code&gt;0x7E000000&lt;/code&gt; as defined by the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;VC CPU Bus Addresses&amp;rdquo;&lt;/em&gt; memory space. We also saw this in the hex dump above where the first 32 bits, the &lt;em&gt;child-bus-address&lt;/em&gt;, contained the value &lt;code&gt;7e 00 00 00&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Line 5&lt;/strong&gt; verifies that the &lt;em&gt;parent-bus-address&lt;/em&gt;, &lt;code&gt;base_address&lt;/code&gt;, matches one of the expected base addresses for Raspberry Pi models 1 thru 4.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Lines 7 and 8&lt;/strong&gt; then set the base address and length of the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block to the variables that will be used in the rest of the program. The important thing about this line is that it casts the source variables to the types expected by the target variables.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/26f58efe4fdfed3eedf800ae8e167ef4.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next snippet maps the BCM2835&amp;rsquo;s &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;ARM Physical Addresses&amp;rdquo;&lt;/em&gt; memory space from &lt;code&gt;/dev/mem&lt;/code&gt; so that it can be safely used in the program.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 1&lt;/strong&gt; first checks to see if the user running the program is running as &lt;em&gt;root&lt;/em&gt; (either &lt;em&gt;root&lt;/em&gt; user or &lt;em&gt;sudo&lt;/em&gt;). If not, the &lt;code&gt;/dev/mem&lt;/code&gt; device can&amp;rsquo;t be used. &lt;code&gt;/dev/mem&lt;/code&gt; provides unrestricted access to the CPU&amp;rsquo;s memory. As this is obviously a dangerous thing to do its use is restricted to &lt;em&gt;root&lt;/em&gt;. There is an alternative to &lt;code&gt;/dev/mem&lt;/code&gt;, &lt;code&gt;/dev/gpio&lt;/code&gt;. This will be shown later in this section.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; opens &lt;code&gt;/dev/mem&lt;/code&gt; in preparation to the mapping operation. &lt;code&gt;O_SYNC&lt;/code&gt; specifies that the write to &lt;code&gt;/dev/mem&lt;/code&gt; must be completed before any write operations return (i.e., the write isn&amp;rsquo;t cached).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 13&lt;/strong&gt; assigns the &lt;code&gt;bcm_peripherals&lt;/code&gt; variable to the memory block at offset and length, &lt;code&gt;bcm_peripherals_base&lt;/code&gt; and &lt;code&gt;bcm-peripherals_size&lt;/code&gt;, of the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block. This mapping effectively restricts the program&amp;rsquo;s access to the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block of physical memory.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/583d622c0db398a6316f997b66cc219c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet calculates the offsets for the various types of registers (e.g., GPIO, PWM, SPI, etc). Each offset is relative to the value of &lt;code&gt;bcm_peripherals&lt;/code&gt; which was the result of a &lt;code&gt;mapmem()&lt;/code&gt; operation in the previous snippet. So to get the address of a register set like the GPIO register set we would add &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt; to the &lt;code&gt;bcm_peripherals&lt;/code&gt; base address. But you may have noticed the code divides these offsets by 4 prior to adding them to &lt;code&gt;bcm_peripherals&lt;/code&gt;. These offsets, e.g., &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt;, which are specified as integers, point to specific byte addresses, i.e., at 8 bit boundaries. &lt;code&gt;bcm_peripherals&lt;/code&gt; is specified as a &lt;code&gt;uint32_t*&lt;/code&gt;, a pointer. You can&amp;rsquo;t just naively add an integer to a pointer. You may recall that pointer arithmetic operates on a pointer variable based on the size of the type of the associated variable. For &lt;code&gt;unint32_t&lt;/code&gt;&#39;s their size is 32 bits or 4 bytes. Adding 1 to a &lt;code&gt;uint32_t&lt;/code&gt; pointer will result in that pointer pointing to the next &lt;code&gt;uint32_t&lt;/code&gt;, which starts 4 bytes from the current position. Naively adding offsets like &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt; to &lt;code&gt;bcm_peripherals&lt;/code&gt; will result in &lt;code&gt;bcm_peripherals&lt;/code&gt; pointing to a position in memory that is 4 &lt;code&gt;uint32_t&lt;/code&gt;s past the current position, not 1 &lt;code&gt;uint32_t&lt;/code&gt; past the current position which is what we want. This is why each register type offset like &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt; is divided by 4 prior to adding it to &lt;code&gt;bcm_peripherals&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re new to C you may not be aware that pointer arithmetic is inherently dangerous. It can be hard to know exactly what a pointer will reference as a result of pointer arithmetic. The pointer could be an unexpected type or have an unexpected value. This can lead to unexpected behavior which can be very difficult to debug. In some cases, for example performing division, pointing to an unexpected place that contains the value zero will lead to the program abruptly ending (with a segmentation fault). This is good, this way you know something is wrong and you even know where it went wrong. A pointer may even point outside the program&amp;rsquo;s address space the program which may lead to system crashes. In our case however the register locations and associated types are very well known and using pointers is relatively safe. That is, as long as we perform pointer arithmetic correctly&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;bcm_spi_begin&#34;&gt;bcm_spi_begin()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_spi_begin()&lt;/code&gt; intializes the SPI interface on the BCM2835.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/e6ab21fc1f9c7dca87d1e439899c0042.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 2&lt;/strong&gt; defines the 32 bit address variable, &lt;code&gt;paddr&lt;/code&gt;, that will contain the address of the GPIO register that we&amp;rsquo;ll manipulate.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 4 &amp;amp; 5&lt;/strong&gt; verify that the SPI0 register offset was successfully initialized in &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt;. Prior to calling &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; all register set offsets are set to the value &lt;code&gt;MAP_FAILED&lt;/code&gt; to prevent the program from running if &lt;code&gt;bcm_init()&lt;/code&gt; wasn&amp;rsquo;t called or didn&amp;rsquo;t complete successfully.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 7 thru 11&lt;/strong&gt; call &lt;a href=&#34;#bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel()&lt;/a&gt; to define the alternate function, &lt;code&gt;BCM_GPIO_FSEL_ALT0&lt;/code&gt; or alternate function zero, that is used to set the I/O functionality of the pins referenced by the &lt;code&gt;BCM_GPIO_P1_*&lt;/code&gt; variables. Note that the comments to the left specify which SPI pins are being set, e.g., &lt;code&gt;CE1&lt;/code&gt; (Chip Select/Chip Enable). These pins, when set to alternate function 0, implement the SPI protocol.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 13&lt;/strong&gt; sets &lt;code&gt;paddr&lt;/code&gt; to the offset to the SPI0 address set plus the offset of the BCM2825 SPI Master Control and Status register (CS) as described on page 152 of &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 Peripherals guide&lt;/a&gt; (using the abbreviation &lt;em&gt;&amp;ldquo;CS&amp;rdquo;&lt;/em&gt; in this case is kind of confusing, but in this context this is not a &amp;ldquo;chip select&amp;rdquo; offset). Note that the &lt;code&gt;BCM_SPI0_CS&lt;/code&gt; offset is divided by 4. The reason why was discussed in the discussion in the &lt;a href=&#34;./#bcm_init&#34;&gt;bcm_init&lt;/a&gt; section above.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 14&lt;/strong&gt; uses the &lt;a href=&#34;#bcm_peri_write&#34;&gt;bcm_peri_write()&lt;/a&gt; function to write zeros to SPI Control and Status (CS) register pointed at by &lt;code&gt;paddr&lt;/code&gt;. As per the BCM2835 ARM Peripherals guide, page 155, setting the 1 byte field at this offset sets the Chip Select field, in the CS register (Control and Status), to 0&amp;rsquo;s which specifies chip select pin 0. This matches the specification of the Raspberry Pi pin &lt;code&gt;BCM_GPIO_P1_24&lt;/code&gt;, GPIO pin 8, which is the &lt;code&gt;CE0&lt;/code&gt; pin (chip enable/chip select pin 0).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 17&lt;/strong&gt;, as the comment suggests, uses &lt;a href=&#34;#bcm_peri_write&#34;&gt;bcm_peri_write_nb()&lt;/a&gt; to clear the transmission and receive FIFOs. Again, looking at page 155 of the BCM2835 ARM Peripherals guide, we can see that the &lt;code&gt;CLEAR&lt;/code&gt; field in the &lt;em&gt;CS&lt;/em&gt; register is at bit offsets 4 and 5. It gives the bit values for clearing the FIFOs, &lt;code&gt;1&lt;/code&gt; in each bit. The value specified by &lt;code&gt;BCM_SPI0_CS_CLEAR&lt;/code&gt; is &lt;code&gt;0x30&lt;/code&gt; (see the &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h&#34;&gt;bcmfuncs.h file&lt;/a&gt;). Converting this to binary we get &lt;code&gt;0011 0000&lt;/code&gt;. Bits 4 and 5 are indeed set to 1 so these bits will be set in the &lt;code&gt;CS&lt;/code&gt; register.&lt;/p&gt;
&lt;h4 id=&#34;bcm_spi_setbitorder&#34;&gt;bcm_spi_setBitOrder()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_spi_setBitOrder()&lt;/code&gt; sets the bit order, MSB (1) or LSB (0), of the SPI interface.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/0effc556bd01ef335e31fde59cbdabf1.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;bcm_spi_setdatamode&#34;&gt;bcm_spi_setDataMode()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_spi_setDataMode()&lt;/code&gt; specifies the clock polarity and phase to be used for data transfers.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/adcf8426e441f223eb592bb7c21e8ad6.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; sets &lt;code&gt;paddr&lt;/code&gt;, the memory offset for the SPI0 Control and Status (CS) register from the base address of the SPI0 register set. Recall from the &lt;a href=&#34;./#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; section, line 13, that the register offsets need to be divided by 4.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; calls &lt;a href=&#34;#bcm_peri_set_bits&#34;&gt;bcm_peri_set_bits()&lt;/a&gt; to set the bits in the SPI0 CS register to the bit pattern specified by &lt;code&gt;mode&lt;/code&gt;. The polarity and phase bits, &lt;code&gt;BCM_SPI0_CS_CPOL&lt;/code&gt; (&lt;code&gt;0x8&lt;/code&gt;) and &lt;code&gt;BCM_SPI0_CS_CPHA&lt;/code&gt; (&lt;code&gt;0x4&lt;/code&gt;) respectively, are masks that ensure that only those bits in the SPI0 CS register are set. See the &lt;a href=&#34;./#bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel() section&lt;/a&gt;, line 5, for more details on how masking works.&lt;/p&gt;
&lt;h4 id=&#34;bcm_spi_setclockdivider&#34;&gt;bcm_spi_setClockDivider()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_spi_setClockDivider()&lt;/code&gt; is used to set the frequency of the SPI Clock (SCLK). It accomplishes this by dividing the system&amp;rsquo;s clock frequency by the &lt;code&gt;divider&lt;/code&gt; parameter. See &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h&#34;&gt;bcmfuncs.h&lt;/a&gt; or the &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/group__constants.html#gaf2e0ca069b8caef24602a02e8a00884e&#34;&gt;BCM2835 C library documentation&lt;/a&gt; for more details.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/165a9ed933f006f7fdb747850e37befb.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; sets &lt;code&gt;paddr&lt;/code&gt; to the memory offset for the SPI clock (&lt;code&gt;BCM_SPI0_CLK&lt;/code&gt;) register from the base address of the SPI0 register set. Recall from the &lt;a href=&#34;./#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; section, line 13, that the register offsets need to be divided by 4.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; calls &lt;a href=&#34;#bcm_peri_write&#34;&gt;bcm_peri_write()&lt;/a&gt; to set the divider value.&lt;/p&gt;
&lt;h4 id=&#34;bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_fsel&lt;/code&gt; is responsible for setting the I/O function associated with a given pin. There are a total of 8 functions available. One defines that the associated pin is to be set as an input pin meaning that it will be read from. Another function defines the associated pin as an output pin meaning the pin will be written to. The remaining 6 are referred to as &amp;ldquo;alternate functions&amp;rdquo; and are given names like &amp;ldquo;alternate function 0&amp;rdquo;. The I/O function that is assigned for the various alternate functions is different for the various GPIO pins. For example, setting BCM GPIO pin 17 to alternate function 4 defines its I/O function to be SPI. It actually defines the pin to be a specific subset of SPI functionality called chip enable or chip select, but that is a topic for a later article. Recall that in &lt;code&gt;main()&lt;/code&gt; above, the function is being set to &lt;code&gt;BCM_GPIO_FSEL_OUTP&lt;/code&gt; which defines &lt;code&gt;pin&lt;/code&gt; to be an output pin.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/dc45d2130865d79d989828fea35746d7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;There&amp;rsquo;s quite a bit going on in this function even though it is quite short.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 1&lt;/strong&gt; defines the function as taking two parameters, &lt;code&gt;pin&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt;. It is fairly obvious that &lt;code&gt;pin&lt;/code&gt; is the pin whose function is to be assigned. &lt;code&gt;mode&lt;/code&gt; is the I/O function to associate with &lt;code&gt;pin&lt;/code&gt;. &lt;code&gt;mode&lt;/code&gt; is actually a bit pattern to be assigned to a particular register offset. The bit pattern assignments are defined in the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;The BCM2835 I/O Peripherals datasheet&lt;/a&gt; in section 6, &lt;strong&gt;GPIO&lt;/strong&gt;, on page 92. The patterns are defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000 = GPIO Pin X is an input
001 = GPIO Pin X is an output
100 = GPIO Pin X takes alternate function 0
101 = GPIO Pin X takes alternate function 1
110 = GPIO Pin X takes alternate function 2
111 = GPIO Pin X takes alternate function 3
011 = GPIO Pin X takes alternate function 4
010 = GPIO Pin X takes alternate function 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is some additional background needed to understand the rest of the function. First, the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;, section 6, page 91, states that a total of 54 GPIO pins are addressable via the function select registers (GPFSEL0-GPFSEL5). Each function select register is 32 bits long. Since each of the function select patterns above are 3 bits long, each function select register can specify the I/O function for 10 pins with 2 bits left over. Ten pins per register and a total of 54 pins explains why there are 6 function select registers numbered 0 thru 5. The math that follows is derived from this information.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt;, &lt;code&gt;volatile uint32_t* paddr = bcm_gpio + BCM_GPFSEL0/4 + (pin/10);&lt;/code&gt;, defines the register offset, &lt;code&gt;paddr&lt;/code&gt;, of the bits that will be set according to &lt;code&gt;mode&lt;/code&gt;. &lt;code&gt;BCM_GPFSEL0&lt;/code&gt; is the base offset, in bytes, of the function select registers. Here&amp;rsquo;s an explanation of the arithmetic performed in this line.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Notice that pointer arithmetic is being performed. Recall that the result of pointer arithmetic is based on the type of the target variable (see the &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; section above). Since &lt;code&gt;uint32_t&lt;/code&gt;&#39;s are 4 bytes long &lt;code&gt;BCM_GPFSEL0&lt;/code&gt; needs to be divided  by 4 for the calculation to come out correctly. Hence &lt;code&gt;... paddr = bcm_gpio + BCM_GPFSEL0/4 ...&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Also recall that each register holds the function select information for 10 pins. For a given pin we need to determine which function select register, GPFSEL0 thru GPFSEL5, specifies the I/O function for a given pin. In C, the result of integer division that results in a fraction will be rounded down. So if we divide the pin number by 10, &lt;code&gt;(pin/10&lt;/code&gt;), we&amp;rsquo;ll get the offset to the correct function select register. So pin 9 will result in &lt;code&gt;9/10&lt;/code&gt; which equals 0, meaning pin 9&amp;rsquo;s function select location is in GPFSEL0. Likewise, pin 17&amp;rsquo;s, &lt;code&gt;17/10 = 1&lt;/code&gt;, function select register is GPFSEL1. And so on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Taken together, the equation &lt;code&gt;paddr = bcm_gpio + BCM_GPFSEL0/4 + (pin/10)&lt;/code&gt; results in the function select register offset appropriate for a given &lt;code&gt;pin&lt;/code&gt;. For pin 17 this will result in &lt;code&gt;paddr&lt;/code&gt; logically pointing to GPFSEL1 at address &lt;code&gt;0x7E20 0004&lt;/code&gt;, &lt;code&gt;7E&lt;/code&gt; being the bus address, &lt;code&gt;20004&lt;/code&gt; being the offset of the GPIO registers plus the offset of GPFSEL1, &lt;code&gt;4&lt;/code&gt;, from the beginning of the GPIO register set. I say logically because &lt;code&gt;bcm_gpio&lt;/code&gt; is an offset from an address returned as the result of a &lt;code&gt;mmap()&lt;/code&gt; operation. &lt;code&gt;mmap()&lt;/code&gt; returns a pointer into the process&amp;rsquo;s virtual memory whereas &lt;code&gt;0x7E20 0004&lt;/code&gt; is an address in the BCM2835&amp;rsquo;s &lt;em&gt;VC CPU Bus Addresses&lt;/em&gt; space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt;, &lt;code&gt;uint8_t   shift = (pin % 10) * 3;&lt;/code&gt;, calculates the location within the function select register for given pin&amp;rsquo;s function select value. Since we&amp;rsquo;ll use bit shifting to set the pin&amp;rsquo;s function select value this location becomes the number of bits to &lt;strong&gt;SHIFT&lt;/strong&gt; the pin&amp;rsquo;s function select value as provided in the &lt;code&gt;mode&lt;/code&gt; parameter. Building the calculation up we first need to find the pin&amp;rsquo;s logical location, that is, which 3 bit cell within the function select register (recall that each function select value is 3 bits long). The calculation for this is given by &lt;code&gt;shift = (pin % 10) ...&lt;/code&gt;. For pin 17 &lt;code&gt;(17 % 10) = 7&lt;/code&gt;. So pin 17&amp;rsquo;s 3 bit cell is located at the 7th 3-bit offset. Next we have to find the actual bit offset within the register. Since each function select value is 3 bits long each pin&amp;rsquo;s boundary is a multiple of 3, hence the complete calculation of &lt;code&gt;shift = (pin % 10) * 3&lt;/code&gt;. For pin 17 this results in &lt;code&gt;(17%10)*3&lt;/code&gt; which equals &lt;code&gt;7*3&lt;/code&gt; which results in an absolute bit offset of 21. Consulting the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide, section 6&lt;/a&gt;, on page 92,  we can confirm that pin 17&amp;rsquo;s offset within the GPFSEL0 register is in bit positions 21 thru 23.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s look at &lt;strong&gt;line 5&lt;/strong&gt;, &lt;code&gt;uint32_t  mask = BCM_GPIO_FSEL_MASK &amp;lt;&amp;lt; shift;&lt;/code&gt;. When setting a subset of bits to a given value we want to preserve the values of the surrounding bits. A mask is used to accomplish this. The mask contains a bit(s) that is in the position of the bit in the target value that we want to change. For example, in the bit pattern &lt;code&gt;0101 1111&lt;/code&gt;, if we want to set bit 6&amp;rsquo;s value from 1 to 0 we only need to define a bit sequence with 1 bit set. To create the most general solution we would just set the least significant bit(s). Since we only need a single bit set we would define the mask as hex number &lt;code&gt;0x1&lt;/code&gt;, which specifies the bit pattern &lt;code&gt;0000 0001&lt;/code&gt;. Next we need to shift this bit pattern as required so that the &lt;code&gt;1&lt;/code&gt; bit is moved to the correct position. In our example, since we want to change bit 6, we would left shift the mask pattern 6 bits to the left, e.g., &lt;code&gt;newMask = 0000 0001 &amp;lt;&amp;lt; 6&lt;/code&gt;. This results in &lt;code&gt;newMask&lt;/code&gt; equaling &lt;code&gt;0100 00000&lt;/code&gt;, which is puts the &lt;code&gt;1&lt;/code&gt; bit in position 6 as we desire. It&amp;rsquo;s possible that we could have defined the mask as &lt;code&gt;0100 0000&lt;/code&gt; outright, but this would not result in a general solution that would work for any mask needed to set a bit(s) in an arbitrary bit position, such as bits 21-23.&lt;/p&gt;
&lt;p&gt;As given in &lt;em&gt;bcmfuncs.h&lt;/em&gt; the value of &lt;code&gt;BCM_GPIO_FSEL_MASK&lt;/code&gt; is 0x7 or &lt;code&gt;0000 0111&lt;/code&gt;, this is because each GPIO function select pattern is 3 bits long. So this is a useful bit pattern for masking 3 bit sequences. If we shift this pattern by the &lt;strong&gt;SHIFT&lt;/strong&gt; of 21 as calculated in line 4 above we&amp;rsquo;ll get a 32 bit pattern that looks like this, &lt;code&gt;0000 0000 1110 0000 0000 0000 0000 0000&lt;/code&gt;. The mask is now in bit locations 21-23, which is the location of pin 17&amp;rsquo;s function select pattern in the GPFSEL1 function select register.&lt;/p&gt;
&lt;p&gt;In summary, &lt;strong&gt;line 5&lt;/strong&gt; creates the mask needed to set the 3 bit function select pattern as specified in the &lt;code&gt;mode&lt;/code&gt; parameter on the provided &lt;code&gt;pin&lt;/code&gt; parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 6&lt;/strong&gt;,&lt;code&gt;uint32_t  value = mode &amp;lt;&amp;lt; shift;&lt;/code&gt;, creates the new 3 bit value that will be placed into the GPFSEL1 register. Recall that GPFSEL1 is a 32 bit register. To use a 3 bit value such as &lt;code&gt;mode&lt;/code&gt; to set a 3 bit sequence at an arbitrary position, e.g., bits 21-23, we create a value mask that sets the bits in the desired position to the desired value. As with the mask above, the most general solution specifies that those bits be set starting in the least significant position. Let&amp;rsquo;s say in our example we want pin 17 to be set to alternate function 1. Looking at the bit patterns above we can see that the 3 bit value for alternate function 1 is &lt;code&gt;101&lt;/code&gt;. The &lt;code&gt;mode&lt;/code&gt; parameter will contain this value. To set pin 17 to alternate function 1 we need to shift &lt;code&gt;mode&lt;/code&gt;&#39;s bit pattern of &lt;code&gt;0000 0101&lt;/code&gt; 21 bits to the left. As with line 5, line 6 does this in a general way, &lt;code&gt;value = mode &amp;lt;&amp;lt; shift&lt;/code&gt;. Given our value of &lt;code&gt;mode&lt;/code&gt; and the calculated value of &lt;code&gt;shift&lt;/code&gt; we get the 32 bit &lt;code&gt;value&lt;/code&gt; of &lt;code&gt;0000 0000 1010 0000 0000 0000 0000 0000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So we now have the 4 variables needed to calculate the new value of the GPFSEL1 register, &lt;code&gt;paddr&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, &lt;code&gt;mask&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 7&lt;/strong&gt; calls the function &lt;a href=&#34;#bcm_peri_set_bits&#34;&gt;bcm_peri_set_bits()&lt;/a&gt; to complete this operation. This operation is done in a separate function since there are other register values that require setting as we will see later.&lt;/p&gt;
&lt;h4 id=&#34;bcm_gpio_write&#34;&gt;bcm_gpio_write()&lt;/h4&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/b40fcbd81d14eee0a73ed167cb464282.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;bcm_gpio_write()&lt;/code&gt; writes the 32 bit value to the specified &lt;code&gt;pin&lt;/code&gt;. It uses 2 helper functions, &lt;a href=&#34;#bcm_gpio_set-and-bcm_gpio_clr&#34;&gt;bcm_gpio_set()&lt;/a&gt; and &lt;a href=&#34;#bcm_gpio_set-and-bcm_gpio_clr&#34;&gt;bcm_gpio_clr()&lt;/a&gt;. The parameter &lt;code&gt;on&lt;/code&gt; is used to specify if the value for &lt;code&gt;pin&lt;/code&gt; should be set or cleared. There are a set of 4 GPIO registers, GPSET0 and GPSET1, and GPCLR0 and GPCLR1, which specify if the value of a pin is HIGH or LOW. HIGH corresponds to GPSETn value of 1. LOW corresponds to GPCLRn value of 1. When the value of &lt;code&gt;on&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; the GPSETn register associated with the value of &lt;code&gt;pin&lt;/code&gt; is set to 1. If &lt;code&gt;on&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; then the GPCLRn register associated with the value of &lt;code&gt;pin&lt;/code&gt; is set to 1. This raises the question, what if both the GPSETn and GPCLRn bits are set to &lt;code&gt;1&lt;/code&gt;? According the the BCM2835 ARM Peripherals guide, &amp;ldquo;&lt;em&gt;&amp;hellip; the bit will be set according to the last set/clear operation&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;GPSETn&amp;rsquo;s and GPCLRn&amp;rsquo;s values are only used when a pin&amp;rsquo;s I/O function is set to OUTPUT. Values of &lt;code&gt;0&lt;/code&gt; in these registers are ignored. Recall that the BCM2835 allows GPIO functions to be specified for 54 pins (vs. the expected 40). Since each pin requires 1 bit to specify whether it&amp;rsquo;s to be set or cleared a total of 54 bits is required. This explains why two 32 bit registers are needed for set and clear.&lt;/p&gt;
&lt;p&gt;The use of these registers is further described in section 6, page 95, of the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_peri_read&#34;&gt;bcm_peri_read()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_peri_read()&lt;/code&gt; will read the 32 bits starting at &lt;code&gt;paddr&lt;/code&gt; and return them to the caller as a 32 bit value. Unlike &lt;code&gt;bcm_fsel()&lt;/code&gt; and &lt;code&gt;bcm_peri_set_bits()&lt;/code&gt;, this function is quite simple.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/5ee1dbb21e3e4223492dc96adb61a5f8.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Lines 4 &amp;amp; 6&lt;/strong&gt; synchronize access to memory so that the read can&amp;rsquo;t be interrupted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; simply sets the return value, &lt;code&gt;ret&lt;/code&gt;, to the contents located at &lt;code&gt;paddr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s another version of this function called &lt;code&gt;bcm_peri_read_nb()&lt;/code&gt;. The difference between versions is that the &lt;code&gt;nb&lt;/code&gt; version is non-blocking, meaning that the &lt;code&gt;__sync_synchoronize()&lt;/code&gt; calls aren&amp;rsquo;t used.&lt;/p&gt;
&lt;h4 id=&#34;bcm_peri_write&#34;&gt;bcm_peri_write()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_peri_write()&lt;/code&gt; will set the 32 bits starting at &lt;code&gt;paddr&lt;/code&gt; to the value contained in &lt;code&gt;value&lt;/code&gt;. Like &lt;code&gt;bcm_peri_read()&lt;/code&gt; this function is quite simple.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/147e413e5293ddf57965d107995ab6dc.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Lines 3 and 5&lt;/strong&gt; synchronize access (lock) to the 32 bits starting at &lt;code&gt;paddr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; sets the 32 bits located at &lt;code&gt;paddr&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s another version of this function called &lt;code&gt;bcm_peri_write_nb()&lt;/code&gt;. The difference between versions is that the &lt;code&gt;nb&lt;/code&gt; version is non-blocking, meaning that the &lt;code&gt;__sync_synchoronize()&lt;/code&gt; calls aren&amp;rsquo;t used.&lt;/p&gt;
&lt;h4 id=&#34;bcm_gpio_set-and-bcm_gpio_clr&#34;&gt;bcm_gpio_set() and bcm_gpio_clr()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_gpio_set()&lt;/code&gt; and &lt;code&gt;bcm_gpio_clr()&lt;/code&gt; are twins in terms of their functionality. They only differ in which registers they operate on. &lt;code&gt;*set()&lt;/code&gt; operates on the GPSETn registers and &lt;code&gt;*clr()&lt;/code&gt; operates on the GPCLRn registers. They are responsible for setting the appropriate bit offset in the appropriate register for the provided &lt;code&gt;pin&lt;/code&gt; argument. This section will only describe &lt;code&gt;bcm_gpio_set()&lt;/code&gt;. With the exception of the register set operated on their implementations are identical. In fact, with the addition of another parameter to specify the starting offset they could be collapsed into a single function.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/95158df431e7c3b655e013dbc8160fff.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;In &lt;code&gt;bcm_gpio_set()&lt;/code&gt; &lt;strong&gt;line 3&lt;/strong&gt; calculates the address, &lt;code&gt;paddr&lt;/code&gt;, of the target register. &lt;code&gt;bcm_gpio&lt;/code&gt; is the starting offset of the GPIO registers. &lt;code&gt;BCM_GPSET0&lt;/code&gt; is the starting offset of the set and clear registers. Recall from the discussion in the &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; section above that pointer arithmetic is used to determine the memory offset to use for a given operation. This is why &lt;code&gt;BCM_GPSET0&lt;/code&gt; is divided by 4 in this operation. &lt;code&gt;pin/32&lt;/code&gt; is used to calculate which of the &lt;code&gt;GP*n&lt;/code&gt; registers is to be used for the given &lt;code&gt;pin&lt;/code&gt;. Recall that integer division always rounds down. So the result of &lt;code&gt;pin 17/32&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; which specifies that the first &lt;code&gt;GP*n&lt;/code&gt; register will be used. Consistent with &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 ARM Peripherals guide&lt;/a&gt;, pages 95 and 96, this is the correct offset within the correct register.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; calculates the bit position for the set/clear bit within the target GPSETn/GPCLRn register. Since each pin only uses a single bit the modulus (&lt;code&gt;%&lt;/code&gt;) operator will provide the proper location. For example, pin 17 will have the result of &lt;code&gt;17%32&lt;/code&gt; which is 17. This is the bit position for pin 17 within the GPSETn/GPCLRn registers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; then uses &lt;a href=&#34;#bcm_peri_write&#34;&gt;bcm_peri_write()&lt;/a&gt; to shift &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt; bits to the left, in order to write to the correct offset in the correct register. For pin 17 for example, the calculation on line 4, &lt;code&gt;17%32&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; is shifted 17 bits to the left.&lt;/p&gt;
&lt;p&gt;You may have noticed that unlike &lt;a href=&#34;./#bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel()&lt;/a&gt;, no mask was used to protect the other bits within the specified register. I&amp;rsquo;m not sure why this is the case. It&amp;rsquo;s odd because this approach will cause all the other bits in the register to be set to zero (0). I&amp;rsquo;m only speculating here, but I&amp;rsquo;m guessing it&amp;rsquo;s because zero values in these registers are ignored and as per the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;, page 95, &amp;ldquo;&lt;em&gt;&amp;hellip; the bit will be set according to the last set/clear operation&lt;/em&gt;&amp;rdquo;. I take this to mean that an output pin&amp;rsquo;s value will be set, &lt;code&gt;1&lt;/code&gt; for GPSETn and &lt;code&gt;0&lt;/code&gt; for GPCLRn, when a &lt;code&gt;1&lt;/code&gt; is written to the appropriate register and subsequent changes to &lt;code&gt;0&lt;/code&gt; will have no effect. However this is just an educated guess.&lt;/p&gt;
&lt;h4 id=&#34;bcm_spi_transfer&#34;&gt;bcm_spi_transfer()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_spi_transfer()&lt;/code&gt; writes and reads a single byte to the SPI0 FIFO bits in the SPI0 FIFO register. SPI transfers are full-duplex meaning that data is written to, and received from, the SPI slave device. See section 10, starting on page 153, of &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 ARM Peripherals guide&lt;/a&gt; for more details on the CS and FIFO register settings below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/25d33b168e77da125f655dbfe9d33f48.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; defines the &lt;code&gt;paddr&lt;/code&gt; variable which is the offset to the SPI0 CS register. Recall from the &lt;a href=&#34;./#bcm_init&#34;&gt;bcm_init() section&lt;/a&gt;, line 13, that these offsets need to be divided by 4.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; defines the &lt;code&gt;fifo&lt;/code&gt; variable which is the offset of the SPI0 FIFO register.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 7&lt;/strong&gt; uses &lt;a href=&#34;#bcm_peri_set_bits&#34;&gt;bcm_peri_set_bits()&lt;/a&gt; to clear the transmission and receive FIFOs in preparation for the data transfers. More on &lt;code&gt;bcm_peri_set_bits()&lt;/code&gt; follows below.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 10&lt;/strong&gt; uses &lt;a href=&#34;#bcm_peri_set_bits&#34;&gt;bcm_peri_set_bits()&lt;/a&gt; to set the &lt;code&gt;TA&lt;/code&gt; bit in the SPI0 CS register. The &lt;code&gt;TA&lt;/code&gt; bit is used to indicate that a SPI transfer is active.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 13&lt;/strong&gt; pauses execution until the FIFO register can accept data. The &lt;code&gt;BCM_SPI0_CS_TXD&lt;/code&gt; value is a mask that contains a &lt;code&gt;1&lt;/code&gt; in bit position 18, meaning the expression will return true if the &amp;ldquo;TX FIFO has space for at least 1 byte&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 17&lt;/strong&gt; writes to the FIFO register ensuring that the bytes sent are in MSB order (see &lt;a href=&#34;./#bcm_correct_order&#34;&gt;bcm_correct_order()&lt;/a&gt; above for details). It uses the non-blocking/non-synchronized version of  &lt;a href=&#34;#bcm_peri_write&#34;&gt;bcm_peri_write&lt;/a&gt; for the transfer, but I&amp;rsquo;m not sure why. It seems to me that the blocking/synchronized version would be safer to ensure that concurrent writes don&amp;rsquo;t conflict with each other.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 20&lt;/strong&gt; waits for the transfer to the SPI slave to complete.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 24&lt;/strong&gt; first reads from the SPI slave device then converts the output as needed to MSB order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 27&lt;/strong&gt; clears the &lt;code&gt;TA&lt;/code&gt; bit signifying that the SPI transfer is complete.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 29&lt;/strong&gt; returns the result of the read on &lt;strong&gt;line 24&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_correct_order&#34;&gt;bcm_correct_order()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_correct_order()&lt;/code&gt; ensures that data sent to SPI0 is in MSB order. See the &lt;a href=&#34;./#init_spi&#34;&gt;bcm_init_spi&lt;/a&gt; section, Line 6, for additional details.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/ec7f6597448fc8af53e0bd38ec236c2a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; reverses the bit order if the check on &lt;em&gt;line 4&lt;/em&gt; shows that the byte order is currently set to &lt;code&gt;BCM_SPI_BIT_ORDER_LSBFIRST&lt;/code&gt;. Per the comments from &lt;code&gt;bcm_byte_reverse_table&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* SPI bit order. BCM2835 SPI0 only supports MSBFIRST, so we instead 
 * have a software based bit reversal, based on a contribution by Damiano Benedetti
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The key point in this statement is that &lt;em&gt;&amp;ldquo;BCM2835 SPI0 only supports MSBFIRST&amp;rdquo;&lt;/em&gt;. The other 2 SPI I/O functions, &lt;code&gt;SPI1&lt;/code&gt; and &lt;code&gt;SPI2&lt;/code&gt; work with both MSB and LSB. See the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;, section &lt;em&gt;2.3.4 SPI register details&lt;/em&gt;, page 23 for more details. Specifically, bit 6 of the AUXSPI0/1_CNTL0 registers are used to specify MSB or LSB - &lt;em&gt;&amp;ldquo;Shift out MS bit first&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;If 1 the data is shifted out starting with the MS bit. (bit 15 or bit 11). If 0 the data is shifted out starting with the LS bit. (bit 0)&amp;quot;&lt;/em&gt;. Support for this was added in BCM2835 version 1.53. See this &lt;a href=&#34;https://groups.google.com/g/bcm2835/c/bkCc8mzq7io/m/DtmVmOyqAQAJ&#34;&gt;BCM2835 Google Groups thread&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h4 id=&#34;bcm_peri_set_bits&#34;&gt;bcm_peri_set_bits()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_peri_set_bits()&lt;/code&gt; writes the an updated value to address &lt;code&gt;paddr&lt;/code&gt; after applying the &lt;code&gt;mask&lt;/code&gt; to the provided &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/d88ef1fec18d9a8b587ec3dbbb4c1bf0.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; reads the current value from the provided address &lt;code&gt;paddr&lt;/code&gt; using &lt;a href=&#34;#bcm_peri_read&#34;&gt;bcm_peri_read()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; calculates the new value &lt;code&gt;v&lt;/code&gt;, from &lt;code&gt;value&lt;/code&gt; and the &lt;code&gt;mask&lt;/code&gt;, to be written to &lt;code&gt;paddr&lt;/code&gt;. Here&amp;rsquo;s an example to demonstrate how this somewhat complex line accomplishes this. This process is similar to the process explained in the &lt;a href=&#34;#bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel()&lt;/a&gt; section, line 5. It&amp;rsquo;s implemented in a different manner so it&amp;rsquo;s worth describing this alternate process for applying a mask.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0100&lt;/span&gt; 
mask  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;mask&lt;/code&gt; has bits 2 and 3 set to &lt;code&gt;11&lt;/code&gt;. This specifies that these are the bits to be reset (in this example). At the end of the process these 2 bits will be set to the values for those same bit as specified in &lt;code&gt;value&lt;/code&gt;, namely &lt;code&gt;01&lt;/code&gt;. The remaining bits in the current value stored at &lt;code&gt;paddr&lt;/code&gt; will remain unchanged.&lt;/p&gt;
&lt;p&gt;After reading the current contents of &lt;code&gt;paddr&lt;/code&gt; on line 3 above, &lt;code&gt;v&lt;/code&gt; is set to &lt;code&gt;1100 1011&lt;/code&gt;. Since &lt;code&gt;value&lt;/code&gt; above specifies that bits 2 and 3 should be set to &lt;code&gt;01&lt;/code&gt;, the new value written to &lt;code&gt;paddr&lt;/code&gt; is expected to be &lt;code&gt;1100 0111&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s build up the final value of &lt;code&gt;v&lt;/code&gt; step by step performed in &lt;strong&gt;line 4&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;mask   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1111&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0011&lt;/span&gt;
v       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1011&lt;/span&gt;
v&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;~&lt;/span&gt;mask &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0011&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We first take the complement of &lt;code&gt;mask&lt;/code&gt;, &lt;code&gt;~mask&lt;/code&gt; so we can reset bits 2 and 3 to &lt;code&gt;00&lt;/code&gt; while leaving the remaining bits of the original value &lt;code&gt;v&lt;/code&gt; unchanged. When we calcuate &lt;code&gt;v&amp;amp;~mask&lt;/code&gt; we get &lt;code&gt;1100 0011&lt;/code&gt;. This provides the desired result, all bits except 2 &amp;amp; 3 keep their current values.&lt;/p&gt;
&lt;p&gt;In the next step we calculate the new values of bits 2 and 3.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;value      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0100&lt;/span&gt;
mask       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1111&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt;
value&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mask &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0100&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If we &lt;code&gt;|&lt;/code&gt; (OR) this value with the result of &lt;code&gt;v&amp;amp;~mask&lt;/code&gt; we&amp;rsquo;ll get the final result as shown next&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;~&lt;/span&gt;mask                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0011&lt;/span&gt;
value&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mask               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0100&lt;/span&gt;
(v&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;~&lt;/span&gt;mask) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (value&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mask) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0111&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So the final value of the calculations in &lt;strong&gt;line 4&lt;/strong&gt; is &lt;code&gt;1100 0111&lt;/code&gt;, bits 2 and 3 have been set to the desired value and the remaining bits are unchanged. Here&amp;rsquo;s a comparison of the old and current values of the register:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;original value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1011&lt;/span&gt;
new value      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0111&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; simply writes the new value, &lt;code&gt;v&lt;/code&gt;, to `paddr using &lt;a href=&#34;#bcm_peri_write&#34;&gt;bcm_peri_write()&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_spi_end&#34;&gt;bcm_spi_end()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_spi_end()&lt;/code&gt; reverses the effects of &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt;. It uses &lt;a href=&#34;#bcm_gpio_fsel&#34;&gt;bcm_gpio_fsel()&lt;/a&gt; to reverse all the SPI0 GPIO pins from SPI mode, the &lt;code&gt;BCM_GPIO_FSEL_ALT0&lt;/code&gt; alternate function, back to input mode, &lt;code&gt;BCM_GPIO_FSEL_INPT&lt;/code&gt;. In the code below, the pin references, e.g., &lt;code&gt;BCM_GPIO_P1_26&lt;/code&gt;, refer to &lt;code&gt;#define&lt;/code&gt;s that cross-reference the Raspberry Pi pin numbers, e.g., &lt;code&gt;26&lt;/code&gt;, to the GPIO pin numbers. For example, &lt;code&gt;BCM_GPIO_P1_26&lt;/code&gt; refers to the Raspberry Pi pin 26 which maps to GPIO pin 7, the CE1 pin.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/1f9ad3f66ca7b4fde22da6b8f7900d9b.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;bcm_close&#34;&gt;bcm_close()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_close&lt;/code&gt; deallocates all resources and resets all GPIO offsets to their original values, &lt;code&gt;MAP_FAILED&lt;/code&gt; in this case. With regard to &lt;code&gt;MAP_FAILED&lt;/code&gt;, this value prevents any more operations on the BCM2835 peripheral registers.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/953c5dcb578b10ca4b51607e4dade0cb.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; releases the memory reserved by the &lt;code&gt;mapmem()&lt;/code&gt; operation in &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 4-14&lt;/strong&gt; reset all the register offsets to their default settings.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;If you got this far, especially if you read the section on interacting directly with the BCM2835, congratulations! This has been a long and detailed article. I do hope you found it worth your investment of time and energy.&lt;/p&gt;
&lt;p&gt;This article has covered quite a lot of ground. First, it walked you through the physical setup you needed to follow this article with a working example.&lt;/p&gt;
&lt;p&gt;Second, it provided a fairly detailed overview of the SPI protocol. This included:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;An overview of SPI and how and why you might use it&lt;/li&gt;
&lt;li&gt;A description of the MAX7219 LED Dot Matrix Display module&lt;/li&gt;
&lt;li&gt;A descriptionof the physical pins in the MAX7219 as well as the corresponding GPIO pins on the BCM2835&lt;/li&gt;
&lt;li&gt;An example SPI timing diagram to illustrate how the signaling works&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Third, it walked you through the main program that demonstrates how to program the MAX7219 to display a series of numbers, characters, and shapes. In and of itself this main program is sufficient to gain an understanding of how to program SPI using the BCM2835 C library.&lt;/p&gt;
&lt;p&gt;Fourth, it provided a detailed, but optional, description of how to directly program the registers on the BCM2835 that are associated with the SPI protocol.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s it, thanks for reading! Comments and questions about this article are welcome.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.6_led_dot_matrix_c.html&#34;&gt;The Sunfounder LED Dot Matrix Module&lt;/a&gt; is the source of the breadboard diagram and the original version of the &lt;a href=&#34;#controlling-the-max7219---main-program&#34;&gt;main()&lt;/a&gt; and supporting functions.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pinout.xyz/&#34;&gt;Raspberry Pi GPIO Pinout diagram&lt;/a&gt; provides the location of physical board pin numbers and their mapping to the corresponding BCM/GPIO pin numbers and the WiringPi pin numbers.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;The gpio repository&lt;/a&gt; contains the code for this and other articles&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;How to setup a new Raspberry Pi from scratch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;How to use a breadboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;GPIO programming on a Raspberry Pi 3B+&lt;/a&gt; is a link to my articles about GPIO programming on the Raspberry Pi&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;The BCM2835 ARM Peripherals guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;The Wikipedia Serial Peripheral Interface&lt;/a&gt; article provides a detailed introduction to the SPI protocol.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf&#34;&gt;The MAX7219 datasheet&lt;/a&gt; describes the low level details of the MAX7219 LED Dot Matrix Display, called the Serially Interfaced, 8-Digit LED Display Drivers. It includes detailed information about the registers, what they do, and how to set them.&lt;/li&gt;
&lt;li&gt;The C &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835&lt;/a&gt; library by Mike McCauley&lt;/li&gt;
&lt;li&gt;The C &lt;a href=&#34;http://wiringpi.com&#34;&gt;WiringPi&lt;/a&gt; library and associated &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;GitHub repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Python &lt;a href=&#34;http://abyz.me.uk/rpi/pigpio/&#34;&gt;pgpio&lt;/a&gt; library&lt;/li&gt;
&lt;li&gt;The Python &lt;a href=&#34;https://pypi.org/project/RPi.GPIO/&#34;&gt;RPi.GPIO&lt;/a&gt; library&lt;/li&gt;
&lt;li&gt;The Go &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://robojax.com/learn/arduino/8x8LED/&#34;&gt;Sprite Generator for LED Matrix 8x8&lt;/a&gt; is an online tool that given an input shape on an LED matrix will output the hex numbers needed to display it.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Raspberry Pi GPIO - Introduction To Programming Broadcom BCM2835 ARM Peripherals</title>
      <link>https://youngkin.github.io/post/gpioprogramming/</link>
      <pubDate>Tue, 05 Apr 2022 13:13:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/gpioprogramming/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This is the sixth article in a series that explores &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;GPIO programming on a Raspberry Pi 3B+&lt;/a&gt;. It is an introduction to controlling GPIO peripheral devices by directly interacting with the appropriate registers on the BCM2835 SoC (system on a chip). It is an introduction in that it only covers one of the capabilities, using the basic GPIO capability as described in &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;Section 6 of the BCM2835 ARM Peripherals guide&lt;/a&gt;. This excludes BCM2835 support for protocols such as SPI, Pulse Width Modulation, and IC2 which overlay specific protocol capability by utilizing the underlying pins mapped to a given protocol (e.g., GPIO pins 8-11 are associated with the SPI protocol and have behaviors that can be enabled that are specific to that protocol). That said, using the basic pin level functionality covers the same concepts needed to utilize advanced protocol capabilites such as SPI. This article, coupled with the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;, should provide enough background to drive devices that are controlled via those capabilities. Of course there are multiple libraries such as the C &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835&lt;/a&gt; and &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; libraries, the Python &lt;a href=&#34;http://abyz.me.uk/rpi/pigpio/&#34;&gt;pgpio&lt;/a&gt; and &lt;a href=&#34;https://pypi.org/project/RPi.GPIO/&#34;&gt;RPi.GPIO&lt;/a&gt; libraries, and the Go &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; library that make this much easier. And while these libraries are usually more appropriate for most projects, it can be helpful to understand how the BCM2835 SoC works and how those libraries interact with the BCM2835. This background is also helpful if you find yourself reading library code and/or would like to contribute to these projects, or even write your own library.&lt;/p&gt;
&lt;p&gt;This article assumes you already have some familiarity with the BCM2835 and GPIO programming on the Raspberry Pi. If you don&amp;rsquo;t you may want to consider trying the projects covered in some of &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;my other GPIO articles&lt;/a&gt;. The simplist article in the series is &lt;a href=&#34;https://youngkin.github.io/post/sunfoundergpionotesled/&#34;&gt;Raspberry Pi GPIO in Go and C - Blinking LED&lt;/a&gt;. It demonstrates the same capability as this article does, blinking an LED, but it also demonstrates the usage of the &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; and the Go &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; libraries. It is a good introduction to using GPIO on the Raspberry Pi, but it only covers basic GPIO concepts and how to wire a breadboard to a Raspberry Pi&amp;rsquo;s GPIO outputs.&lt;/p&gt;
&lt;p&gt;The following topics will be covered:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Prerequisites&lt;/strong&gt; - describes the hardware and libraries you&amp;rsquo;ll need for this article.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;An introduction to BCM2835 GPIO Peripherals&lt;/strong&gt; - provides an overview the BCM2835&amp;rsquo;s architecture and capabililites.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Using the BCM2835 board to control an LED via the GPIO pins&lt;/strong&gt; - provides the details, including code, for controlling an LED using the BCM2835 GPIO registers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Summary&lt;/strong&gt; - summarizes the important concepts covered in this article.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;References&lt;/strong&gt; - provides a list of references I found helpful, some of which were used in the creation of this article.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;stretch&amp;rsquo; version of the Raspbian OS. See &lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;How to setup a new Raspberry Pi from scratch&lt;/a&gt; if you don&amp;rsquo;t already have a Raspberry Pi and need help setting one up.&lt;/p&gt;
&lt;p&gt;Next you&amp;rsquo;ll need is a &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt;, some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;, &lt;a href=&#34;https://www.amazon.com/Gikfun-Resistor-Experiment-Raspberry-Arduino/dp/B01G3FCMVA/ref=sr_1_19?keywords=220+ohm+resistor&amp;amp;qid=1648933499&amp;amp;sr=8-19&#34;&gt;a 220 Ohm resistor, and an LED&lt;/a&gt;. You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the adapter will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. Buying all these things separately will cost more than a kit however. &lt;a href=&#34;https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;amp;pd_rd_i=B06WP7169Y&amp;amp;pd_rd_w=OZVyf&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=0V0IH&amp;amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;Here&amp;rsquo;s a simple kit that has all of the above&lt;/a&gt;. If you expect to follow this series I recommend buying the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt;.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;You&amp;rsquo;ll need some basic C programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll need familiarity with how to use an editor like Vi or nano. You&amp;rsquo;ll also need basic familiarity with the Linux command line.&lt;/p&gt;
&lt;p&gt;Finally, you&amp;rsquo;ll need to clone or fork &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;my GPIO repository&lt;/a&gt; as it contains underlying library code used to access GPIO capabilities on the BCM2835. As mentioned in other sections, this library code is based on the &lt;a href=&#34;http://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835 C library&lt;/a&gt; developed by Mike McCauley.&lt;/p&gt;
&lt;h2 id=&#34;an-introduction-to-the-bcm2835-arm-peripherals&#34;&gt;An introduction to the BCM2835 ARM Peripherals&lt;/h2&gt;
&lt;p&gt;This section provides an overview of the BCM2835 peripherals. It starts with an overview overview of the capabilites of the various types of peripherals. It then moves to an overview of BCM2835 addressing. Understanding addressing is fundamental to understanding the rest of the article. It concludes with a more detailed discussion about how registers are used to access the peripherals and their associated I/O functions.&lt;/p&gt;
&lt;p&gt;This is not an exhaustive description of the BCM2835. The only capability that will be covered in any detail, and is the focus of this article, is interacting with the GPIO I/O functions, namely defining the function of a pin and setting and clearing the value of the pin (e.g., setting it to HIGH and LOW), specifically programming BCM2835 GPIO to blink an LED.&lt;/p&gt;
&lt;p&gt;There are multiple pin numbering schemes. The Raspberry Pi has physical pin numbers, i.e., the numbers printed on the Pi board. BCM2835 has a numbering scheme called GPIO numbering. It is different than, and incompatible with, the Pi&amp;rsquo;s physical numbering scheme. Finally some libraries such as the C WiringPi library have their own numbering schemes which are incompatible with the Pi and BCM2835 schemes. This article uses the BCM2835 numbering scheme exclusively. There is a good &lt;a href=&#34;https://pinout.xyz&#34;&gt;pin out diagram&lt;/a&gt; available that maps between these 3 numbering schemes. Where a pin supports a particular I/O function, as described below, that is also called out on this pin out diagram.&lt;/p&gt;
&lt;p&gt;A quick note on terminology&amp;hellip; The term &amp;ldquo;peripherals&amp;rdquo; is used in the title and in some parts of this article. To me the term peripherals is something of a misnomer. Let me explain. At its most basic the GPIO capability of the BCM2835 is made available through a set of physical pins on the device. Some of these pins provide power and ground needed to drive external devices like LEDs, sensors, and motors. Other pins can be controlled programatically to take input from, or output to, these external devices. At a higher level, subsets of the GPIO pins provide support for complete protocols that implement more sophisticated functions like controlling the speed and direction of a motor and controlling LED displays that display text like those in highway signs. These basic and more sophisticated capabilities are controlled by setting the function of a pin. Input and output are 2 functions that can be set. There are a variety of others that will be covered. Setting the function of a pin describes how the BCM2835 interacts with a device or peripheral. Because of this I prefer to use the term I/O Function. I think that more accurately describes the concept than the term &amp;ldquo;peripherals&amp;rdquo; does. To me &amp;ldquo;peripherals&amp;rdquo; are the external devices. The first use of the term &lt;strong&gt;I/O Functions&lt;/strong&gt; is the title of the  next section.&lt;/p&gt;
&lt;h3 id=&#34;io-functions&#34;&gt;I/O Functions&lt;/h3&gt;
&lt;p&gt;The BCM2835 supports a variety of I/O functions. These are the subject of the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;. This section will only describe a few of these functions in detail. There are other sources like Wikipedia that can provide information about the others.&lt;/p&gt;
&lt;p&gt;The main I/O functions supported by the BCM2835 are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPIO&lt;/li&gt;
&lt;li&gt;SPI&lt;/li&gt;
&lt;li&gt;PWM&lt;/li&gt;
&lt;li&gt;AUX&lt;/li&gt;
&lt;li&gt;BSC&lt;/li&gt;
&lt;li&gt;DMA&lt;/li&gt;
&lt;li&gt;External Mass Media Controller&lt;/li&gt;
&lt;li&gt;Interrupts&lt;/li&gt;
&lt;li&gt;Audio (PCM/I2s Audio)&lt;/li&gt;
&lt;li&gt;System Timer&lt;/li&gt;
&lt;li&gt;UART&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As I have direct experience with the first 3 I/O functions, GPIO, SPI, and PWM, this section will focus on these. This will provide enough context in order to get a basic understanding of the kinds of things the BCM2835 is capable of as well as leveraging the information in the Addressing and Registers sections below in order to learn about and use the remaining I/O functions.&lt;/p&gt;
&lt;h4 id=&#34;gpio-general-purpose-inputoutput&#34;&gt;GPIO (General Purpose Input/Output)&lt;/h4&gt;
&lt;p&gt;GPIO stands for General Purpose Input Output. In the BCM2835 ARM Peripherals guide the term GPIO refers to the most general, or basic, level of control of a physical pin. This is what&amp;rsquo;s used to control the function of a pin, such as setting it as an input or output pin, or more advanced I/O functions such as SPI and PWM. It&amp;rsquo;s also used to set or get the value of a pin. Values are conceptually referred to as HIGH and LOW, but they are represented by voltage, or lack thereof, passing across the pin. There are other types of settings for pins. One of these settings is used to control whether to detect a state change on the rising or falling edge of a pin&amp;rsquo;s voltage change. Another setting controls what are called pull-up/pull-down resistors attached to each pin. These resistors are used to explicitly control the value of a pin, 1 or 0, when a pin&amp;rsquo;s voltage is in an indeterminate state. &lt;a href=&#34;https://www.electronics-tutorials.ws/logic/pull-up-resistor.html&#34;&gt;This tutorial&lt;/a&gt; has a reasonably good explanation for why pull-up and pull-down resistors are needed.&lt;/p&gt;
&lt;p&gt;The code associated with this article causes and LED to blink. Accomplishing this involves the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Set the function of the pin to output, i.e., it&amp;rsquo;s going to be written to in order to send a signal to the LED.&lt;/li&gt;
&lt;li&gt;Write LOW to the pin to cause the LED to turn on.&lt;/li&gt;
&lt;li&gt;Pause&lt;/li&gt;
&lt;li&gt;Write HIGH to the pin to cause the LED to turn off.&lt;/li&gt;
&lt;li&gt;Repeat steps 2 through 4.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Accomplishing this uses the GPIO I/O  functions. More accurately it uses the GPIO registers to set the pin&amp;rsquo;s function (e.g., output) and to control the behavior of the peripheral, an LED in this case.&lt;/p&gt;
&lt;h4 id=&#34;spi-serial-peripheral-interface&#34;&gt;SPI (Serial Peripheral Interface)&lt;/h4&gt;
&lt;p&gt;SPI is used to send data serially to a peripheral that can accept or requires data in parallel. This is helpful because a relatively large set of parallel inputs can be written to using just 3 GPIO pins not including power (VCC) and ground (GND). If SPI wasn&amp;rsquo;t used, one GPIO pin would be required for each parallel input. This could easily be prohibitive since pins are a limited resource. Let&amp;rsquo;s see how this works with an example.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/MAX7219_Transparent.jpg&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: Author&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The diagram above shows the MAX7219 LED Dot Matrix Display. It&amp;rsquo;s commonly used to display display arbitrary shapes such as letters, numbers, and smiley faces. It controls an 8x8 matrix of LEDs. Controlling an LED requires 1 pin excluding power or ground. An 8x8 LED matrix has 64 LEDs. This number is well in excess of the 26 or 40 GPIO pins available on a standard Raspberry Pis. As explained below, utilizing SPI requires considerably fewer GPIO pins.&lt;/p&gt;
&lt;p&gt;The MAX7219 has the following input pins:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DIN - this is the serial data input pin.&lt;/li&gt;
&lt;li&gt;CS - This is commonly called a chip select (CS) or chip enable (CE) pin.&lt;/li&gt;
&lt;li&gt;CLK - This pin connects to a clock pin on the Raspberry Pi that synchronizes data transfers between the Raspberry Pi and the MAX7219.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are 2 more pins that aren&amp;rsquo;t used to control the MAX7219.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VCC - This is the power-in pin. It connects to a power source on the Raspberry Pi, usually a 3.3v source.&lt;/li&gt;
&lt;li&gt;GND - This is the ground pin. It connects to a ground pin of the Raspberry Pi.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A minimum of 3 GPIO pins are required to connect from the Raspberry Pi to the MAX7219, specifically to the DIN, CS, and CLK pins. A Raspberry Pi can control all 64 LEDs in a cost (pin-wise) efficient manner using only these three pins. The usual approach is to use the Raspberry Pi pins that can drive the DIN, CS, and CLK pins. These 3 pins are named:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(SPI)MOSI - This stands for Master Out Slave In. The MOSI pin will be connected to the MAX7219 DIN pin and is used to send a serial data signal to the MAX7219 (or any SPI peripheral).&lt;/li&gt;
&lt;li&gt;(SPI)SCLK - These stand for SPI Clock. This pin will be connected to the MAX7219 CLK pin. It is used as the source of the clock signal used to synchronize the data transfer between the BCM2835 and the MAX7219 (or any SPI peripheral). The data transfer will occur when both the MOSI pin and the SCLK pin are set to HIGH.&lt;/li&gt;
&lt;li&gt;(SPI)CS or (SPI)CE - These stands for Chip Select or Chip Enable. In either case, setting the pin to LOW directs the MAX7219 to accept data as described in the previous bullet.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;I reluctantly use the terms &amp;ldquo;master&amp;rdquo; and &amp;ldquo;slave&amp;rdquo;. However these terms are used in all of the documents I&amp;rsquo;ve read on SPI. I&amp;rsquo;ll continue to use them in order to avoid confusion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The SPI capability on the Raspberry Pi may require as many as 5 GPIO pins. The 2 additional pins are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(SPI)MISO - This stands for Master In Slave Out. This pin allows for the MAX7219 (or any SPI peripheral) to send data back to the BCM2835.&lt;/li&gt;
&lt;li&gt;(SPI)CS or (SPI)CE - This is a second chip select/chip enable pin. Having a second CS/CE pin allows the BCM2835 to control 2 SPI peripherals. As stated above, when the CS/CE pin is set to LOW the SPI peripheral will accept data from the BCM2835. So by setting one of the CS/CE pins to HIGH and the other to LOW we can control which slave can receive and send data. The article &lt;a href=&#34;https://adikedia.com/2016/08/10/using-multiple-spi-slave-devices-with-wiringpi/&#34;&gt;Using Multiple SPI Slave Devices with the Raspberry Pi&lt;/a&gt; provides more information about how the 2 CE/CS pins are used. The following schematic illustrates how this is done:&lt;/li&gt;
&lt;/ol&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/SPIMasterSlave.jpg&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: BCM2835 ARM Peripherals Guide&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The primary SPI interface on the BCM2835, SPI0, is implemented on GPIO pins 7-11. Pins 7 &amp;amp; 8 are the 2 CE/CS pins available on the BCM2835. Pin 9 is MISO, 10 is MOSI, and 11 is the clock (SPICLK/SCLK). The BCM2835 has 2 auxilary SPI interfaces, SPI1 (AKA AUX_SPI0) and SPI2 (AKA AUX_SPI1). From the BCM2835 ARM Peripherals Guide, SPI1 is available on pins 16-21 and SPI2 on pins 35-39. These auxilary interfaces are available via the AUX I/O function.&lt;/p&gt;
&lt;p&gt;The following diagram shows a GPIO extension board frequently used to connect the BCM2835 GPIO pins to a breadboard. The pins are labeled with there GPIO pin numbers or the I/O function (e.g., SPI) they support Note the SPI pins are labeled on the board using the same terms as above:&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/GPIOExtensionBoard.jpg&#34; align=&#34;center&#34; width=&#34;500&#34; height=&#34;250200&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: BCM2835 ARM Peripherals Guide&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;In addition to the MAX7219, SPI can be used to control a variety of peripherals to display images, take input from touchscreens, and interact with various sensors. &lt;a href=&#34;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&#34;&gt;Wikipedia has a good article&lt;/a&gt; describing SPI in more detail.&lt;/p&gt;
&lt;p&gt;My article titled &lt;a href=&#34;http://youngkin.github.io/post/spidotmatrixmodule/&#34;&gt;Raspberry Pi GPIO - Using SPI to display arbitrary patterns on a MAX7219 Dot Matrix Display Module&lt;/a&gt; provides detailed coverage of the SPI I/O function and how to program it. Similar to this article, it also includes detailed coverage of how to directly program the BCM2835 using the associated registers on the BCM2835, but for SPI instead of general GPIO I/O functionality. By reading that article you&amp;rsquo;ll gain a deeper understanding of how to use the BCM2835 registers to program the I/O functionality supported by the BCM2835.&lt;/p&gt;
&lt;h4 id=&#34;pwm-pulse-width-modulation&#34;&gt;PWM (Pulse Width Modulation)&lt;/h4&gt;
&lt;p&gt;PWM is used to convert a digital signal, like that produced by the BCM2835, into a simulated analog signal. It is simulated in the sense that it&amp;rsquo;s not a true analog signal. It&amp;rsquo;s still a digital signal but it cycles so fast that, much like a video, it appears to be an analog signal. Many peripherals like electric motors, dimmable LEDs, and color LEDs require an analog signal. As with SPI there are dedicated pins that can be enabled to utilize the PWM I/O function. These are GPIO pins 12, 13, 18, and 19. With these pins the BCM2835 supports something called hardware PWM. The PWM functionality is embedded into the BCM2835. It implements a hardware based clock loop that controls the frequency of the simulated analog signal. It is possible to use other GPIO pins for PWM, this is called software PWM. However, in software PWM the clock loop is written in the code that runs on the Raspberry Pi CPU. Since that CPU is doing many other things it isn&amp;rsquo;t possible to create a reliable clock signal. This can result in some undesirable side effects such as a flickering LED in place of a dim LED. See my articles &lt;a href=&#34;https://youngkin.github.io/post/sunfoundergpionotesrgbled/&#34;&gt;Raspberry Pi GPIO in Go and C - RGB LED&lt;/a&gt; and &lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies&lt;/a&gt; for more information about PWM as well as examples of PWM in use.&lt;/p&gt;
&lt;h3 id=&#34;addressing&#34;&gt;Addressing&lt;/h3&gt;
&lt;p&gt;All GPIO I/O functions are accessed via registers. These registers are located at various offsets in the on-board memory. Accessing the registers requires a knowledge of how addressing works on the BCM2835 was well as on the Raspberry Pi. Here&amp;rsquo;s a diagram from the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt;, section 1.2.1, showing how memory is mapped from the Pi&amp;rsquo;s physical address to the BCM2835 addresses.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/bcm2835programming/BCM2835Addressing.jpg&#34; align=&#34;center&#34; width=&#34;1000&#34; height=&#34;500&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;BCM2835 Addressing&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The Raspberry Pi maps the BCM2835 memory to the Pi&amp;rsquo;s physical address of &lt;code&gt;0x2000 0000&lt;/code&gt;. This is shown in the middle column labeled &amp;ldquo;ARM Physical Addresses&amp;rdquo;. The gray shaded area labeled I/0 peripherals is the Pi&amp;rsquo;s physical memory location of the BCM2835&amp;rsquo;s peripherals (e.g., GPIO pins). Moving towards the left you&amp;rsquo;ll see a gold box labeled &amp;ldquo;VC/ARM MMU&amp;rdquo;. This is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Memory_management_unit&#34;&gt;Memory Management Unit&lt;/a&gt; that is responsible for mapping the Pi&amp;rsquo;s physical memory to the BCM2835 memory. Following the line from the middle column&amp;rsquo;s &amp;ldquo;I/O Peripherals&amp;rdquo; partition, through the VC/ARM MMU, to the far left column titled &amp;ldquo;VC CPU Bus Addresses&amp;rdquo; leads to the &amp;ldquo;I/O Peripherals&amp;rdquo; partition on the BCM2835&amp;rsquo;s CPU address bus. It&amp;rsquo;s address is &lt;code&gt;0x7E00 0000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The I/O peripheral addresses can be made available to the application through one of 2 ways. The traditional way is via the &lt;code&gt;/dev/mem&lt;/code&gt; device mounted on the file system. Accessing this device requires root privileges. A newer method became available starting with the Raspberry Pi 2. This method accesses the I/O peripheral addresses via &lt;code&gt;/dev/gpio&lt;/code&gt;. An advantage of using this method is that it doesn&amp;rsquo;t require root access. A disadvantage to using this method is that only the GPIO I/O functionality of the BCM2835 can be accessed. This means advanced capabilities like PWM and SPI are not available. Accessing the I/O peripherals using &lt;code&gt;/dev/mem&lt;/code&gt; also requires a little more work, namely mapping the physical memory from &lt;code&gt;/dev/mem&lt;/code&gt; to the application&amp;rsquo;s virtual memory. This will be covered in more detail later.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is third way to interface with GPIO registers. In the case of SPI, there are 2 devices (generally available on many Raspberry Pi models), &lt;code&gt;/dev/spidev0.0&lt;/code&gt; and &lt;code&gt;/dev/spidev0.1&lt;/code&gt; via &lt;code&gt;ioctl()&lt;/code&gt;. This method won&amp;rsquo;t be covered in this article.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;registers&#34;&gt;Registers&lt;/h3&gt;
&lt;p&gt;As mentioned above, specifying the I/O function of a pin or set of pins is accomplished through registers on the BCM2835. Each I/O function has an associated register set located at an offset within the BCM2835&amp;rsquo;s I/O peripheral address space. For example, the GPIO register set starts at the CPU bus address &lt;code&gt;0x7E20 0000&lt;/code&gt;. The SPI register set starts at CPU bus address offset &lt;code&gt;0x7E20 4000&lt;/code&gt;. The PWM register set starts at offset &lt;code&gt;0x7E20 C000&lt;/code&gt;. And so on, each I/O function has it&amp;rsquo;s own set of registers to manage its behavior. That said, they all work on the same principles. Namely, find the offset of the beginning of each I/O function&amp;rsquo;s register set and then set (or get) the appropriate bits at the appropriate offsets to control the behavior. To make this example more explicit, and to highlight additional details, let&amp;rsquo;s do a high level walkthrough of how to control a GPIO pin to blink an LED.&lt;/p&gt;
&lt;p&gt;As mentioned previously the GPIO register starts at bus address &lt;code&gt;0x7e2000 0000&lt;/code&gt;. Section 6.1 of the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;BCM2835 ARM Peripherals guide&lt;/a&gt; starting on page 90 provides the details about the GPIO registers. To blink an LED we&amp;rsquo;ll first need to specify the pin&amp;rsquo;s function, output in this case, and then toggle the value of the LED between HIGH and LOW.&lt;/p&gt;
&lt;h4 id=&#34;specify-a-pins-function&#34;&gt;Specify a pin&amp;rsquo;s function&lt;/h4&gt;
&lt;p&gt;First the I/O function of the pin needs to be set. A pin&amp;rsquo;s functionality is defined via one of 8 alternative functions. Encoding each function requires 3 bits, 000 - 111. These bits are contained within what is called a GPIO Function Select Register. Each register is 32 bits long. Therefore each 32 bit register can control 10 pins with 2 bits left over. In order to control all of the GPIO pins there are 6 function select registers. The BCM2835 has the capability to control up to 54 pins, if supported, via function select registers (on the Raspberry Pi 3B+ only 40 pins are available). Supporting 54 pins, with 10 pins/register, requires 6 registers. The first function select register is located at &lt;code&gt;0x7E20 0000&lt;/code&gt;, zero-offset from the start of the GPIO register set. The 6th function select register starts at offset &lt;code&gt;0x7E20 0014&lt;/code&gt;. The 8 alternative functions are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input - represented by bit pattern &lt;code&gt;000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Output  - represented by bit pattern &lt;code&gt;001&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and Alternate functions 0 through 5 represented by bit patterns &lt;code&gt;010&lt;/code&gt; through &lt;code&gt;111&lt;/code&gt; respectively.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this example let&amp;rsquo;s use pin 17 as an output pin. Inspecting the BCM2835 ARM Peripherals guide we see that pin 17 is in function select register 1, AKA GPFSEL1. GPFSEL1 is at offset &lt;code&gt;0x7E20 0004&lt;/code&gt;. Pin 17&amp;rsquo;s function select offset within the register is at bits 21-23. Recall that the output bit pattern is &lt;code&gt;001&lt;/code&gt; so we&amp;rsquo;ll need to put that bit pattern in bits 21-23. In the section on coding below we&amp;rsquo;ll see how this is actually accomplished.&lt;/p&gt;
&lt;h4 id=&#34;set-the-pin-value&#34;&gt;Set the pin value&lt;/h4&gt;
&lt;p&gt;This article assumes that pin 17 is attached to the ground terminal of the LED (the cathode). This means that we&amp;rsquo;ll have to set the pin to LOW in order for current to flow from the power input to the anode through to the LED ground on pin 17 and light the LED. Setting the pin to HIGH will cause the LED to turn off. Switching between LOW and HIGH will cause the LED to blink, which is what we&amp;rsquo;re looking for.&lt;/p&gt;
&lt;p&gt;GPIO pin values are controlled via the GPIO Pin Output Set register. There are 2 GPIO Pin Output Set registers. Pin 17 is in the first register, GPIO Pin Output Set 0, AKA GPSET0, at GPIO register offset &lt;code&gt;0x7E20 002C&lt;/code&gt;. Pin 17 is at bit offset 17 within GPSET0. Setting bit 17 to 1 sets the register to HIGH. GPIO Pin Output Set registers can only set a pin to HIGH, setting a pin to 0 has no effect. But recall we need to set the pin to LOW. Since setting a pin in GPSET0 won&amp;rsquo;t result in the pin being set to LOW how can we accomplish this? It turns out there is another set of GPIO registers called GPIO Pin Output Clear registers. These are used to set a pin&amp;rsquo;s value to LOW. Pin 17 is in GPIO Pin Output Clear register 0, AKA GPCLR0, starting at offset &lt;code&gt;0x7E20 0028&lt;/code&gt;. It&amp;rsquo;s position within the register is also at bit 17. Setting bit 17 to 1 will set the pin to LOW. So we&amp;rsquo;ll need to left shift a &lt;code&gt;1&lt;/code&gt; into bit 17 in order to turn on the LED. We&amp;rsquo;ll use GPSET0 to turn the LED off. As with specifying a pin&amp;rsquo;s function, how this is accomplished will be covered later in this article. By using the GPCLR0 and GPSET0 registers in turn we can cause the LED to blink.&lt;/p&gt;
&lt;h4 id=&#34;other-gpio-settings&#34;&gt;Other GPIO settings&lt;/h4&gt;
&lt;p&gt;The GPIO register set can be used to control many other functions of a GPIO pin in addition to selecting the function and setting/clearing a pin&amp;rsquo;s value. It can also be used to read the value of a pin. As discussed in the I/O functions section above other things that can be managed include specifying how state changes are to be detected (rising/falling edge detection) and how to set the voltage of a pin when it&amp;rsquo;s in an indeterminate state (pull-up/down resistors). Discussing these other registers is an advanced topic and is beyond the scope of this article.&lt;/p&gt;
&lt;h2 id=&#34;setup-and-code&#34;&gt;Setup and Code&lt;/h2&gt;
&lt;p&gt;This section starts with a program that causes an LED to blink. It&amp;rsquo;s fairly simple and will show the basic steps needed to program the BCM2835. The next part of this section will cover the BCM2835 programming in more detail. But before all that, here&amp;rsquo;s how to wire the breadboard to work with the blinking LED example.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/blinkingLED.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Image credit: Sunfounder&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The breadboard should be wired as illustrated in the above diagram. Note that the (bent) long lead of the LED, the anode, is connected to the 3.3 volt power pin via the resister and the cathode, or ground, is connected to GPIO pin 17. If you&amp;rsquo;re unfamiliar  with breadboards and breadboard diagrams this &lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;breadboard tutorial &lt;/a&gt; should be helpful.&lt;/p&gt;
&lt;p&gt;This section will first describe the main program that blinks an LED. After that it goes into detail about how the code that interacts with the BCM2835 works to control the I/O functions.&lt;/p&gt;
&lt;p&gt;All code in this article can be found in &lt;a href=&#34;https://github.com/youngkin/gpio/tree/main/ledblink&#34;&gt;my gpio repository&lt;/a&gt;, in the ledblink directory.&lt;/p&gt;
&lt;h3 id=&#34;controlling-an-led---main-program&#34;&gt;Controlling an LED - main program&lt;/h3&gt;
&lt;p&gt;The code for the file that contains this code can be found at &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/blinkinglednolib.c&#34;&gt;gpio/ledblink/blinkinglednolib.c&lt;/a&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/b6d09240d211b22dde5cf8efa522598c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This first code snippet shows a couple of important things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Line 1 gives the command to compile and link the program.&lt;/li&gt;
&lt;li&gt;Line 3 provides the include directive needed to import the BCM2835 functions that directly interact with the BCM2835.&lt;/li&gt;
&lt;li&gt;Line 8 defines the BCM GPIO pin that is used to control the LED. It matches the wiring diagram above.&lt;/li&gt;
&lt;/ol&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/f2d0840b28641e0a6412ab87ecc057ab.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This snippet declares an interrupt handler to be used to gracefully exit the program. This ensures that the pin, and the LED, are left in a known state. The definition of the interrupt handler will be shown later.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/06d98adb2c5d4eb6038d65db0bcdda5e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This snippet shows the beginning of the main function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; registers the interrupt handler for the SIGINT signal (i.e., ctl-C).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 5-10&lt;/strong&gt; initialize the BCM2835 GPIO functionality. Briefly, it finds the GPIO peripherals offset and length within main memory and maps it to &lt;code&gt;/dev/mem&lt;/code&gt; so it can be safely accessed within the program. It then sets variables to the offsets of the various capability registers (e.g., GPIO or SPI). If initialization fails the program exits. The &lt;code&gt;bcm_init()&lt;/code&gt; function will be described in more detail below.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 13&lt;/strong&gt; sets &lt;code&gt;LEDPIN&lt;/code&gt; to the GPIO output function. This allows the program to write values, HIGH or LOW, to the pin. The &lt;code&gt;bcm_gpio_fsel()&lt;/code&gt; function will be described in more detail below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/90fe4ed60f0dbe266f4f2d6346db1b2d.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This snippet implements the primary functionality of the program. &lt;strong&gt;Lines 2-10&lt;/strong&gt; blink the LED on and off.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 5 and 8&lt;/strong&gt; set the value of the &lt;code&gt;LEDPIN&lt;/code&gt; by calling &lt;code&gt;bcm_gpio_write()&lt;/code&gt; and setting the value of the pin to either &lt;code&gt;LOW&lt;/code&gt; to turn the LED on, or &lt;code&gt;HIGH&lt;/code&gt; to turn the LED off. &lt;code&gt;LOW&lt;/code&gt; turns the LED off because the lead connecting BCM GPIO pin 17 to the LED is connected to the LED&amp;rsquo;s ground pin. To get current to flow the pin must be set to 0 volts. Likewise, &lt;code&gt;HIGH&lt;/code&gt; turns the LED off. &lt;code&gt;bcm_gpio_write()&lt;/code&gt; will be described in more detail below.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 6 and 9&lt;/strong&gt; cause the program to sleep for 500 milliseconds so the LED can be observed blinking.&lt;/p&gt;
&lt;p&gt;As the comment states, &lt;strong&gt;line 13&lt;/strong&gt; releases the GPIO resources obtained by &lt;code&gt;bcm_init()&lt;/code&gt;. This will also set the GPIO system back to a known state. &lt;code&gt;bcm_close()&lt;/code&gt; will be described in more detail below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/a25e8e6c86f81b442a0aa2307f2508ab.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This snippet defines the interrupt handler function. &lt;strong&gt;Lines 3 and 4&lt;/strong&gt; first turn the LED off, then release the GPIO resources obtained by &lt;code&gt;bcm_init()&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;controlling-an-led---interacting-with-the-bcm2835&#34;&gt;Controlling an LED - interacting with the BCM2835&lt;/h3&gt;
&lt;p&gt;This section describes how the code interacts with and controls the GPIO peripherals, specifically setting the values of the various registers associated with the I/O functionality of the BCM2835. Setting register values is used to control GPIO peripherals and reading register values allow the current state of the associated GPIO peripherals to be accessed.&lt;/p&gt;
&lt;p&gt;The code for the file that contains this code can be found at &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.c&#34;&gt;gpio/ledblink/bcmfuncs.c&lt;/a&gt;. The associated header file can be found at &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h&#34;&gt;gpio/ledblink/bcmfuncs.h&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_init&#34;&gt;bcm_init()&lt;/h4&gt;
&lt;p&gt;The section on &lt;a href=&#34;./#registers&#34;&gt;Registers&lt;/a&gt; mentions that all operations on BCM2835 peripherals are accomplished by manipulating the registers associated for that type of peripheral. The purpose of &lt;code&gt;bcm_init()&lt;/code&gt; is to determine the address offsets for all the types of registers, e.g., GPIO, PWM, SPI, etc. so that the their associated peripherals can be controlled.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/5eb96cc009b06a09d61aca92f031896f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This snippet shows the beginning of the &lt;code&gt;bcm_init()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 10&lt;/strong&gt; opens the &lt;code&gt;BCM_RPI2_DT_FILENAME&lt;/code&gt;. As indicated in the comment, the &lt;code&gt;rb&lt;/code&gt; in the &lt;code&gt;fopen()&lt;/code&gt; call opens a binary file for reading. &lt;code&gt;BCM_RPI2_DT_FILENAME&lt;/code&gt; is defined in the associated &lt;code&gt;bcmfuncs.h&lt;/code&gt; header file. It&amp;rsquo;s value is &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt;. As stated in &lt;a href=&#34;https://www.kernel.org/doc/html/latest/devicetree/usage-model.html&#34;&gt;Linux and the Devicetree&lt;/a&gt;,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An operating system used the Device Tree to discover the topology of the hardware at runtime, and thereby support a majority of available hardware without hard coded information (assuming drivers were available for all devices).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;One of the pieces of information the device tree holds, and is important for our purposes, is the location and length of the I/O Peripherals partition in the BCM2835&amp;rsquo;s physical address space. Here&amp;rsquo;s a hex dump of the contents of &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt; on a Raspberry Pi 3B+:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pi@pi-node1:/ $ hexdump -C /proc/device-tree/soc/ranges
00000000  7e 00 00 00 3f 00 00 00  01 00 00 00 40 00 00 00  |~...?.......@...|
00000010  40 00 00 00 00 00 10 00                           |@.......|
00000018
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We&amp;rsquo;ll refer back to this in this next code snippet. Per &lt;a href=&#34;https://www.devicetree.org/specifications/&#34;&gt;devicetree.org&lt;/a&gt;, in &lt;a href=&#34;https://github.com/devicetree-org/devicetree-specification/releases/download/v0.4-rc1/devicetree-specification-v0.4-rc1.pdf&#34;&gt;v0.4-rc1 of the Devicetree Specification&lt;/a&gt;, the &lt;code&gt;soc/ranges&lt;/code&gt; property is defined as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The ranges property provides a means of defining a mapping or translation between the address space of the bus (the child address space) and the address space of the bus node’s parent (the parent address space).
The format of the value of the ranges property is an arbitrary number of triplets of (child-bus-address, parent-bus-address, length)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the case of the I/O Peripherals address block, as described in the &lt;a href=&#34;./#addressing&#34;&gt;Addressing section&lt;/a&gt; above, the &lt;em&gt;&amp;ldquo;child-bus-address&amp;rdquo;&lt;/em&gt; refers to the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;VC CPU Bus Addresses&amp;rdquo;&lt;/em&gt; memory space. The &lt;em&gt;&amp;ldquo;parent-bus-address&amp;rdquo;&lt;/em&gt; refers to the the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;ARM Physical Addresses&amp;rdquo;&lt;/em&gt; block. And the &lt;em&gt;&amp;ldquo;length&amp;rdquo;&lt;/em&gt; refers to the actual length of the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block. The Raspberry Pi 3B+ has a 32 bit address space so each of the values in the triple are 32 bits or 4 bytes.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/40c162eaeef54c259d1345f18d9b85e1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet finds the &lt;em&gt;parent-bus-address&lt;/em&gt; and &lt;em&gt;length&lt;/em&gt; of the I/O peripherals block using the data from &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt;. Recall that the parent bus address is the second entry in the triplet that also defines the child bus address and length. &lt;strong&gt;Lines 1 thru 4&lt;/strong&gt; shift the contents of the &lt;em&gt;parent-bus-address&lt;/em&gt;, bytes at &lt;code&gt;buf&lt;/code&gt; offsets 4 thru 7, into &lt;code&gt;base_address&lt;/code&gt;. &lt;code&gt;3F&lt;/code&gt; is shifted into the high order byte of &lt;code&gt;base_address&lt;/code&gt;. The remaining &lt;code&gt;buf&lt;/code&gt; cells are likewise shifted into &lt;code&gt;base_address&lt;/code&gt; from left (most significant) to right (least significant byte). After shifting is complete &lt;code&gt;base_address&lt;/code&gt; will be set to &lt;code&gt;0x3F000000&lt;/code&gt;. Looking back at the diagram in the &lt;a href=&#34;./#addressing&#34;&gt;Addressing section&lt;/a&gt; above you&amp;rsquo;ll notice it &lt;strong&gt;DOESN&amp;rsquo;T MATCH&lt;/strong&gt; the base address of &lt;code&gt;0x20000000&lt;/code&gt; in the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block in &lt;em&gt;ARM Physical Addresses&lt;/em&gt;. This is because the diagram in the Addressing section is for the Raspberry Pi 1. This offset is different in the Raspberry Pi models 2 &amp;amp; 3. And it&amp;rsquo;s different yet again in the Raspberry Pi 4 model.&lt;/p&gt;
&lt;p&gt;Moving on, in a similar manner to &lt;code&gt;base_address&lt;/code&gt;, &lt;strong&gt;lines 6 thru 9&lt;/strong&gt; get the &lt;em&gt;length&lt;/em&gt; by shifting from &lt;code&gt;buf&lt;/code&gt; offsets 8 thru 11 into &lt;code&gt;peri-size&lt;/code&gt;. For the Raspberry Pi 3B+, &lt;code&gt;0x01000000&lt;/code&gt; is the expected length of the address block.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/3f8ae5656e480195f3d7293061711016.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet completes obtaining the addressing information from &lt;code&gt;/proc/device-tree/soc/ranges&lt;/code&gt;. Specifically it validates that the &lt;em&gt;&amp;ldquo;child-bus-address&amp;rdquo;&lt;/em&gt; and &lt;em&gt;&amp;ldquo;parent-bus-address&amp;rdquo;&lt;/em&gt; have the expected values. Recall that the &lt;em&gt;&amp;ldquo;child-bus-address&amp;rdquo;&lt;/em&gt; is the first value in the addresses/length triplet, &lt;code&gt;buf&lt;/code&gt; offsets 0 thru 3. Lines 1 thru 6 do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Lines 1 thru 4&lt;/strong&gt; verify that the first 4 bytes of &lt;code&gt;buf&lt;/code&gt;, the &lt;em&gt;child-bus-address&lt;/em&gt;, is &lt;code&gt;0x7E000000&lt;/code&gt; as defined by the &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;VC CPU Bus Addresses&amp;rdquo;&lt;/em&gt; memory space.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Line 5&lt;/strong&gt; verifies that the &lt;em&gt;parent-bus-address&lt;/em&gt;, &lt;code&gt;base_address&lt;/code&gt;, matches one of the expected base addresses for Raspberry Pi models 1 thru 4.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Lines 7 and 8&lt;/strong&gt; then set the base address and length of the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block to the variables that will be used in the rest of the program. The important thing about this line is that it casts the source variables to the types expected by the target variables.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/26f58efe4fdfed3eedf800ae8e167ef4.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next snippet maps the BCM2835&amp;rsquo;s &lt;em&gt;&amp;ldquo;I/O Peripherals&amp;rdquo;&lt;/em&gt; address block in the &lt;em&gt;&amp;ldquo;ARM Physical Addresses&amp;rdquo;&lt;/em&gt; memory space from &lt;code&gt;/dev/mem&lt;/code&gt; so that it can be safely used in the program.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 1&lt;/strong&gt; first checks to see if the user running the program is running as &lt;em&gt;root&lt;/em&gt; (either &lt;em&gt;root&lt;/em&gt; user or &lt;em&gt;sudo&lt;/em&gt;). If not, the &lt;code&gt;/dev/mem&lt;/code&gt; device can&amp;rsquo;t be used. &lt;code&gt;/dev/mem&lt;/code&gt; provides unrestricted access to the CPU&amp;rsquo;s memory. As this is obviously a dangerous thing to do its use is restricted to &lt;em&gt;root&lt;/em&gt;. As you may recall from the &lt;a href=&#34;./#addressing&#34;&gt;Addressing section&lt;/a&gt;, there is an alternative to &lt;code&gt;/dev/mem&lt;/code&gt;, &lt;code&gt;/dev/gpio&lt;/code&gt;. This will be shown later in this section.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; opens &lt;code&gt;/dev/mem&lt;/code&gt; in preparation to the mapping operation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 13&lt;/strong&gt; assigns the &lt;code&gt;bcm_peripherals&lt;/code&gt; variable to the offset and length, &lt;code&gt;bcm_peripherals_base&lt;/code&gt; and &lt;code&gt;bcm-peripherals_size&lt;/code&gt;, of the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block. This mapping effectively restricts the program&amp;rsquo;s access to the &lt;em&gt;I/O Peripherals&lt;/em&gt; address block of physical memory.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/583d622c0db398a6316f997b66cc219c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet calculates the offsets for the various types of registers (e.g., GPIO, PWM, SPI, etc). Each offset is relative to the value of &lt;code&gt;bcm_peripherals&lt;/code&gt; which was the result of a &lt;code&gt;mapmem()&lt;/code&gt; operation in the previous snippet. So to get the address of a register set like the GPIO register set we would add &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt; to the &lt;code&gt;bcm_peripherals&lt;/code&gt; base address. But you may have noticed the code divides these offsets by 4 prior to adding them to &lt;code&gt;bcm_peripherals&lt;/code&gt;. These offsets, e.g., &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt;, which are specified as integers, point to specific byte addresses, i.e., at 8 bit boundaries. &lt;code&gt;bcm_peripherals&lt;/code&gt; is specified as a &lt;code&gt;uint32_t*&lt;/code&gt;, a pointer. You can&amp;rsquo;t just naively add an integer to a pointer. You may recall that pointer arithmetic operates on a pointer variable based on the size of the type of the associated variable. For &lt;code&gt;unint32_t&lt;/code&gt;&#39;s their size is 32 bits or 4 bytes. Adding 1 to a &lt;code&gt;uint32_t&lt;/code&gt; pointer will result in that pointer pointing to the next &lt;code&gt;uint32_t&lt;/code&gt;, which starts 4 bytes from the current position. Naively adding offsets like &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt; to &lt;code&gt;bcm_peripherals&lt;/code&gt; will result in &lt;code&gt;bcm_peripherals&lt;/code&gt; pointing to a position in memory that is 4 &lt;code&gt;uint32_t&lt;/code&gt;s past the current position, not 1 &lt;code&gt;uint32_t&lt;/code&gt; past the current position which is what we want. Which is why each register type offset like &lt;code&gt;BCM_GPIO_BASE&lt;/code&gt; is divided by 4 prior to adding it to &lt;code&gt;bcm_peripherals&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re new to C you may not be aware that pointer arithmetic is inherently dangerous. It can be hard to know exactly what a pointer will reference as a result of pointer arithmetic. The pointer could be an unexpected type or have an unexpected value. This can lead to unexpected behavior which can be very difficult to debug. In some cases, for example performing division, pointing to an unexpected place that contains the value zero will lead to the program abruptly ending (with a segmentation fault). This is good, this way you know something is wrong and you even know where it went wrong. A pointer may even point outside the program&amp;rsquo;s address space the program which may lead to system crashes. In our case however the register locations and associated types are very well known and using pointers is relatively safe. That is, as long as we perform pointer arithmetic correctly&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;bcm_fsel&#34;&gt;bcm_fsel()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_fsel&lt;/code&gt; is responsible for setting the I/O function associated for a given pin. There are a total of 8 functions available. One defines that the associated pin is to be set as an input pin meaning that it will be read from. Another function defines the associated pin as an output pin meaning the pin will be written to. The remaining 6 are referred to as &amp;ldquo;alternate functions&amp;rdquo; and are given names like &amp;ldquo;alternate function 0&amp;rdquo;. The I/O function that is assigned for the various alternate functions is different for the various GPIO pins. For example, setting BCM GPIO pin 17 to alternate function 4 defines its I/O function to be SPI. It actually defines the pin to be a specific subset of SPI functionality called chip enable or chip select, but that is a topic for a later article. Recall that in &lt;code&gt;main()&lt;/code&gt; above, the function is being set to &lt;code&gt;BCM_GPIO_FSEL_OUTP&lt;/code&gt; which defines &lt;code&gt;pin&lt;/code&gt; to be an output pin.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/dc45d2130865d79d989828fea35746d7.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;There&amp;rsquo;s quite a bit going on in this function even though it is quite short.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 1&lt;/strong&gt; defines the function as taking two parameters, &lt;code&gt;pin&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt;. It is fairly obvious that &lt;code&gt;pin&lt;/code&gt; the pin whose function is to be assigned. &lt;code&gt;mode&lt;/code&gt; is the I/O function to associate with &lt;code&gt;pin&lt;/code&gt;. &lt;code&gt;mode&lt;/code&gt; is actually a bit pattern to be assigned to a particular register offset. The bit pattern assignments are defined in the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;The BCM2835 I/O Peripherals datasheet&lt;/a&gt; in section 6, &lt;strong&gt;GPIO&lt;/strong&gt;. The patterns are defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000 = GPIO Pin X is an input
001 = GPIO Pin X is an output
100 = GPIO Pin X takes alternate function 0
101 = GPIO Pin X takes alternate function 1
110 = GPIO Pin X takes alternate function 2
111 = GPIO Pin X takes alternate function 3
011 = GPIO Pin X takes alternate function 4
010 = GPIO Pin X takes alternate function 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is some additional background needed to understand the rest of the function. First, &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;The BCM2835 I/O Peripherals datasheet&lt;/a&gt;, section 6, shows that a total of 54 GPIO pins are addressable via the function select registers (GPFSEL0-GPFSEL5). Each function select register is 32 bits long. Since each of the function select patterns above is 3 bits long each function select register can specify the I/O function for 10 pins with 2 bits left over. Ten pins per register and a total of 54 pins explains why there are 6 function select registers numbered 0 thru 5. The math that follows is derived from this information.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; defines the register offset, &lt;code&gt;paddr&lt;/code&gt;, of the bits that will be set according to &lt;code&gt;mode&lt;/code&gt;. &lt;code&gt;BCM_GPFSEL0&lt;/code&gt; is the base offset, in bytes, of the function select registers. Here&amp;rsquo;s an explanation of the arithmetic performed in this line.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Notice that pointer arithmetic is being performed. Recall that the result of pointer arithmetic is based on the type of the target variable (see the &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; section above). Since &lt;code&gt;uint32_t&lt;/code&gt;&#39;s are 4 bytes long &lt;code&gt;BCM_GPFSEL0&lt;/code&gt; needs to be divided  by 4 for the calculation to come out correctly. Hence &lt;code&gt;... paddr = bcm_gpio + BCM_GPFSEL0/4 ...&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Also recall that each register holds the function select information for 10 pins. For a given pin we need to determine which function select register, GPFSEL0 thru GPFSEL5, specifies the I/O function for a given pin. In C, the result of integer division that results in a fraction will be rounded down. So if we divide the pin number by 10, &lt;code&gt;(pin/10&lt;/code&gt;), we&amp;rsquo;ll get the offset to the correct function select register. So pin 9 will result in &lt;code&gt;9/10&lt;/code&gt; which equals 0, meaning pin 9&amp;rsquo;s function select location is in GPFSEL0. Likewise, pin 17&amp;rsquo;s, &lt;code&gt;17/10 = 1&lt;/code&gt;, function select register is GPFSEL1. And so on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Taken together, the equation &lt;code&gt;paddr = bcm_gpio + BCM_GPFSEL0/4 + (pin/10)&lt;/code&gt; results in the function select register offset appropriate for a given &lt;code&gt;pin&lt;/code&gt;. For pin 17 this will result in &lt;code&gt;paddr&lt;/code&gt; logically pointing to GPFSEL1 at address &lt;code&gt;0x7E20 0004&lt;/code&gt;, &lt;code&gt;7E&lt;/code&gt; being the bus address, &lt;code&gt;20004&lt;/code&gt; being the offset of the GPIO registers plus the offset of GPFSEL1, &lt;code&gt;4&lt;/code&gt;, from the beginning of the GPIO register set. I say logically because &lt;code&gt;bcm_gpio&lt;/code&gt; is an offset from an address returned as the result of a &lt;code&gt;mmap()&lt;/code&gt; operation. &lt;code&gt;mmap()&lt;/code&gt; returns a pointer into the process&amp;rsquo;s virtual memory whereas &lt;code&gt;0x7E20 0004&lt;/code&gt; is an address in the BCM2835&amp;rsquo;s &lt;em&gt;VC CPU Bus Addresses&lt;/em&gt; space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; calculates the location within the function select register for given pin&amp;rsquo;s function select value. Since we&amp;rsquo;ll use bit shifting to set the pin&amp;rsquo;s function select value this location becomes the number of bits to &lt;strong&gt;SHIFT&lt;/strong&gt; the pin&amp;rsquo;s function select value as provided in the &lt;code&gt;mode&lt;/code&gt; parameter. Building the calculation up we first need to find the pin&amp;rsquo;s logical location, that is, which 3 bit cell within the function select register (recall that each function select value is 3 bits long). The calculation for this is given by &lt;code&gt;shift = (pin % 10) ...&lt;/code&gt;. For pin 17 &lt;code&gt;(pin % 17) = 7&lt;/code&gt;. So pin 17&amp;rsquo;s 3 bit cell is located at the 7th 3-bit offset. Next we have to find the actual bit offset within the register. Since each function select value is 3 bits long each pin&amp;rsquo;s boundary is a multiple of 3, hence the complete calculation of &lt;code&gt;shift = (pin % 10) * 3&lt;/code&gt;. For pin 17 this results in &lt;code&gt;(17%10)*3&lt;/code&gt; which equals &lt;code&gt;7*3&lt;/code&gt; which results in an absolute bit offset of 21. Consulting &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 I/O Peripherals datasheet, section 6&lt;/a&gt;, on page 92,  we can confirm that pin 17&amp;rsquo;s offset within the GPFSEL0 register is in bit positions 21 thru 23.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s look at &lt;strong&gt;line 5&lt;/strong&gt;. When setting a subset of bits to a given value we want to preserve the values of the surrounding bits. A mask is used to accomplish this. The mask contains a bit(s) that is in the position of the bit in the target value that we want to change. For example, in the bit pattern &lt;code&gt;0101 1111&lt;/code&gt;, if we want to set bit 6&amp;rsquo;s value from 1 to 0 we only need to define a bit sequence with 1 bit set. To create the most general solution we would just set the least significant bit(s). Since we only need a single bit set we would define the mask as hex number &lt;code&gt;0x1&lt;/code&gt;, which specifies the bit pattern &lt;code&gt;0000 0001&lt;/code&gt;. Next we need to shift this bit pattern as required so that the &lt;code&gt;1&lt;/code&gt; bit is moved to the correct position. In our example, since we want to change bit 6, we would left shift the mask pattern 6 bits to the left, e.g., &lt;code&gt;newMask = 0000 0001 &amp;lt;&amp;lt; 6&lt;/code&gt;. This results in &lt;code&gt;newMask&lt;/code&gt; equaling &lt;code&gt;0100 00000&lt;/code&gt;, which is puts the &lt;code&gt;1&lt;/code&gt; bit in position 6 as we desire. It&amp;rsquo;s possible that we could have defined the mask as &lt;code&gt;0100 0000&lt;/code&gt; outright, but this would not result in a general solution that would work for any mask needed to set a bit(s) in an arbitrary bit position, such as bits 21-23.&lt;/p&gt;
&lt;p&gt;As given in bcmfuncs.h the value of &lt;code&gt;BCM_GPIO_FSEL_MASK&lt;/code&gt; is 0x7 or &lt;code&gt;0000 0111&lt;/code&gt;, this is because each GPIO function select pattern is 3 bits long. So this is a useful bit pattern for masking 3 bit sequences. If we shift this pattern by the &lt;strong&gt;SHIFT&lt;/strong&gt; of 21 as calculated in line 4 above we&amp;rsquo;ll get a 32 bit pattern that looks like this, &lt;code&gt;0000 0000 1110 0000 0000 0000 0000 0000&lt;/code&gt;. The mask is now in bit locations 21-23, which is the location of pin 17&amp;rsquo;s function select pattern in the GPFSEL1 function select register.&lt;/p&gt;
&lt;p&gt;In summary, &lt;strong&gt;line 5&lt;/strong&gt; creates the mask needed to set the 3 bit function select pattern as specified in the &lt;code&gt;mode&lt;/code&gt; parameter on the provided &lt;code&gt;pin&lt;/code&gt; parameter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 6&lt;/strong&gt; creates the new 3 bit value that will be placed into the GPFSEL1 register. Recall that GPFSEL1 is a 32 bit register. To use a 3 bit value such as &lt;code&gt;mode&lt;/code&gt; to set a 3 bit sequence at an arbitrary position, e.g., bits 21-23, we create a value mask that sets the bits in the desired position to the desired value. As with the mask above, the most general solution specifies that those bits be set starting in the least significant position. Let&amp;rsquo;s say in our example we want pin 17 to be set to alternate function 1. Looking at the bit patterns above we can see that the 3 bit value for alternate function 1 is &lt;code&gt;101&lt;/code&gt;. The &lt;code&gt;mode&lt;/code&gt; parameter will contain this value. To set pin 17 to alternate function 1 we need to shift &lt;code&gt;mode&lt;/code&gt;&#39;s bit pattern of &lt;code&gt;0000 0101&lt;/code&gt; 21 bits to the left. As with line 5, line 6 does this in a general way, &lt;code&gt;value = mode &amp;lt;&amp;lt; shift&lt;/code&gt;. Given our value of &lt;code&gt;mode&lt;/code&gt; and the calculated value of &lt;code&gt;shift&lt;/code&gt; we get the 32 bit &lt;code&gt;value&lt;/code&gt; of &lt;code&gt;0000 0000 1010 0000 0000 0000 0000 0000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So we now have the 4 variables needed to calculate the new value of the GPFSEL1 register, &lt;code&gt;paddr&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, &lt;code&gt;mask&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 7&lt;/strong&gt; calls the function &lt;code&gt;bcm_peri_set_bits()&lt;/code&gt; to complete this operation. This operation is done in a separate function since there are other register values that require setting as we will see later.&lt;/p&gt;
&lt;h4 id=&#34;bcm_peri_set_bits&#34;&gt;bcm_peri_set_bits()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_peri_set_bits()&lt;/code&gt; is the function that sets a 32 bit sequence, &lt;code&gt;v&lt;/code&gt;, to a new value, &lt;code&gt;value&lt;/code&gt;, at position &lt;code&gt;paddr&lt;/code&gt;, using a &lt;code&gt;mask&lt;/code&gt; as discussed above. As with &lt;code&gt;bcm_fsel()&lt;/code&gt;, this function does quite a bit in just a few lines of code.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/3a034112183f8892c5b256eb9095c535.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; uses &lt;code&gt;bcm_peri_read()&lt;/code&gt; to read the 32 bit value &lt;code&gt;v&lt;/code&gt; located at &lt;code&gt;paddr&lt;/code&gt;. More on this later.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; sets the &lt;code&gt;v&lt;/code&gt; to its new value. Recall that when a mask is used a subset of bits can be set while leaving the remaining bits unchanged. Line 4 does this in 3 steps. First it does a bitwise-AND operation, &lt;code&gt;&amp;amp;&lt;/code&gt;, between the current value &lt;code&gt;v&lt;/code&gt; with the complement of mask. Taking the example in the previous section for &lt;code&gt;BCM_GPIO_FSEL_MASK&lt;/code&gt;, it&amp;rsquo;s bit value, for brevity just bit positions 16 and 23, is reversed from &lt;code&gt;... 1110 0000 ...&lt;/code&gt; to &lt;code&gt;... 0001 1111 ...&lt;/code&gt;. When the bitwise-AND occurs between the the complemented &lt;code&gt;mask&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; as in &lt;code&gt;(v &amp;amp; ~mask)&lt;/code&gt;, only the bits 21-23 of the original value &lt;code&gt;v&lt;/code&gt; are modified and bits 21-23 are reset to &lt;code&gt;0&lt;/code&gt;s. The remaining bits are unchanged. If bits 16-23 of &lt;code&gt;v&lt;/code&gt; were originally set to &lt;code&gt;... 0100 1010 ...&lt;/code&gt;, the new value of bits 16-23 will now look like &lt;code&gt;... 0000 1010 ...&lt;/code&gt;. In our example for pin 17 its function select bits have been reset to zeros. Note the bits in positions 16 thru 20 are unchanged.&lt;/p&gt;
&lt;p&gt;The next operation, &lt;code&gt;(value &amp;amp; mask)&lt;/code&gt; only retains the bits values at positions 21-23 of the new value, &lt;code&gt;value&lt;/code&gt;, setting the remaining bits to &lt;code&gt;0&lt;/code&gt;. Bits 16-23 of &lt;code&gt;value&lt;/code&gt; are &lt;code&gt;... 1010 0000 ...&lt;/code&gt; which specifies pin 17 is is to be set to alternate function 1. The result of the operation &lt;code&gt;... 1010 0000 ... &amp;amp; ... 1110 0000 ...&lt;/code&gt; is &lt;code&gt;... 1010 0000 ...&lt;/code&gt;, which is expected. The operation is specified as &lt;code&gt;(value &amp;amp; mask)&lt;/code&gt; because we can&amp;rsquo;t say ahead of time that only bits 21-23 are to be reset to &lt;code&gt;value&lt;/code&gt;. Both &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; could have bits set at other positions.&lt;/p&gt;
&lt;p&gt;Putting this all together, the third and final step, &lt;code&gt;(v &amp;amp; ~mask) | (value &amp;amp; mask)&lt;/code&gt; will OR the 2 results, &lt;code&gt;... 0000 1010 ... | ... 1010 0000 ...&lt;/code&gt; which results in &lt;code&gt;v&lt;/code&gt; being reset to &lt;code&gt;... 1010 1010 ...&lt;/code&gt;. Remember that only bits 21-23 were changed. This is shown here by bits 16-20 retaining their previous values. Likewise, the other bits ov &lt;code&gt;v&lt;/code&gt; will remain unchanged.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; the sets the 32 bits at &lt;code&gt;paddr&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt; via &lt;code&gt;bcm_peri_write()&lt;/code&gt;. More on this later as well.&lt;/p&gt;
&lt;h4 id=&#34;bcm_peri_read&#34;&gt;bcm_peri_read()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_peri_read()&lt;/code&gt; will read the 32 bits starting at &lt;code&gt;paddr&lt;/code&gt; and return them to the caller as a 32 bit value. Unlike &lt;code&gt;bcm_fsel()&lt;/code&gt; and &lt;code&gt;bcm_peri_set_bits()&lt;/code&gt; this function is quite simple.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/5ee1dbb21e3e4223492dc96adb61a5f8.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Lines 4 &amp;amp; 6&lt;/strong&gt; synchronize access to memory so that the read can&amp;rsquo;t be interrupted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; simply sets the return value, &lt;code&gt;ret&lt;/code&gt;, to the contents located at &lt;code&gt;paddr&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_peri_write&#34;&gt;bcm_peri_write()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_peri_write()&lt;/code&gt; will write the 32 bits starting at &lt;code&gt;paddr&lt;/code&gt; to the value contained in &lt;code&gt;value&lt;/code&gt;. Like &lt;code&gt;bcm_peri_read()&lt;/code&gt; this function is quite simple.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/147e413e5293ddf57965d107995ab6dc.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Lines 3 and 5&lt;/strong&gt; synchronize access (lock) to the 32 bits starting at &lt;code&gt;paddr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; sets the 32 bits located at &lt;code&gt;paddr&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_gpio_write&#34;&gt;bcm_gpio_write()&lt;/h4&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/b40fcbd81d14eee0a73ed167cb464282.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;bcm_gpio_write()&lt;/code&gt; writes the 32 bit &lt;code&gt;value&lt;/code&gt; to the specified &lt;code&gt;pin&lt;/code&gt;. It uses 2 helper functions, &lt;code&gt;bcm_gpio_set()&lt;/code&gt; and &lt;code&gt;bcm_gpio_clr()&lt;/code&gt;. The parameter &lt;code&gt;on&lt;/code&gt; is used to specify if the &lt;code&gt;value&lt;/code&gt; for &lt;code&gt;pin&lt;/code&gt; should be set or cleared. There are a set of 4 GPIO registers, GPSET0 and GPSET1, and GPCLR0 and GPCLR1, which specify if the value of a pin is HIGH or LOW. HIGH corresponds to GPSETn. LOW corresponds to GPCLRn. When the value of &lt;code&gt;on&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; the GPSETn register associated with the value of &lt;code&gt;pin&lt;/code&gt; is set to 1. If &lt;code&gt;on&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; then the GPCLRn register associated with the value of &lt;code&gt;pin&lt;/code&gt; is set to 1. GPSETn&amp;rsquo;s values are only used when a pin&amp;rsquo;s I/O function is set to OUTPUT. GPCLRn&amp;rsquo;s values are likewise only used when a pin&amp;rsquo;s I/O function is set to OUTPUT. Values of &lt;code&gt;0&lt;/code&gt; in these registers are ignored. Recall that the BCM2835 allows GPIO functions to be specified for 54 pins (vs. the expected 40). Since each pin requires 1 bit to specify whether it&amp;rsquo;s to be set or cleared a total of 54 bits is required. This explains why two 32 bit registers are needed for set and clear.&lt;/p&gt;
&lt;p&gt;The use of these registers is further described in section 6, page 95, of &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;the BCM2835 I/O Peripherals datasheet&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;bcm_gpio_set-and-bcm_gpio_clr&#34;&gt;bcm_gpio_set() and bcm_gpio_clr()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_gpio_set()&lt;/code&gt; and &lt;code&gt;bcm_gpio_clr()&lt;/code&gt; are twins in terms of their functionality. They only differ in which registers they operate on. &lt;code&gt;*set()&lt;/code&gt; operates on the GPSETn registers and &lt;code&gt;*clr()&lt;/code&gt; operates on the GPCLRn registers. They are responsible for setting the appropriate bit offset in the appropriate register for the provided &lt;code&gt;pin&lt;/code&gt; argument. This section will only describe &lt;code&gt;bcm_gpio_set()&lt;/code&gt;. With the exception of the register set operated on their implementations are identical. In fact, with the addition of another parameter to specify the starting offset they could be collapsed into a single function.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/95158df431e7c3b655e013dbc8160fff.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;In &lt;code&gt;bcm_gpio_set()&lt;/code&gt; &lt;strong&gt;line 3&lt;/strong&gt; calculates the address, &lt;code&gt;paddr&lt;/code&gt;, of the target register. &lt;code&gt;bcm_gpio&lt;/code&gt; is the starting offset of the GPIO registers. &lt;code&gt;BCM_GPSET0&lt;/code&gt; is the starting offset of the set and clear registers. Recall from the discussion in the &lt;a href=&#34;#bcm_init&#34;&gt;bcm_init()&lt;/a&gt; section above that pointer arithmetic is used to determine the memory offset to use for a given operation. This is why &lt;code&gt;BCM_GPSET0&lt;/code&gt; is divided by 4 in this operation. &lt;code&gt;pin/32&lt;/code&gt; is used to calculate which of the &lt;code&gt;GP*n&lt;/code&gt; registers is to be used for the given &lt;code&gt;pin&lt;/code&gt;. Recall that integer division always rounds down. So the result of &lt;code&gt;pin 17/32&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; which specifies that the first &lt;code&gt;GP*n&lt;/code&gt; register will be used. This is consistent with the BCM2835 ARM Peripherals guide. And &lt;code&gt;0&lt;/code&gt; is correct in the calculation of the &lt;code&gt;paddr&lt;/code&gt; because of the use of integer arithmetic.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 4&lt;/strong&gt; calculates how large of a &lt;code&gt;shift&lt;/code&gt; is needed to set the proper bit associated with &lt;code&gt;pin&lt;/code&gt; in the &lt;code&gt;GP*n&lt;/code&gt; register. Taking our example of pin 17, &lt;code&gt;17%32&lt;/code&gt; is 17, which corresponds to bit 17 in GPSET0. Again, per the BCM2835 ARM Peripherals guide, this is the correct offset within the correct register.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Line 5&lt;/strong&gt; then uses &lt;code&gt;bcm_peri_write()&lt;/code&gt; to shift &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt; bits to the left, in order to write to the correct offset in the correct register. From the calculation on line 4, &lt;code&gt;1&lt;/code&gt; is shifted 17 bits to the left.&lt;/p&gt;
&lt;h4 id=&#34;bcm_close&#34;&gt;bcm_close()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;bcm_close&lt;/code&gt; deallocates all resources and resets all GPIO offsets to their original values, &lt;code&gt;MAP_FAILED&lt;/code&gt; in this case. With regard to &lt;code&gt;MAP_FAILED&lt;/code&gt;, this value prevents any more operations on the BCM2835 peripheral registers.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/953c5dcb578b10ca4b51607e4dade0cb.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Line 3&lt;/strong&gt; releases the memory reserved by the &lt;code&gt;mapmem()&lt;/code&gt; operation in &lt;code&gt;bcm_init()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lines 4-14&lt;/strong&gt; reset all the register offsets to their default settings.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;This article has provided a detailed look at how to interact directly with the BCM2835&amp;rsquo;s peripherals registers, without using a 3rd party library, to make an LED blink. It first provided an overview of the BCM2835&amp;rsquo;s ARM peripherals main concepts including the types of I/O functions that operate on external devices/peripherals, how the BCM2835 addressing works as a prerequiste for describing how to interact with the BCM2835 registers to control external devices (like an LED). It then described the lab setup needed to control an LED. Next it presented the code, along with explanations of what the code is doing, used by the main program. It finished up presenting the code, with explanations, that interacts directly with the BCM2835&amp;rsquo;s registers that are associated with various types of peripherals.&lt;/p&gt;
&lt;p&gt;At this point you should have a good understanding of how to directly program the BCM2835 to control a variety of peripheral types using the various I/O functions supported by the BCM2835. While the low-level details for a specific I/O function, e.g., SPI, may differ, the mechanics for programming the BCM2835 are the same.&lt;/p&gt;
&lt;p&gt;Keep an eye out for my upcoming article titled &amp;ldquo;Raspberry Pi GPIO - Using SPI to display alphanumeric characters on a MAX7219 Dot Matrix Display Module&amp;rdquo; which, among other things, will demonstrate how to control a dot matrix LED display using only low-level access to the BCM2835 registers. It makes a nice companion to this article as it will introduce a new set of peripheral registers used to program the SPI I/O function.&lt;/p&gt;
&lt;p&gt;Comments and questions about this article are welcome.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;The Sunfounder Blinking LED project&lt;/a&gt; is the source of the breadboard diagram. It was also the inspiration for this series on Raspberry Pi GPIO programming. See my &lt;a href=&#34;http://10.0.0.223:1313/post/sunfoundergpionotesled/&#34;&gt;Blinking LED project&lt;/a&gt; for more details.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pinout.xyz/&#34;&gt;Raspberry Pi GPIO Pinout diagram&lt;/a&gt; including the physical board pin numbers, the BCM/GPIO pin numbers, and the WiringPi pin numbers.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;The gpio repository&lt;/a&gt; containing the code for this and other articles&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;How to setup a new Raspberry Pi from scratch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;How to use a breadboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;GPIO programming on a Raspberry Pi 3B+&lt;/a&gt; contains a list of my articles about GPIO programming on the Raspberry Pi&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;The BCM2835 Peripherals guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The C &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/index.html&#34;&gt;BCM2835&lt;/a&gt; library by Mike McCauley&lt;/li&gt;
&lt;li&gt;The C &lt;a href=&#34;http://wiringpi.com&#34;&gt;WiringPi&lt;/a&gt; library and associated &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;GitHub repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Python &lt;a href=&#34;http://abyz.me.uk/rpi/pigpio/&#34;&gt;pgpio&lt;/a&gt; library&lt;/li&gt;
&lt;li&gt;The Python &lt;a href=&#34;https://pypi.org/project/RPi.GPIO/&#34;&gt;RPi.GPIO&lt;/a&gt; library&lt;/li&gt;
&lt;li&gt;The Go &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/latest/devicetree/usage-model.html&#34;&gt;Linux and the Devicetree&lt;/a&gt; describes what a Linux device tree is and how it is used.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://adikedia.com/2016/08/10/using-multiple-spi-slave-devices-with-wiringpi/&#34;&gt;Using Multiple SPI Slave Devices with the Raspberry Pi&lt;/a&gt; provides more information about how to use multiple slave devices.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Raspberry Pi GPIO in Go and C - Using a Shift Register &amp; 7 Segment Display</title>
      <link>https://youngkin.github.io/post/shiftregistersevensegdisplay/</link>
      <pubDate>Fri, 19 Nov 2021 13:13:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/shiftregistersevensegdisplay/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This is the fifth article in a series that explores GPIO programming on a Raspberry Pi 3B+. It is a supplement to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.4_7-segment_display_c.html&#34;&gt;Sunfounder 7-Segment Display&lt;/a&gt; project. You can find the full series &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;here&lt;/a&gt;. The code for the series can be found on &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Like the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;Sunfounder RGB LED&lt;/a&gt; project, there are some complicated aspects to this project that aren&amp;rsquo;t well covered in the Sunfounder project documentation. The purpose of this article is to fill those gaps, specifically:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What is a &amp;ldquo;shift register&amp;rdquo; (the 74HC595 chip)?&lt;/li&gt;
&lt;li&gt;What are the uses of a shift register?&lt;/li&gt;
&lt;li&gt;What is a 7-segment display?&lt;/li&gt;
&lt;li&gt;How is a shift register used on conjunction with a 7-segment display?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An additional goal of this article is to provide a more complete example of the capability of shift registers and 7-segment displays using a program written in C. This program is significantly more advanced in this area than the Sunfounder code. This article will also provide this same program written in Go.&lt;/p&gt;
&lt;p&gt;If you haven&amp;rsquo;t worked with LEDs before you should consider having a look at my &lt;a href=&#34;https://youngkin.github.io/post/sunfoundergpionotesled/&#34;&gt;Raspberry Pi GPIO in Go and C - Blinking LED&lt;/a&gt; first. That article covers the basics of using an LED with Raspberry Pi GPIO and the associated C and Go libraries which isn&amp;rsquo;t discussed in this article.&lt;/p&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;This section is repeated in all articles in my &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;Raspberry Pi GPIO series&lt;/a&gt;. If you&amp;rsquo;ve already completed a project from one of these articles you can skim this section, looking only for required items not included in other projects, specifically the shift register and 7-segment display.&lt;/p&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;Stretch&amp;rsquo; version of the Raspbian OS. The Raspberry Pi website has instructions on how to &lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;setup a new Raspberry Pi from scratch&lt;/a&gt; if you decide to go that way vs. buying a complete kit.&lt;/p&gt;
&lt;p&gt;Other items you&amp;rsquo;ll need include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt; &lt;em&gt;(You may find &lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;this tutorial on breadboards&lt;/a&gt; helpful)&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/Resistor-Tolerance-Resistors-Assortment-Certificated/dp/B08QR72BFW/ref=sr_1_8?crid=1E3LWKK431TDV&amp;amp;keywords=resistor+assortment&amp;amp;qid=1636936543&amp;amp;qsid=143-6049131-7886617&amp;amp;s=industrial&amp;amp;sprefix=resistor%2Cindustrial%2C203&amp;amp;sr=1-8&amp;amp;sres=B085NQZNTY%2CB072BL2VX1%2CB07N1ZK8CC%2CB098BKR447%2CB08QR72BFW%2CB07L851T3V%2CB09CZ18Z31%2CB08PF3HNMD%2CB07D54XMFK%2CB088WQMNYK%2CB08NY3XR96%2CB06WRQS97C%2CB07PXYVP3J%2CB07D2Z45CG%2CB089Q88QPN%2CB08ZRYH9VC%2CB08FD1XVL6%2CB08QRH6HFT%2CB07PTNN78Z%2CB07P3MFG5D&#34;&gt;220 Ohm resistor&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/Texas-Instruments-SN74HC595N-Registers-3-State/dp/B01J6WI7RA/ref=sr_1_5?keywords=shift+register+74hc595&amp;amp;qid=1636936939&amp;amp;qsid=143-6049131-7886617&amp;amp;s=industrial&amp;amp;sr=1-5&amp;amp;sres=B07HFWB9L9%2CB01J6WI7RA%2CB0993RQGQY%2CB09CTHBH9P%2CB07B9DCR17%2CB08Z8B9QXY%2CB06WD3W8Q3%2CB07ZHGL8LN%2CB0842PRWJG%2CB07DR7PYYT%2CB01HEPJOV4%2CB07WNHBP86%2CB07RL1398S%2CB07B9D7SPC%2CB08Z3NH5BK%2CB07MQ5X9Q3%2CB07DL13RZH%2CB08JTXNP9Q%2CB08BR1PPQM%2CB01D8KOZF4&#34;&gt;74HC595 shift register&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/microtivity-7-segment-Display-Common-Cathode/dp/B004S95VJE/ref=sr_1_11?crid=AOG8YK9L0NA1&amp;amp;keywords=7+segment+display&amp;amp;qid=1636937044&amp;amp;qsid=143-6049131-7886617&amp;amp;s=industrial&amp;amp;sprefix=7+segment%2Cindustrial%2C211&amp;amp;sr=1-11&amp;amp;sres=B07GTQZ286%2CB00XW2L6SS%2CB07MCGDST2%2CB00EZBGUMC%2CB08THC6NGS%2CB07GTQ8NDC%2CB07GTPYXNF%2CB004S95VJE%2CB00XW2NSU2%2CB0060FGD3M%2CB087B8WTRZ%2CB01D0WSCJA%2CB0060FGCW4%2CB08N15PLSQ%2CB081VDVVSS%2CB07CLCC82N%2CB07GTQFL6J%2CB07GTQ42VR%2CB085WMBYH4%2CB08XPSCG4K&#34;&gt;common cathode 7-segment display&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the T-Type adapter will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. Buying all these things separately will cost more than a kit however.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;amp;pd_rd_i=B06WP7169Y&amp;amp;pd_rd_w=OZVyf&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=0V0IH&amp;amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;Here&amp;rsquo;s a simple kit&lt;/a&gt; that has all (most?) of the above. The photo of the kit appears to show a shift register, but I can&amp;rsquo;t be sure. I&amp;rsquo;m finding the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt; especially useful. NOTE: The Ultimate Starter Kit and the Raphael Kit are the same product.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;You will also need some basic C  and Go programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll also need familiarity with how to use an editor like vim or nano.&lt;/p&gt;
&lt;p&gt;To compile and run the C program you&amp;rsquo;ll need the &lt;a href=&#34;https://github.com/WiringPi&#34;&gt;WiringPi&lt;/a&gt; library. It&amp;rsquo;s easy to get:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install wiringpi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then test the installation using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pi@pi-node1:~/go/src/github.com/youngkin/gpio/rgbled $ gpio -v
gpio version: 2.50
Copyright &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 2012-2018 Gordon Henderson
This is free software with ABSOLUTELY NO WARRANTY.
For details type: gpio -warranty

Raspberry Pi Details:
  Type: Pi 3B+, Revision: 03, Memory: 1024MB, Maker: Sony
  * Device tree is enabled.
  *--&amp;gt; Raspberry Pi &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; Model B Plus Rev 1.3
  * This Raspberry Pi supports user-level GPIO access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above you&amp;rsquo;ll notice &lt;code&gt;gpio version: 2.50&lt;/code&gt;. If you&amp;rsquo;re using a Rasberry Pi 4, use the instructions given in the Sunfounder &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/check_the_wiringpi_c.html&#34;&gt;Checking the WiringPi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;WiringPi is unique in that it includes a command line tool, &lt;code&gt;gpio&lt;/code&gt;, as shown above, that can be used to manage, control, and query the GPIO board. This can be very handy. See the &lt;a href=&#34;http://wiringpi.com/the-gpio-utility/&#34;&gt;gpio reference&lt;/a&gt; for more information on what it can do and how to use it.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in Go development on a Raspberry Pi you&amp;rsquo;ll need to install the development environment onto the Raspberry Pi. &lt;a href=&#34;https://www.jeremymorgan.com/tutorials/raspberry-pi/install-go-raspberry-pi/&#34;&gt;Here&amp;rsquo;s a simple source&lt;/a&gt; that explains how to accomplish this. This source is a little dated, but the only significant issue is with the version of Go to install. The source shows installing Go &lt;strong&gt;1.14.4.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.14.4.linuxarmv6l.tar.gz&lt;/strong&gt;. The current versions are &lt;strong&gt;1.17.1.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. For the Raspberry Pi 3B+ the correct choice will be &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. The other is intended for 64 bit systems like the Raspberry Pi 4 series. You can find current ARM versions of Go at the &lt;a href=&#34;https://golang.org/dl/&#34;&gt;Golang download site&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For Go development you&amp;rsquo;ll also need the &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; library.&lt;/p&gt;
&lt;p&gt;If you want to veer away from the cookbook style of the Sunfounder docs you&amp;rsquo;ll need some basic knowledge of Linux . For example, I won&amp;rsquo;t be explaining what &lt;strong&gt;root privileges&lt;/strong&gt; are.&lt;/p&gt;
&lt;h2 id=&#34;information-that-would-have-been-helpful&#34;&gt;Information that would have been helpful&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.4_7-segment_display_c.html&#34;&gt;Sunfounder 7-Segment Display&lt;/a&gt; project documentation pretty much just jumps into how to wire up the breadboard and the code without mentioning much about the hardware components, especially the shift register. Even the code description was a little confusing given my lack of knowledge about shift registers. I accidentally stumbled across the &lt;a href=&#34;https://docs.sunfounder.com/projects/electronic-kit/en/latest/lesson_19_7-segment.html&#34;&gt;Sunfounder 7-Segment Python&lt;/a&gt; project documentation that did provide some useful information on the 7-segment display, but still no mention of the shift register. This project could easily be done without the shift register, in fact many &lt;a href=&#34;https://www.circuitbasics.com/arduino-7-segment-display-tutorial/&#34;&gt;other articles on 7-segment displays&lt;/a&gt; do just that. So why does the project use a shift register? Why not just wire the 7-segment display directly to the GPIO pins? Clearly there&amp;rsquo;s something to the shift register and I wanted to know what that was. It turns out, for me anyway, that this project is really about shift register with the 7-segment display being merely a tool to visualize how shift registers work. But before we get to shift registers, let&amp;rsquo;s have a short discussion about 7-segment displays.&lt;/p&gt;
&lt;h3 id=&#34;what-is-a-7-segment-display&#34;&gt;What is a 7-segment display?&lt;/h3&gt;
&lt;p&gt;So what is a 7-segment display? Well, to be pedantic, it has 8 segments if you include the decimal point on the device. That aside, it&amp;rsquo;s a common device you&amp;rsquo;re already familiar with having seen them used in everything from clocks to calculators and other devices that need a numeric display. In terms of the physical implementation there are a few details we need to know.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Pinout diagram&lt;/th&gt;
&lt;th&gt;LED Identification diagram&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/7segmentdisplaypinout.png&#34; align=&#34;center&#34; width=&#34;150&#34;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/sevensegmentdisplaydiagram.png&#34; align=&#34;center&#34; width=&#34;200&#34;/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;&lt;a href=&#34;https://www.circuitbasics.com/arduino-7-segment-display-tutorial/&#34;&gt;Image Credit: Circuit Basics&lt;/a&gt;&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;First of all, the diagram to the above left shows the pinout designations for the 7-segment display. This diagram shows the middle pins on the top and the bottom with a (-) annotation. This designates those pins to be the ground pins for the display. The letters on the remaining pins correspond to the letters in the LED identification diagram on the right. For example, applying power to the &amp;lsquo;A&amp;rsquo; pin on the display will light up the LED labeled &amp;lsquo;A&amp;rsquo; in the diagram to the right. The letters &amp;ldquo;DP&amp;rdquo; stand for decimal point.&lt;/p&gt;
&lt;p&gt;For this project we need what is known as a common cathode 7-segment display. This is what the diagram above left is showing &lt;em&gt;(the middle pins on the top and the bottom have a (-) annotation)&lt;/em&gt;. All this means is that all the negative terminals of the LEDs in the display are connected to a common ground pin. Common anode is the other type, which as you might expect, means all the LEDs&amp;rsquo; positive terminals are connected to the same pin.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/commoncathodeoranode.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;&lt;a href=&#34;https://www.circuitbasics.com/arduino-7-segment-display-tutorial/&#34;&gt;Image Credit: Circuit Basics&lt;/a&gt;&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;If you&amp;rsquo;re using the Sunfounder kit the 7-segment display is a common cathode display. If you got a 7-segment display from another source you might want to verify it&amp;rsquo;s type. Determining whether a 7-segment display is a common cathode or common anode is fairly easy to do. Paraphrasing from &lt;a href=&#34;https://www.circuitbasics.com/arduino-7-segment-display-tutorial/&#34;&gt;How to set up seven segment displays on the Arduino&lt;/a&gt;, &lt;em&gt;which is also the source of the above diagram&lt;/em&gt;, the steps are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;While the above diagram shows an Arduino, hooking it up to a Raspberry Pi is very similar.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;You&amp;rsquo;ll need the Raspberry Pi 3.3v power pin hooked up to a breadboard.
&lt;ol&gt;
&lt;li&gt;Connect the power from the Raspberry Pi as shown above (or to the breadboard&amp;rsquo;s power bus).&lt;/li&gt;
&lt;li&gt;Connect a resistor between the 2 sides of the breadboard, or from the power bus to one side of the breadboard.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Connect a jumper wire (red) on the far end of the resistor from the power source.&lt;/li&gt;
&lt;li&gt;Connect a jumper wire (black) to the Raspberry Pi&amp;rsquo;s GPIO ground pin.&lt;/li&gt;
&lt;li&gt;Connect the black jumper wire (ground) to the middle pin, top or bottom, of the display.&lt;/li&gt;
&lt;li&gt;Connect the red jumper wire (positive) to any of the other pins (except the middle pin!).&lt;/li&gt;
&lt;li&gt;If an LED lights up the display is a common cathode.&lt;/li&gt;
&lt;li&gt;If an LED doesn&amp;rsquo;t light up
&lt;ol&gt;
&lt;li&gt;Disconnect the jumpers from the display&lt;/li&gt;
&lt;li&gt;Connect the red jumper to one of the middle pins, top or bottom&lt;/li&gt;
&lt;li&gt;Connect the black wire to one of the other pins.&lt;/li&gt;
&lt;li&gt;At this point an LED should light up and you&amp;rsquo;ve verified that the display is a common anode display&lt;/li&gt;
&lt;li&gt;If no LED lights up then double-check your wiring.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://youtu.be/Fa7BHbPAM98&#34;&gt;This YouTube video&lt;/a&gt; shows how to accomplish this using a multimeter instead of wiring up a breadboard as described above.&lt;/p&gt;
&lt;h3 id=&#34;what-is-a-shift-register-and-what-is-it-good-for&#34;&gt;What is a shift register and what is it good for?&lt;/h3&gt;
&lt;p&gt;There are &lt;a href=&#34;https://www.elprocus.com/what-is-a-shift-register-different-types-counters-and-applications/&#34;&gt;several types of shift registers&lt;/a&gt;. For this project we&amp;rsquo;re using what&amp;rsquo;s known as a &amp;ldquo;Serial In, Parallel Out&amp;rdquo; (SIPO) shift register. This type of shift register converts a serial input into a parallel output. For example, several pulses of a signal generated on a single Raspberry Pi GPIO pin can be accumulated by the shift register and then sent as a single parallel output to a 7-segment display. This is exactly what is being done in this project.&lt;/p&gt;
&lt;p&gt;So why use a shift register? Well for one, as noted above, it only takes one GPIO pin to drive 8 pins on a 7-segment display &lt;em&gt;(not quite true, this will be explained in more detail farther into the article)&lt;/em&gt;. Versions of this project without a shift register take 8 GPIO pins to accomplish the same thing. So, one use of a shift register is to conserve GPIO pins. This is especially true of LED displays with a very large number of LEDs that perhaps wouldn&amp;rsquo;t be usable due to a lack of available GPIO pins. Although this isn&amp;rsquo;t true of a 7-segment display, some devices only take parallel input. So for this kind of situation, a SIPO shift register is mandatory in converting a serial source into a parallel output.&lt;/p&gt;
&lt;h4 id=&#34;shift-register-anatomy&#34;&gt;Shift register anatomy&lt;/h4&gt;
&lt;p&gt;The 74HC595 shift register has a couple of logical components that are pertinent to this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input shift register - This is a series of connected flip-flop devices that receive incoming (serial) data on the receipt of each synchronizing clock pulse (more about this later). This register is comprised of outputs that are named in sequence from Qa&amp;rsquo; to Qh&amp;rsquo;, i.e., Qa&amp;rsquo;, Qb&amp;rsquo;, &amp;hellip;, Qh&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;Output or storage register - This is another series of connected flip-flop devices that transfer the serial data in parallel to a connected device. This register is comprised of outputs that are named in sequence from Qa to Qh, and Qh&amp;rsquo; (more on Qh&amp;rsquo; below).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This anatomy is shown graphically in the following, albeit somewhat complex, diagram from the &lt;a href=&#34;https://www.ti.com/lit/ds/symlink/cd74hc595.pdf?ts=1636840974607&amp;amp;ref_url=https%253A%252F%252Fwww.google.com%252F&#34;&gt;Texas Instruments CD74HC595 8-Bit Shift Registers with 3-State Output Registers datasheet&lt;/a&gt;. The first column of 8 boxes to the left, labeled C1 or C2, comprise the input shift register. The second column of 8 boxes to the right, labeled C3, comprise the output shift register. The output register&amp;rsquo;s output pins can be seen at the far right, labeled Qa through Qh, and Qh&amp;rsquo;. The input and control channels, as shown by OE, RCLK, SRCLR, SRCLK, and SER in the upper left of the diagram, are discussed in more detail below.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/74HC595Schematic.png&#34; align=&#34;center&#34; width=&#34;600&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;&lt;a href=https://www.ti.com/lit/ds/symlink/cd74hc595.pdf?ts=1636840974607&amp;ref_url=https%253A%252F%252Fwww.google.com%252F&#34;&gt;TI CD74HC595 schematic diagram - Image Credit: Texas Instruments&lt;/a&gt;&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;More information pertaining to the Q* names for the registers&amp;rsquo; outputs is provided below.&lt;/p&gt;
&lt;p&gt;It is a little confusing for the entire device to be called shift register as well as the input component to also be called shift register. To differentiate between the two, if it&amp;rsquo;s not clear from the context, I&amp;rsquo;ll make sure to reference which one I&amp;rsquo;m referring to when the term is used later in the article.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Pin Diagram&lt;/th&gt;
&lt;th&gt;Photo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/74hc595shiftregister.png&#34; align=&#34;center&#34; width=&#34;600&#34; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/74HC595Photo.png&#34; align=&#34;center&#34; width=&#34;370&#34;/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;&lt;a href=https://www.ti.com/lit/ds/symlink/cd74hc595.pdf?ts=1636840974607&amp;ref_url=https%253A%252F%252Fwww.google.com%252F&#34;&gt;Image Credit: Texas Instruments&lt;/a&gt; (Left) and Author (Right)&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The diagram at above left shows the pinouts for a SN74HC595 shift register. The photo at above right is in the same orientation as the pin diagram, namely GND is in the lower left, Vcc is in the upper right, and the &amp;ldquo;notch&amp;rdquo; is at the top center. The pins are defined as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pin 15&lt;/strong&gt; (right side, 2nd from the top), Qa, is the first output pin. Qa is also known as Q0.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pins 1-7&lt;/strong&gt;, Qb-Qh, are the remaining output pins. Notice that there are 8 output pins (including Qa above). Having 8 outputs makes this an 8-bit shift register. Qb-Qh are also known as Q1-Q7.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 8&lt;/strong&gt;, GND is the ground pin.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 16&lt;/strong&gt;, Vcc, is the power-in pin.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 14&lt;/strong&gt;, SER, is the serial input pin. This is the pin that takes the incoming serial data pulses from the Raspberry Pi. This is sometimes referred to as DS, SI, or SDI.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 11&lt;/strong&gt;, SRCLK, is the pin that accepts the synchronization signal that indicates 1 bit of data has been transmitted to the SER pin. This type of signal is called a clock. SRCLK stands for shift register clock. SRCLK is also known as sh_cp.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 12&lt;/strong&gt;, RCLK, is the pin that accepts the synchronization signal that indicates all 8 shift register bits have been populated and it&amp;rsquo;s time to transfer the bits, in parallel, to the output/storage register and thereby to the device connected to the output pins, Qa-Qh. RCLK is also known as st_cp or latch.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 10&lt;/strong&gt;, SRCLR, is used to clear the current values of the shift register. SRCLR stands for shift register clear. SRCLR is also known as MR. If clearing the shift register is not required it can be connected to the power source which generates a HIGH signal (or 1). To clear the shift register the SRCLR pin is set to LOW (or 0). It must be set back to HIGH before the shift register is functional again.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 13&lt;/strong&gt;, OE, is used to block the availability of the output or storage register. The OE pin&amp;rsquo;s effect is temporary. When it&amp;rsquo;s set to LOW (0) the data in the output register is accessible. When it&amp;rsquo;s HIGH(1) the data is not accessible. Setting it from HIGH to LOW makes the data once again accessible. Unlike the SRCLR pin, it does not clear the register. If disabling the output register is not required it can be connected to ground.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pin 9&lt;/strong&gt;, Qh&amp;rsquo;, is used to daisy chain multiple shift registers. For example, imagine a project that needed to control 16 LEDs in a parallel fashion. In this case a single 8-bit shift register is inadequate, we need 2 that can communicate in some manner. We can get the other required 8 bits from a second 8-bit shift register. To link the 2 shift registers we connect the Qh&amp;rsquo; output from the first, to pin 14, SER, on the second shift register. Daisy chaining shift registers is beyond the scope of this project, but you can read more about it on &lt;a href=&#34;https://www.electroschematics.com/multiple-shift-registers-arduino-part-1/&#34;&gt;Multiple Shift-out Registers on Arduino - part 1&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shift-register-in-operation&#34;&gt;Shift register in operation&lt;/h4&gt;
&lt;p&gt;As stated above, input data is stored in the input shift register. Data is transferred on each pulse of the SRCLK input. When an SRCLK input is received, data on a prior Q*&amp;rsquo; pin is shifted to the next Q*&amp;rsquo; register in the sequence. When the input shift register has been populated an RCLK signal causes all of the input register contents to be transferred to the output register. The following table illustrates this behavior. To keep things simple, I&amp;rsquo;m limiting the example to 4 bits, Qa* to Qd*. The input bit sequence will be &lt;code&gt;1011&lt;/code&gt;. The first bit, &lt;code&gt;1&lt;/code&gt;, will be transmitted at t0. The transmitted bits are indicated in parentheses next to the time indication (e.g., &lt;code&gt;t0(1)&lt;/code&gt;). The 4 bits become available at the output register on a signal from RCLK at t4.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SRCLK&lt;/th&gt;
&lt;th&gt;t0 (1)&lt;/th&gt;
&lt;th&gt;t1 (0)&lt;/th&gt;
&lt;th&gt;t2 (1)&lt;/th&gt;
&lt;th&gt;t3 (1)&lt;/th&gt;
&lt;th&gt;t4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Qa&amp;rsquo;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qb&amp;rsquo;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qc&amp;rsquo;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qd&amp;rsquo;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;RCLK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qa&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qb&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qc&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qd&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Notice that in the output sequence of bits, if the output bits are read from Qa to Qd, the bit sequence is reversed. That is, &lt;code&gt;1101&lt;/code&gt; vs. the input sequence of &lt;code&gt;1011&lt;/code&gt;. This manner of shifting is called Most Significant Bit (MSB) shifting. It starts with the leftmost bit as in this example. This must be kept in mind or unexpected results may occur. It is possible to shift in a more intuitive way, Least Significant Bit (LSB). To do this the shifting must start with the least, or rightmost, input bit. In C and Go, MSB shifting is done using the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; shift operator. LSB shifting is done by using the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; shift operator. The impact of shift method will become more obvious when we get to how the shift register (not the input shift register) is used in conjunction with the 7-segment display. &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_numbering&#34;&gt;See Wikipedia for more about MSB and LSB&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As noted previously, I simplified things a little bit when I stated above that only one Raspberry Pi GPIO pin is needed to drive the 8 LED segments in the 7-segment display. The one pin I identified is used for the SER (serial data in) pin. A minimum of 2 more are needed; 1 for the SRCLK pin and the other for the RCLK pins. As shown above these are required to advance the clock on the input shift register and transfer data from the input shift register to the output register respectively. So that&amp;rsquo;s now 3 pins to drive the 8 LEDs on the 7-segment display. This is still a good tradeoff. But 2 more GPIO pins are needed if the SRCLR and OE pins are needed. So now that&amp;rsquo;s 5 GPIO pins to drive 8 LED segments. Still a net gain of 3 pins. However, the savings become even greater when shift registers are daisy-chained as discussed above. Without requiring additional GPIO pins it is possible to control 16 or even more LEDs from those 5 GPIO pins. The savings become more significant as more devices, e.g., LEDs, need to be controlled.&lt;/p&gt;
&lt;h3 id=&#34;how-does-this-project-use-the-shift-register-and-7-segment-display&#34;&gt;How does this project use the shift register and 7-segment display?&lt;/h3&gt;
&lt;p&gt;This project uses the shift register component to capture serial input, accumulate it until 8 bits are written, and then make it available to the output register. Since the shift register component is wired to the 7-segment display, the contents of the output register are made available to the 7-segment display, controlling what is ultimately displayed. The details of the pin connections from the shift register component to the 7-segment display pins, coupled with the shift method used, MSB in this case, dictate what LEDs will be illuminated on the 7-segment display. The following table provides the specific pin assignments as well as what the final values at the output register will be given that the input number is &lt;code&gt;0x3f&lt;/code&gt;, &lt;code&gt;0011 1111&lt;/code&gt;, is used with MSB shifting.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;74HC595 pin&lt;/th&gt;
&lt;th&gt;7-segment display pin&lt;/th&gt;
&lt;th&gt;Final value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Qa&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qb&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qc&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qd&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qe&lt;/td&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qf&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qg&lt;/td&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Qh&lt;/td&gt;
&lt;td&gt;DP&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Using the diagrams below we can ascertain what number will be displayed at the 7-segment LED.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Pinout diagram&lt;/th&gt;
&lt;th&gt;LED Identification diagram&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/7segmentdisplaypinout.png&#34; align=&#34;center&#34; width=&#34;150&#34;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/sevensegmentdisplaydiagram.png&#34; align=&#34;center&#34; width=&#34;200&#34;/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;&lt;a href=&#34;https://www.circuitbasics.com/arduino-7-segment-display-tutorial/&#34;&gt;Image Credit: Circuit Basics&lt;/a&gt;&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;7-segment display pins A-F will have the value 1, G and DP will have the values 0. Mapping this to the above LED Identification diagram we can see that the number displayed will be &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;setup-and-code&#34;&gt;Setup and Code&lt;/h2&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/breadboard.png&#34; align=&#34;center&#34; width=&#34;800&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder wiring diagram - &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.4_7-segment_display_c.html&#34;&gt;Image Credit - Sunfounder&lt;/a&gt;&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/flatbreadboard2.png&#34; align=&#34;center&#34; width=&#34;800&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Actual wiring (mostly) - Image Credit: Author&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The breadboard should be wired as illustrated in the above diagram &lt;em&gt;(as indicated in the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.4_7-segment_display_c.html&#34;&gt;Sunfounder 7-Segment Display&lt;/a&gt; project documentation)&lt;/em&gt;. One very important thing to note, something that I spent way too much time debugging, is that the resistor connecting the ground pin on the 7-segment display must be connected to the ground or negative bus on the breadboard. In all my prior projects I&amp;rsquo;ve connected the resistor to the positive breadboard bus. I initially missed this detail and the 7-segment display didn&amp;rsquo;t display anything. One other thing I got wrong on the initial wiring is that I had the 74HC595 output register pins connected incorrectly to the 7-segment display. This is easy to do. I debugged this by noting which LED segments lit up for which expected number. After going through several numbers it became apparent that I had the &amp;lsquo;G&amp;rsquo; and &amp;lsquo;E&amp;rsquo; pins on the 7-segment display reversed.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re unfamiliar  with breadboards and breadboard diagrams this &lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;breadboard tutorial &lt;/a&gt; should be helpful.&lt;/p&gt;
&lt;h3 id=&#34;shift-register7-segment-display-in-c&#34;&gt;Shift Register/7-Segment Display in C&lt;/h3&gt;
&lt;p&gt;This code is quite different from the Sunfounder code. This is because I chose to add several capabilities including:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Support for an interrupt handler. This will gracefully exit the program by clearing the input shift register thereby turning off all the LEDs. The Sunfounder program will leave the LEDs in whatever state they were in when that version exits.&lt;/li&gt;
&lt;li&gt;It supports setting both the SRCLR and OE shift register pins.&lt;/li&gt;
&lt;li&gt;It adds support for illuminating the decimal point in the 7-segment display.&lt;/li&gt;
&lt;li&gt;It add several functions that provide the ability to test different capabilities of the 74HC595 shift register including using the SRCLR and OE pins.&lt;/li&gt;
&lt;li&gt;It accepts user input from the keyboard allowing the user to specify how they&amp;rsquo;d like the program to drive the shift register and hence the LED. This includes things like clearing the input shift register, disabling and reenabling the output register as well as writing all hexadecimal digits/decimal point as well as writing an &lt;code&gt;8.&lt;/code&gt; to the display.&lt;/li&gt;
&lt;/ol&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/84d8e9f350d19d184255adb3fb7ad93c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Most of this is pretty well explained by the embedded comments, but I&amp;rsquo;ll mention of few highlights.&lt;/p&gt;
&lt;p&gt;Lines 12 and 13 provide information on how to build and run the program.&lt;/p&gt;
&lt;p&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/sevensegdisplay/74hc595shiftregister.png&#34; align=&#34;center&#34; width=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;&lt;a href=https://www.ti.com/lit/ds/symlink/cd74hc595.pdf?ts=1636840974607&amp;ref_url=https%253A%252F%252Fwww.google.com%252F&#34;&gt;Image Credit: Texas Instruments&lt;/a&gt;&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;Lines 27 and 28 define the GPIO pins that drive the SRCLR and OE pins respectively. Note that the GPIO pin numbers are the &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; pin numbers. If you decide you want to see this behavior in action, wire pin 24 to the SRCLR shift register pin, and wire pin 29 to the OE shift register pin instead of positive and ground respectively.&lt;/p&gt;
&lt;p&gt;Lines 32 and 33 define an array, &lt;code&gt;SegCode&lt;/code&gt;, that contains the hexadecimal numbers that will be shifted into the shift register in order to display a number that matches the index of a particular number in the array. For example, to display an 8 &lt;code&gt;SegCode[8]&lt;/code&gt; should be used. Note that these numbers reflect the use of the MSB form of shifting. The numbers would be different if the LSB shifting form were used. For example, the number to use to display 0, as shown on line 32, is &lt;code&gt;0x3F&lt;/code&gt; (&lt;code&gt;0011 1111&lt;/code&gt;). To display 0 using the LSB method the hex number &lt;code&gt;0xFC&lt;/code&gt;(&lt;code&gt;1111 1100&lt;/code&gt;) and the C right-shift operator, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, should be used.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/f9f9d14b5405805f9f2ef31ec36d7c46.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet shows the initialization of the shift register. In a nutshell, all the pins we&amp;rsquo;re using are placed in OUTPUT mode so we can write to them. Next, all pins except for the SRCLR pin are set to LOW (0). Recall that the SRCLR pin must be set to HIGH for the shift register to be operational.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The alternative to pin mode OUTPUT is PWM (Pulse Width Modulation). Since PWM simulates lower voltages by rapidly pulsing the associated pin it&amp;rsquo;s not suitable for use with shift registers. Recall that a pulse to the SRCLK and RCLK pins represents a clock advancing. Using PWM, and the resulting rapid pulsing, would interfere with the clocks advancing in a reliable manner.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/332b51486edd22771dda7bac8f88ae62.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This code snippet demonstrates 2 methods of turning off all the LEDs in the 7-segment display. Specifically, it shows how to use both the SRCLR pin and writing zeros to all the input shift register bits to clear the input shift register that will result in the 7-segment display showing nothing.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;shiftRegClr&lt;/code&gt;, lines 1 through 11, note the use of the RCLK pin on lines 4 and 6. The clock signal to that pin must be pulsed, i.e., set to HIGH followed by LOW, in order to make the input shift register contents available to the output register. Also note that the SRCLR pin needs to be reset to HIGH after the operation to reenable the shift register.&lt;/p&gt;
&lt;p&gt;Lines 16 through 28 show the method of writing zeros to all the input shift register bits to clear the input shift register (&lt;code&gt;zeroClear()&lt;/code&gt;). This is functionally equivalent to using the SRCLR method, they both set the input shift register bits to 0. It does take a lot more effort however. The &lt;code&gt;for&lt;/code&gt; loop in lines 18 through 23 shifts a zero into each bit of the input shift register. It repeats the process 8 times, advancing the SRCLK with each write, to fill the input shift register bits. Lines 20 and 22 send the SRCLK pulse to advance the input shift register bits. Strictly speaking, it&amp;rsquo;s not necessary to shift the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; it to &lt;code&gt;0x80&lt;/code&gt; on line 19. It would be sufficient to merely write &lt;code&gt;0&lt;/code&gt; to the SDI pin. However, it is necessary to use this method of writing to the SDI pin write any other number, e.g., &lt;code&gt;0x3F&lt;/code&gt; into the input shift register.&lt;/p&gt;
&lt;p&gt;As with &lt;code&gt;shiftRegClr()&lt;/code&gt; above, lines 25 and 27 toggle the RCLK pin to transfer the bits to the output register.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/ce54e1d33e27f7005dcabfde0611f0e6.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next code snippet demonstrates how to light up all the LEDs, including the decimal point, as well as toggling the OE pin to temporarily disable the output register.&lt;/p&gt;
&lt;p&gt;Lines 3 through 15 show &lt;code&gt;writeAllOnes()&lt;/code&gt;. It&amp;rsquo;s implemented almost exactly like &lt;code&gt;zeroClear()&lt;/code&gt; above. The one notable exception is that it doesn&amp;rsquo;t left-shift the 1 and &lt;code&gt;&amp;amp;&lt;/code&gt; it to &lt;code&gt;0x80&lt;/code&gt; before writing it to the pin. This demonstrates that when all input shift register bits will have the same value, i.e., 1 or 0, it&amp;rsquo;s not necessary to do this. It does however repeat the process of writing to the pin 8 times, advancing the SRCLK clock after each write.&lt;/p&gt;
&lt;p&gt;Lines 22 through 29 implement &lt;code&gt;oeToggle()&lt;/code&gt;, which toggles the OE pin to HIGH (1) and then LOW again. There&amp;rsquo;s a 1 second delay between the writes to ensure that the effect is visible. Recall that setting to OE pin to HIGH is how the output register is disabled. From the observer&amp;rsquo;s perspective, the 7-segment display will turn off for 1 second and then be restored to whatever was being displayed prior to the toggling. It&amp;rsquo;s up to the calling function to decide what is displayed on the 7-segment display prior to calling this function.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/beb013db757698a7467564c6f118e99a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code&gt;hc595_shift()&lt;/code&gt; is responsible for shifting the various bits of the input number, &lt;code&gt;dat&lt;/code&gt;, into the input shift register. With the exception that the input number is variable based on what the value of &lt;code&gt;dat&lt;/code&gt; is, the function is implemented exactly like &lt;code&gt;zeroClr()&lt;/code&gt; above. In fact, both &lt;code&gt;zeroClr()&lt;/code&gt; and &lt;code&gt;writeAllOnes()&lt;/code&gt; can, and probably should have been, implemented using &lt;code&gt;hc595_shift()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For those that might have trouble imagining how the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; works in conjunction with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, like I did, here&amp;rsquo;s a short example using &lt;code&gt;0x3f&lt;/code&gt; or &lt;code&gt;0011 1111&lt;/code&gt; as an example. Note that the order of precedence of the operations is that &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; happens first followed by the &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;i&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;dat&lt;/code&gt; after shift&lt;/th&gt;
&lt;th&gt;&lt;code&gt;dat &amp;amp; 0x80&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;result written to the SDI pin&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0011 1111&lt;/td&gt;
&lt;td&gt;0011 1111 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0111 1110&lt;/td&gt;
&lt;td&gt;0111 1110 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1111 1100&lt;/td&gt;
&lt;td&gt;1111 1100 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1111 1000&lt;/td&gt;
&lt;td&gt;1111 1000 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1111 0000&lt;/td&gt;
&lt;td&gt;1111 0000 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1110 0000&lt;/td&gt;
&lt;td&gt;1110 0000 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;1100 0000&lt;/td&gt;
&lt;td&gt;1100 0000 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;1000 0000&lt;/td&gt;
&lt;td&gt;1000 0000 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;0000 0000&lt;/td&gt;
&lt;td&gt;0000 0000 &amp;amp; 1000 0000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The last entry, &lt;code&gt;i = 8&lt;/code&gt;,  is what would happen if &lt;code&gt;dat&lt;/code&gt; was shifted 9 times instead of 8. This was included just to make it clear that &lt;code&gt;dat&lt;/code&gt; has been shifted 8 bits to the left leaving all 8 bits set to 0.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/ba2fdb83fa9819be02fb8237aa299fd1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Most of the functions in the above code snippet merely setup the test by setting the display to &lt;code&gt;8&lt;/code&gt;, and then delegate the behavior to the functions that we saw implemented above (e.g., &lt;code&gt;shiftRegCLr()&lt;/code&gt;). Instead of merely displaying an &lt;code&gt;8&lt;/code&gt;, &lt;code&gt;testWriteNum()&lt;/code&gt; will rotate through all the hexadecimal numbers and decimal point.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/dc409c1a8995949b09f51baccdf81752.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Finally, this code snippet implements the &lt;code&gt;main()&lt;/code&gt; and &lt;code&gt;interruptHandler()&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;Line 3 registers a signal handler, &lt;code&gt;interruptHandler()&lt;/code&gt;, with interest in the &lt;code&gt;SIGINT&lt;/code&gt; signal. &lt;code&gt;SIGINT&lt;/code&gt; is what will be generated when &lt;code&gt;ctl-C&lt;/code&gt; is entered at the terminal.&lt;/p&gt;
&lt;p&gt;Lines 6 through 9 initialize the WiringPi library, exiting if the initialization fails.&lt;/p&gt;
&lt;p&gt;Line 16 prompts the user for what behavior they&amp;rsquo;d like to see demonstrated.&lt;/p&gt;
&lt;p&gt;Lines 17 through 25 first read the terminal input from the user and populate a null terminated string with the results. The code doesn&amp;rsquo;t care for any characters that might have been entered except the first character. Any additional characters between it and the newline will be ignored.&lt;/p&gt;
&lt;p&gt;Line 26 frees the memory allocated by &lt;code&gt;getline()&lt;/code&gt; on line 19. This is necessary to avoid memory leaks. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand this. It&amp;rsquo;s not important to what&amp;rsquo;s being demonstrated in this program. If you&amp;rsquo;re interested, investigate memory allocation in C including how memory is allocated (&lt;code&gt;malloc&lt;/code&gt;), how it&amp;rsquo;s freed (&lt;code&gt;free&lt;/code&gt;), why this is important, and finally the operation of the &lt;code&gt;getline()&lt;/code&gt; function. Otherwise just remember it&amp;rsquo;s required.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;ASIDE: strictly speaking it&amp;rsquo;s not actually required in this program as the resulting memory leak is likely to be trivial in normal use. At a minimum it&amp;rsquo;s bad form to not &lt;code&gt;free&lt;/code&gt; all allocated memory when it&amp;rsquo;s no longer needed. At worst, the program can fail in various ways once all available memory has been allocated. So, call &lt;code&gt;free&lt;/code&gt; when the memory associated with a variable like &lt;code&gt;line&lt;/code&gt; is no longer needed.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation&#34;&gt;Wikipedia&lt;/a&gt; has a very detailed discussion about memory allocation and management.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Lines 28 through 56 detect which option the user chose and call the function associated with that option. The entire process described from line 15 onwards is repeated until the user chooses the (q)uit option.&lt;/p&gt;
&lt;p&gt;Lines 63 through 67 register the signal handler that will gracefully exit the program if &lt;code&gt;ctl-C&lt;/code&gt; is entered at the terminal. It calls &lt;code&gt;toggle8()&lt;/code&gt; which briefly displays an &lt;code&gt;8&lt;/code&gt; before turning off all the LEDs in the 7-segment display.&lt;/p&gt;
&lt;h3 id=&#34;shift-register7-segment-display-in-go&#34;&gt;Shift Register/7-Segment Display in Go&lt;/h3&gt;
&lt;p&gt;The Go program is very similar to the C version. There are some minor differences in the implementation and the runtime output. Some of these differences are due to structural differences between the languages as well as differences in coding conventions. The snippets below represent most, but not all of the program. I left out some of the boiler plate and whitespace.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/372686065e31b4fcc896de3398e3a80a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;There are 4 major parts to this snippet. The first is the definition of the &lt;code&gt;segcode&lt;/code&gt; variable on line 3. It serves the same purpose as &lt;code&gt;SegCode&lt;/code&gt; in the C program, namely defining the values to be left-shifted into the shift register. One thing of note is that, as with the C version, these values are dependent on the use of Most Significant Bit shifting (MSB). For convenience, here&amp;rsquo;s the explanatory text from the C version:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;SegCode&lt;/code&gt; &amp;hellip; contains the hexadecimal numbers that should be shifted into the shift register in order to display a number that matches the index of a particular number in the array. For example, to display an 8 &lt;code&gt;SegCode[8]&lt;/code&gt; should be used. Note that these numbers reflect the use of the MSB form of shifting. The numbers would be different if the LSB shifting form were used. For example, the number to use to display 0, as shown on line 32, is &lt;code&gt;0x3F&lt;/code&gt; (&lt;code&gt;0011 1111&lt;/code&gt;). To display 0 using the LSB method the hex number &lt;code&gt;0xFC&lt;/code&gt;(&lt;code&gt;1111 1100&lt;/code&gt;) and the C right-shift operator, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, should be used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Second, lines 7-13, in &lt;code&gt;main()&lt;/code&gt;, initialize the go-rpio library. Line 13 guarantees that the resources held by the go-rpio library will be released on program termination.&lt;/p&gt;
&lt;p&gt;Third, lines 15-20, create the go-rpio &lt;code&gt;rpio.Pin&lt;/code&gt; objects that are manipulated by the rest of the program.&lt;/p&gt;
&lt;p&gt;Finally, lines 22-35, define a signal/interrupt handler to catch &lt;code&gt;ctl-C&lt;/code&gt; inputs from the terminal. This is needed to gracefully exit the program if the user enters &lt;code&gt;ctl-C&lt;/code&gt; at the keyboard. A key point to notice in this snippet is the use of the channel named &lt;code&gt;stop&lt;/code&gt;. The signal/interrupt handler runs in its own goroutine (line 35). At this point there are 2 goroutines running, the &lt;code&gt;main()&lt;/code&gt; goroutine and the goroutine associated with the signal/interrupt handler. They are run and scheduled independently and as a result control can shift from one goroutine to another in arbitrary and unpredictable ways. In order to gracefully shutdown the program they must both be stopped in a controlled manner. Otherwise exiting the program would result in unpredictable behavior. For example, at program exit the 7-segment display might still have some illuminated LEDs. Synchronizing program exit using the &lt;code&gt;stop&lt;/code&gt; channel prevents this from happening. See the Tour of Go lessons on &lt;a href=&#34;https://tour.golang.org/concurrency/1&#34;&gt;Goroutines&lt;/a&gt; and &lt;a href=&#34;https://tour.golang.org/concurrency/2&#34;&gt;Channels&lt;/a&gt; for a quick introduction to goroutines and channels. Don&amp;rsquo;t worry if you don&amp;rsquo;t quite understand all this, concurrency in Go is an advanced topic. Mostly I just wanted to provide a high level explanation of why the code is written this way.&lt;/p&gt;
&lt;p&gt;The program comments provide additional detail. The rest of &lt;code&gt;main()&lt;/code&gt; is in the following snippet.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/84ed027cd69b1682444466703b2c699a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The rest of &lt;code&gt;main()&lt;/code&gt; as shown above handles prompting the user about what capability they&amp;rsquo;d like to see demonstrated is fairly self-explanatory. One thing to point out though is the &lt;code&gt;for/select&lt;/code&gt; loop starting in lines 2-8. &lt;code&gt;for/select&lt;/code&gt; is a common pattern used in Go programs. It&amp;rsquo;s use here goes back to the the prior discussion about the &lt;code&gt;stop&lt;/code&gt; channel. The &lt;code&gt;select&lt;/code&gt; part of the &lt;code&gt;for/select&lt;/code&gt; pattern is listening on the &lt;code&gt;stop&lt;/code&gt; for the message indicating this goroutine should exit. Notice the &lt;code&gt;select&lt;/code&gt; had 2 &lt;code&gt;case&lt;/code&gt; choices. The first is for listening to the &lt;code&gt;stop&lt;/code&gt; channel. If a message is received the &lt;code&gt;for&lt;/code&gt; loop, and program, will exit. If no message is received then control will immediately pass to the &lt;code&gt;default&lt;/code&gt; case, continuing with normal program flow. In the &lt;code&gt;default&lt;/code&gt; case the user is prompted, in lines 18-57, for their choice which will result in one of the test functions being called.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/61200f26ffe1211c8b09efb87a6b82d8.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;There are 3 parts to this next code snippet. The first is the creation of the go-rpio &lt;code&gt;rpio.Pin&lt;/code&gt; objects that represent the logical connection to the shift register&amp;rsquo;s physical pins. The GPIO/BCM pins 17, 18, 27, 19, and 21 are used for the SDI, RCLK, SRCLK, SRCLR, and OE pins respectively.&lt;/p&gt;
&lt;p&gt;The second part sets the pins to OUTPUT mode so that they can be written to.&lt;/p&gt;
&lt;p&gt;The final part sets the voltage on the pins to their initial values. Note the the SRCLR pin is set to HIGH. This is required in order for the shift register to work. In later code snippets we&amp;rsquo;ll see that clearing the input shift register is accomplished by setting the SRCLR pin to LOW to clear the input shift register, and then back to HIGH to reenable the normal operation of the shift register.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/7898d5147333eefb86a45494c5e7e189.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This code snippet shows the implementation of the test functions that are called in response to users&amp;rsquo; choices regarding what capability they&amp;rsquo;d like to see demonstrated.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/d81ec6100f22e48b25ab536ce115fe56.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This code snippet shows the implementation of the function that&amp;rsquo;s the heart of the program, &lt;code&gt;hc595_shift()&lt;/code&gt;, which does the actual writing to the input shift register. The comments provide a good detailed explanation of what the function does.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/4fa966a3ff8ed3e550feca78bab2baa3.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This final code snippet shows the implementation of 2 helper functions and the signal/interrupt handler. The first helper function, &lt;code&gt;writeNums()&lt;/code&gt;, writes the actual data needed to illuminate the hexadecimal numbers on the 7-segment display. The second, &lt;code&gt;shiftRegClr()&lt;/code&gt;, shows how to use the combination of the SRCLR and RCLK pins to clear the shift register ultimately clearing the 7-segment display. Note that, as described above, the SRCLR pin needs to be set back to HIGH in order to reenable the shift register.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;shiftRegClr&lt;/code&gt;, lines 12 through 18, note the use of the RCLK pin on lines 14 and 16. The clock signal to that pin must be pulsed, i.e., set to HIGH followed by LOW, in order to make the input shift register contents available to the output register. Also note that the SRCLR pin needs to be reset to HIGH after the operation to reenable the shift register.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;signalHandler()&lt;/code&gt; function catches the signal from the OS (line 23) via the &lt;code&gt;sigs&lt;/code&gt; channel. Then on (line 25) it closes the stop channel. A side effect of closing a channel is a notification is sent to all listeners on the other end of the channel. This is a common pattern in Go. Finally it clears the shift register, releases go-rpio resources (line 28). Line 30 releases the resources held by the go-rpio library. Finally, the program exits on line 32.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;This article has covered quite a bit of ground. If you&amp;rsquo;ve been following my series starting with the &lt;a href=&#34;https://youngkin.github.io/post/sunfoundergpionotesled/&#34;&gt;Raspberry Pi GPIO in Go and C - Blinking LED&lt;/a&gt; project, you&amp;rsquo;re already familiar with using GPIO to drive LEDs. You might agree that the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.4_7-segment_display_c.html&#34;&gt;Sunfounder 7-Segment Display&lt;/a&gt; project didn&amp;rsquo;t really add to your knowledge of GPIO and LEDs that hasn&amp;rsquo;t already been covered in previous projects. So this is why, for me anyway, this project is really about learning shift register fundamentals and using them in a non-trivial way.&lt;/p&gt;
&lt;p&gt;This article covered several interesting things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It demonstrated wiring up a relatively complex circuit on a breadboard. As I did, you might have made some mistakes along the way that gave you some useful knowledge of how to debug circuits.&lt;/li&gt;
&lt;li&gt;Through an academic discussion and hands-on practice you&amp;rsquo;ve learned quite a bit about shift registers and what they can be used for.&lt;/li&gt;
&lt;li&gt;Despite my somewhat trivializing the use of LEDs in this project, this project did shed light on how to use LEDs in a more realistic manner. Controlling an individual LED is interesting, but being able to control an array of LEDs in parallel and display digits on that array is a big step forward. You also learned that there are 2 types of 7-segment displays, common anode and common cathode.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Comments and questions about this article are welcome.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.4_7-segment_display_c.html&#34;&gt;Sunfounder 7-Segment Display&lt;/a&gt; project documentation.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://docs.sunfounder.com/projects/electronic-kit/en/latest/lesson_19_7-segment.html&#34;&gt;Sunfounder 7-Segment Python&lt;/a&gt; project contains some additional information not available in the C version of the project.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pinout.xyz/&#34;&gt;Raspberry Pi GPIO Pinout diagram&lt;/a&gt; including the physical board pin numbers, the BCM/GPIO pin numbers, and the WiringPi pin numbers.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.allaboutcircuits.com/textbook/digital/chpt-12/serial-in-parallel-out-shift-register/&#34;&gt;Shift Registers: Serial-in, Parallel-out (SIPO) Conversion&lt;/a&gt; is a good resource for getting a detailed introduction to shift registers in general, and the 74HC595 shift register in particular.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ti.com/lit/ds/symlink/cd74hc595.pdf?ts=1636840974607&amp;amp;ref_url=https%253A%252F%252Fwww.google.com%252F&#34;&gt;Texas Instruments CD74HC595 Datasheet&lt;/a&gt; contains some interesting information including a timing diagram.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.circuitbasics.com/arduino-7-segment-display-tutorial/&#34;&gt;How to set up seven segment displays on the Arduino&lt;/a&gt; provides an example of a 7-segment LED project that doesn&amp;rsquo;t use a shift register. It also has some other useful information such as how to determine whether a 7-segment display is a common cathode or common anode display.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; library for C&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiringpi.com/&#34;&gt;WiringPi website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; library for Go&lt;/li&gt;
&lt;li&gt;Other articles in my &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;Raspberry Pi GPIO series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;The gpio repository&lt;/a&gt; containing the code for this article&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;How to setup a new Raspberry Pi from scratch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;How to use a breadboard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Raspberry Pi GPIO in Go and C - LED Bar Graph</title>
      <link>https://youngkin.github.io/post/ledbargraph/</link>
      <pubDate>Mon, 08 Nov 2021 13:13:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/ledbargraph/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This is the fourth article in a series that explores GPIO programming on a Raspberry Pi 3B+. It is a supplement to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.3_led_bar_graph_c.html&#34;&gt;Sunfounder LED Bar Graph&lt;/a&gt; project. You can find the full series &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;here&lt;/a&gt;. The code for the series can be found in my &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;gpio repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.3_led_bar_graph_c.html&#34;&gt;Sunfounder LED Bar Graph&lt;/a&gt; project provides very good documentation regarding how to set up the project as well as describing the C code. This article is more geared towards describing what an LED bar graph is, what it&amp;rsquo;s good for, and how to control an LED bar graph using Go as well as C.&lt;/p&gt;
&lt;p&gt;LED bar graphs consist of several LEDs embedded into a single component. In the picture below the bar graph contains 10 LEDs arranged side-by-side.&lt;/p&gt;
&lt;img style=&#34;border:1px solid white; padding: 15px;&#34; src=&#34;https://youngkin.github.io/images/ledbargraph/bargraphimage.png&#34; align=&#34;center&#34; width=&#34;800&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;LED Bar Graph&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
LED bar graphs have several uses including:
&lt;ul&gt;
&lt;li&gt;Progress indicators&lt;/li&gt;
&lt;li&gt;Battery charge&lt;/li&gt;
&lt;li&gt;Voltmeter&lt;/li&gt;
&lt;li&gt;Sound meter&lt;/li&gt;
&lt;li&gt;Speed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In short, just about anything that requires an indication of a value at a relative position on a scale can be represented by an LED bar graph.&lt;/p&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;This section is repeated in all articles in my &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;Raspberry Pi GPIO series&lt;/a&gt;. If you&amp;rsquo;ve already completed a project from one of these articles you can skim this section for required items not included in other projects (e.g., an LED Bar Graph).&lt;/p&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;Stretch&amp;rsquo; version of the Raspbian OS. The Raspberry Pi website has instructions on how to &lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;setup a new Raspberry Pi from scratch&lt;/a&gt; if you decide to go that way vs. buying a complete kit.&lt;/p&gt;
&lt;p&gt;Other items you&amp;rsquo;ll need include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt; &lt;em&gt;(You may find &lt;a href=&#34;http://wiki.sunfounder.cc/index.php?title=Breadboard_Basics_%E2%80%93_Types&#34;&gt;this tutorial on breadboards&lt;/a&gt; helpful)&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;10 &lt;a href=&#34;https://www.amazon.com/Resistor-Tolerance-Resistors-Assortment-Certificated/dp/B08QR72BFW/ref=sr_1_8?crid=1E3LWKK431TDV&amp;amp;keywords=resistor+assortment&amp;amp;qid=1636936543&amp;amp;qsid=143-6049131-7886617&amp;amp;s=industrial&amp;amp;sprefix=resistor%2Cindustrial%2C203&amp;amp;sr=1-8&amp;amp;sres=B085NQZNTY%2CB072BL2VX1%2CB07N1ZK8CC%2CB098BKR447%2CB08QR72BFW%2CB07L851T3V%2CB09CZ18Z31%2CB08PF3HNMD%2CB07D54XMFK%2CB088WQMNYK%2CB08NY3XR96%2CB06WRQS97C%2CB07PXYVP3J%2CB07D2Z45CG%2CB089Q88QPN%2CB08ZRYH9VC%2CB08FD1XVL6%2CB08QRH6HFT%2CB07PTNN78Z%2CB07P3MFG5D&#34;&gt;220 Ohm resistors&lt;/a&gt; - this set actually has an assortment of resistors including 220 Ohm resistors.&lt;/li&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/10-Segment-LED-BAR-Graph-Indicator/dp/B0155SPLN2/ref=pd_sbs_3/143-6049131-7886617?pd_rd_w=1Ex07&amp;amp;pf_rd_p=0a3ad226-8a77-4898-9a99-63ffeb1aef90&amp;amp;pf_rd_r=PSA6XYZEJZTWWA8QVHG1&amp;amp;pd_rd_r=63d233c3-3180-4b34-8452-eee71e2cc984&amp;amp;pd_rd_wg=GSCIp&amp;amp;pd_rd_i=B0155SPLN2&amp;amp;psc=1&#34;&gt;10 segment LED Bar Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the T-Type adapter will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. Buying all these things separately will cost more than a kit however.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;amp;pd_rd_i=B06WP7169Y&amp;amp;pd_rd_w=OZVyf&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=0V0IH&amp;amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;Here&amp;rsquo;s a simple kit that has all of the above&lt;/a&gt;. I&amp;rsquo;m finding the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt; especially useful. NOTE: The Ultimate Starter Kit and the Raphael Kit are the same product.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;You will also need some basic C  and Go programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll also need familiarity with how to use an editor like vim or nano.&lt;/p&gt;
&lt;p&gt;To compile and run the C program you&amp;rsquo;ll need the &lt;a href=&#34;https://github.com/WiringPi&#34;&gt;WiringPi&lt;/a&gt; library. It&amp;rsquo;s easy to get:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install wiringpi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then test the installation using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pi@pi-node1:~/go/src/github.com/youngkin/gpio/rgbled $ gpio -v
gpio version: 2.50
Copyright &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 2012-2018 Gordon Henderson
This is free software with ABSOLUTELY NO WARRANTY.
For details type: gpio -warranty

Raspberry Pi Details:
  Type: Pi 3B+, Revision: 03, Memory: 1024MB, Maker: Sony
  * Device tree is enabled.
  *--&amp;gt; Raspberry Pi &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; Model B Plus Rev 1.3
  * This Raspberry Pi supports user-level GPIO access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above you&amp;rsquo;ll notice &lt;code&gt;gpio version: 2.50&lt;/code&gt;. If you&amp;rsquo;re using a Rasberry Pi 4, use the instructions given in the Sunfounder &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/check_the_wiringpi_c.html&#34;&gt;Checking the WiringPi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;WiringPi is unique in that it includes a command line tool, &lt;code&gt;gpio&lt;/code&gt;, as shown above, that can be used to manage, control, and query the GPIO board. This can be very handy. See the &lt;a href=&#34;http://wiringpi.com/the-gpio-utility/&#34;&gt;gpio reference&lt;/a&gt; for more information on what it can do and how to use it.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in Go development on a Raspberry Pi you&amp;rsquo;ll need to install the development environment onto the Raspberry Pi. &lt;a href=&#34;https://www.jeremymorgan.com/tutorials/raspberry-pi/install-go-raspberry-pi/&#34;&gt;Here&amp;rsquo;s a simple source&lt;/a&gt; that explains how to accomplish this. This source is a little dated, but the only significant issue is with the version of Go to install. The source shows installing Go &lt;strong&gt;1.14.4.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.14.4.linuxarmv6l.tar.gz&lt;/strong&gt;. The current versions are &lt;strong&gt;1.17.1.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. For the Raspberry Pi 3B+ the correct choice will be &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. The other is intended for 64 bit systems like the Raspberry Pi 4 series. You can find current ARM versions of Go at the &lt;a href=&#34;https://golang.org/dl/&#34;&gt;Golang download site&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For Go development you&amp;rsquo;ll also need the &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; library.&lt;/p&gt;
&lt;p&gt;If you want to veer away from the cookbook style of the Sunfounder docs you&amp;rsquo;ll need some basic knowledge of Linux . For example, I won&amp;rsquo;t be explaining what &lt;strong&gt;root privileges&lt;/strong&gt; are.&lt;/p&gt;
&lt;h2 id=&#34;setup-and-code&#34;&gt;Setup and Code&lt;/h2&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/ledbargraph/breadboard.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder wiring diagram&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/ledbargraph/ledbargraph.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Actual wiring&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The breadboard should be wired as illustrated in the above diagram. If you&amp;rsquo;re unfamiliar  with breadboards and breadboard diagrams this &lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;breadboard tutorial &lt;/a&gt; should be helpful.&lt;/p&gt;
&lt;p&gt;One thing to note about the wiring diagram is that the resistors are all attached to the breadboard&amp;rsquo;s positive power bus on one side and the positive terminals of the LED bar graph on the other (&lt;em&gt;Label Side&lt;/em&gt;). This means the LED bar graph is always getting power. In order for power to flow through a component one of the component&amp;rsquo;s terminals must be receiving power and the other must either not be receiving power or be connected to a negative or ground terminal. As noted, the resistors are directly attached to the power bus. In this diagram the GPIO pins are connected to the bar graph&amp;rsquo;s negative terminals. GPIO pins are set to either &lt;strong&gt;HIGH&lt;/strong&gt; or &lt;strong&gt;LOW&lt;/strong&gt; when in output mode &lt;em&gt;(i.e., the pins are written to)&lt;/em&gt;. &lt;strong&gt;HIGH&lt;/strong&gt; means voltage is flowing to the pin, &lt;strong&gt;LOW&lt;/strong&gt; means no voltage is flowing to the pin. Since completing a circuit requires one side of the circuit to have zero volts, and the bar graph is always receiving power via the power bus, the GPIO pins must be set to &lt;strong&gt;LOW&lt;/strong&gt; voltage for current to flow and the LEDs to illuminate. In the code sections below, the LEDs are set to &lt;strong&gt;LOW&lt;/strong&gt; when the LEDs should be illuminated.&lt;/p&gt;
&lt;h3 id=&#34;led-bar-graph-in-c&#34;&gt;LED Bar Graph in C&lt;/h3&gt;
&lt;p&gt;The code for this program can be found in the &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledbargraph/ledbargraph.c&#34;&gt;ledbargraph.c&lt;/a&gt; file in the &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;github respository&lt;/a&gt; accompanying this series. It substantially similar to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.3_led_bar_graph_c.html&#34;&gt;Sunfounder program&lt;/a&gt;, but there are some important differences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This program includes an initialization function that turns all the LEDs on then off prior to continuing with the remainder of the program. This can be useful to verify that the LED bar graph is wired up correctly.&lt;/li&gt;
&lt;li&gt;This program includes an interrupt handler that cleans up when the program is interrupted via entering &lt;code&gt;ctl-C&lt;/code&gt; at the terminal. The Sunfounder code does not. This cleanup includes resetting the bar graph to its state prior to the program starting, e.g., turning all the LEDs off.&lt;/li&gt;
&lt;li&gt;Finally, this program also includes a function that randomly lights individual LEDs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The major parts of the program are described in more detail below. The code is pretty well described in the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.3_led_bar_graph_c.html&#34;&gt;Sunfounder article&lt;/a&gt; so I won&amp;rsquo;t repeat what&amp;rsquo;s already covered there.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/d3870141ea2a8de68cad62135fa488ed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Lines 9 &amp;amp; 10 show how to build and run the program. Line 19 declares the interrupt handler that&amp;rsquo;s used to intercept &lt;code&gt;ctl-C&lt;/code&gt; input from the terminal. The rest of this section shows the &lt;code&gt;init()&lt;/code&gt; function I added. It iterates through the &lt;code&gt;pins&lt;/code&gt; array and first sets all the pins to &lt;code&gt;LOW&lt;/code&gt; which has the effect of lighting them up. They&amp;rsquo;re set to &lt;code&gt;LOW&lt;/code&gt; because the positive terminals of the LED bar graph are connected to the positive power bus. The pins are connected to the negative terminals of the bar graph. To get current to flow the pin states must be set to 0 volts, or &lt;code&gt;LOW&lt;/code&gt;. The bar graph stays lit for 500 microseconds, then the LEDs are turned off, then there&amp;rsquo;s another delay of 500 microseconds before the program continues. The delays provide enough time to see the entire bar graph light up then turn off before the program continues. This provides a visual indication that the bar graph is connected properly.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/7c1b89402b9e73cbf4d1e86995472a7b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next section contains the functions that control the bar graph LEDs. The &lt;code&gt;oddLedBarGraph()&lt;/code&gt;, &lt;code&gt;evenLedBarGraph()&lt;/code&gt;, and &lt;code&gt;allLedBarGraph()&lt;/code&gt; functions are taken directly from the Sunfounder code. I added the &lt;code&gt;randomBarGraph()&lt;/code&gt; function on lines 1 - 12 just to make things more interesting. It uses the C standard library &lt;code&gt;rand()&lt;/code&gt; function, line 5, to generate a random number that is adjusted on line 6 to be within the range of the &lt;code&gt;pins&lt;/code&gt; array, offsets 0 through 9. That resulting number is used as the offset in the array to find the pin to be toggled (lines 7 and 9). There is a very brief delay between lighting the individual LEDs.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/95819fcaa718f6fcc5f55821e63431b2.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This last section of code shows the &lt;code&gt;main()&lt;/code&gt; function and the interrupt handler, &lt;code&gt;interruptHandler()&lt;/code&gt;. With the exception of the addition of lines 3, 18, and 19, &lt;code&gt;main()&lt;/code&gt; is identical to the Sunfounder code. Line 3 registers the &lt;code&gt;interruptHandler()&lt;/code&gt; function to receive the &lt;code&gt;SIGINT&lt;/code&gt; signal associated with entering &lt;code&gt;ctl-C&lt;/code&gt; at the terminal.&lt;/p&gt;
&lt;p&gt;Lines 26 through 34 define the &lt;code&gt;interruptHandler()&lt;/code&gt; function. It&amp;rsquo;s parameter, sig, contains the integer value of the signal being passed to the function. In our case it doesn&amp;rsquo;t matter what signal is passed, it&amp;rsquo;ll exit the program in any case.&lt;/p&gt;
&lt;p&gt;Lines 27 thorugh 30 iterate through the &lt;code&gt;pins&lt;/code&gt; array making sure each pin is set to &lt;code&gt;OUTPUT&lt;/code&gt; mode, i.e., it can be written to, and setting it&amp;rsquo;s value to &lt;code&gt;HIGH&lt;/code&gt;. Recall from above that setting the pin to &lt;code&gt;LOW&lt;/code&gt; will light the pin, setting it to &lt;code&gt;HIGH&lt;/code&gt; will turn it off.&lt;/p&gt;
&lt;p&gt;Finally, the program exits on line 33 with a &amp;ldquo;success&amp;rdquo;, 0, exit code.&lt;/p&gt;
&lt;h3 id=&#34;led-bar-graph-in-go&#34;&gt;LED Bar Graph in Go&lt;/h3&gt;
&lt;p&gt;The code for this program can be found in the &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/ledbargraph/ledbargraph.go&#34;&gt;ledbargraph.go&lt;/a&gt; file in the &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;github respository&lt;/a&gt; accompanying this series. This program in this section is very similar to its C counterpart above. There are some minor differences however. It doesn&amp;rsquo;t include functions to light the even and odd numbered LEDs. The major parts of the program are described in more detail below.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/83522e2fcba8b95bb29635743635ddb1.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Line 6 provides the command to run the program. Lines 34 and 35, set up the slices that will contain the pin numbers and the associated go-rpio &lt;code&gt;rpio.Pin&lt;/code&gt; instances. Line 33 shows the comparable WiringPi pin numbers as a cross-reference.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/gpio_extension_board.html&#34;&gt;Sunfounder GPIO Extension Board diagram&lt;/a&gt; doesn&amp;rsquo;t show the GPIO pins associated with SDA1, SCL1, and SPICE0 pins. The &lt;a href=&#34;https://pinout.xyz/&#34;&gt;Raspberry Pi Pinout diagram&lt;/a&gt; does. Using this reference we can see that SDA1 maps to GPIO pin 2, SCL1 maps to GPIO pin 3, and SPICE0 maps to GPIO pin 8.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/c3d7ff9785e4f201937f52e806c4e9ac.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This next part of the program shows the &lt;code&gt;init&lt;/code&gt; function. Lines 4 - 9 create &lt;code&gt;rpio.Pin&lt;/code&gt; instances, define the pins as &lt;code&gt;rpio.OUTPUT&lt;/code&gt; pins, and append them to the &lt;code&gt;gpins&lt;/code&gt; slice defined in the first part of the program. Lines 10 - 13 set the pins to &lt;code&gt;LOW&lt;/code&gt; state, lighting them up. Recall the discussion about the C program above that describes why the pins are set to &lt;code&gt;LOW&lt;/code&gt;. Line 14 briefly pauses the program so the effect of lighting them up can be seen. Finally lines 15 - 17 turn the pins off by setting them to &lt;code&gt;HIGH&lt;/code&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/c56a1e306dc1cbf2eb1469d2f25715ed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This part of the program contains the &lt;code&gt;randBarGraph()&lt;/code&gt; and &lt;code&gt;ledAll()&lt;/code&gt; functions. Line 3 seeds the Go random number generator which is used in line 9 to generate the pin number to be lit. Lines 5 - 15 and lines 22 - 30 contain Go &lt;code&gt;select&lt;/code&gt; blocks which are used to make sure the 2 functions will exit if a &lt;code&gt;ctl-C&lt;/code&gt; signal is received from the terminal. Specifically, line 6 and 23 receive the stop command via the &lt;code&gt;stop&lt;/code&gt; channel and lines 7 &amp;amp; 24 exit the functions. The rest of the code is self-explanatory, the LEDs are turned on and off.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/78167aa8d18574e24f2a36af749f1d2b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This final part of the program contains the &lt;code&gt;main()&lt;/code&gt; and the &lt;code&gt;signalHandler()&lt;/code&gt; functions. Lines 11 &amp;amp; 15 create unbuffered Go channels. The &lt;code&gt;stop&lt;/code&gt; channel is used to signal other parts of the program that the program is exiting. This is needed because the &lt;code&gt;signalHandler()&lt;/code&gt; is started in a separate goroutine on line 21. It must be able to stop the main goroutine before exiting the program. The &lt;code&gt;stop&lt;/code&gt; channel is defined as taking an &lt;code&gt;interface{}&lt;/code&gt; type. This means that the channel can contain any type. For this channel the type of the data sent isn&amp;rsquo;t important.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;sigs&lt;/code&gt; channel, defined on line 15, is used by the Go runtime to notify the &lt;code&gt;signalHandler()&lt;/code&gt; that an interrupt signal has been received. &lt;code&gt;signalHandler()&lt;/code&gt; is registered with the Go runtime on line 20. Line 21 starts the goroutine that will run &lt;code&gt;signalHandler()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The rest of &lt;code&gt;main()&lt;/code&gt; simply initializes the pins and runs the controlling functions.&lt;/p&gt;
&lt;p&gt;LInes 28 - 42 contain the definition of &lt;code&gt;signalHandler()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;This brief article provided a quick overview of the LED bar graph component and its application in the real world. It also included some C code that wasn&amp;rsquo;t included in the original Sunfounder program. This additional code is used to show how to turn on the different LEDs in random fashion. Finally an implementation of this same C program was provided in Go. This was meant to demonstrate the usage of how use the &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; library implements functionality similar to &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Hopefully you&amp;rsquo;ve learned enough from this article to use LED bar graphs in your own applications.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.3_led_bar_graph_c.html&#34;&gt;Sunfounder LED Bar Graph&lt;/a&gt; project&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/gpio_extension_board.html&#34;&gt;Sunfounder GPIO Extension Board diagram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pinout.xyz/&#34;&gt;Raspberry Pi Pinout diagram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; library for C&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiringpi.com/&#34;&gt;WiringPi website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; library for Go&lt;/li&gt;
&lt;li&gt;Other articles in my &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;Raspberry Pi GPIO series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;The gpio repository&lt;/a&gt; containing the code for this article&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;How to setup a new Raspberry Pi from scratch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard&#34;&gt;How to use a breadboard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Raspberry Pi GPIO in Go and C - RGB LED</title>
      <link>https://youngkin.github.io/post/sunfoundergpionotesrgbled/</link>
      <pubDate>Mon, 01 Nov 2021 13:13:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/sunfoundergpionotesrgbled/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;This is the third article in a series that explores GPIO programming on a Raspberry Pi 3B+. The first is &lt;a href=&#34;https://youngkin.github.io/post/sunfoundergpionotesled/&#34;&gt;Raspberry Pi GPIO in Go and C - Blinking LED&lt;/a&gt;. It is a supplement to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;Sunfounder RGB LED&lt;/a&gt; project. You can find the full series &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This article explores the use of Pulse Width Modulation (PWM) to drive an RGB LED, as well as how to control an individual LED pin&amp;rsquo;s brightness. The code samples will be in Go and C.&lt;/p&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;stretch&amp;rsquo; version of the Raspbian OS. Given that the Sunfounder Ultimate Starter Kit is advertised to work with a Raspberry Pi 4, I would expect the 4 series to work as well. I&amp;rsquo;m less sure about other Raspberry Pi versions, especially versions with 26 vs. 40 GPIO pins.&lt;/p&gt;
&lt;p&gt;Next you&amp;rsquo;ll need&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;https://www.amazon.com/EDGELEC-Tri-Color-Multicolor-Diffused-Resistors/dp/B077XGF3YR/ref=asc_df_B077XGF3YR/?tag=hyprod-20&amp;amp;linkCode=df0&amp;amp;hvadid=242051162351&amp;amp;hvpos=&amp;amp;hvnetw=g&amp;amp;hvrand=11064062033670066895&amp;amp;hvpone=&amp;amp;hvptwo=&amp;amp;hvqmt=&amp;amp;hvdev=c&amp;amp;hvdvcmdl=&amp;amp;hvlocint=&amp;amp;hvlocphy=9028749&amp;amp;hvtargid=pla-430228081645&amp;amp;psc=1&#34;&gt;220 Ohm resistor, and a RGB LED&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the cable will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. Buying all these things separately will cost more than a kit however. &lt;a href=&#34;https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;amp;pd_rd_i=B06WP7169Y&amp;amp;pd_rd_w=OZVyf&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=0V0IH&amp;amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;Here&amp;rsquo;s a simple kit that has all of the above&lt;/a&gt;. If you expect to follow this series I recommend buying the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt;.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;You will also need some basic C  and Go programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll also need familiarity with how to use an editor like Vi or nano.&lt;/p&gt;
&lt;p&gt;To compile and run the C program you&amp;rsquo;ll need the &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; libary. It&amp;rsquo;s easy to get:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install wiringpi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then test the installation using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pi@pi-node1:~/go/src/github.com/youngkin/gpio/rgbled $ gpio -v
gpio version: 2.50
Copyright &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 2012-2018 Gordon Henderson
This is free software with ABSOLUTELY NO WARRANTY.
For details type: gpio -warranty

Raspberry Pi Details:
  Type: Pi 3B+, Revision: 03, Memory: 1024MB, Maker: Sony
  * Device tree is enabled.
  *--&amp;gt; Raspberry Pi &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; Model B Plus Rev 1.3
  * This Raspberry Pi supports user-level GPIO access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above you&amp;rsquo;ll notice &lt;code&gt;gpio version: 2.50&lt;/code&gt;. If you&amp;rsquo;re using a Rasberry Pi 4, use the instructions given in the Sunfounder &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/check_the_wiringpi_c.html&#34;&gt;Checking the WiringPi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;WiringPi is unique in that it includes a command line tool, &lt;code&gt;gpio&lt;/code&gt;, as shown above, that can be used to manage, control, and query the GPIO board. This can be very handy. See the &lt;a href=&#34;http://wiringpi.com/the-gpio-utility/&#34;&gt;gpio reference&lt;/a&gt; for more information on what it can do and how to use it.&lt;/p&gt;
&lt;p&gt;I chose not to download the code from the Sunfounder site, preferring to write my own instead, even if all I did was copy directly from the project documentation. Due to this I created my own location to create the code. In fact, &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;my code is in Github&lt;/a&gt;. If you do like downloading code you have the option of downloading, cloning, or forking it from my Github repository. As an added bonus, the project code written in Go is also located there. The code for this project is located at &lt;a href=&#34;https://github.com/youngkin/gpio/tree/main/rgbled&#34;&gt;gpio/rgbled&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in Go development on a Raspberry Pi you&amp;rsquo;ll need to install the development environment onto the Raspberry Pi. &lt;a href=&#34;https://www.jeremymorgan.com/tutorials/raspberry-pi/install-go-raspberry-pi/&#34;&gt;Here&amp;rsquo;s a simple source&lt;/a&gt; that explains how to accomplish this. This source is a little dated, but the only significant issue is with the version of Go to install. The source shows installing Go &lt;strong&gt;1.14.4.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.14.4.linuxarmv6l.tar.gz&lt;/strong&gt;. The current versions are &lt;strong&gt;1.17.1.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. For the Raspberry Pi 3B+ the correct choice will be &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. The other is intended for 64 bit systems like the Raspberry Pi 4 series.&lt;/p&gt;
&lt;p&gt;For Go development you&amp;rsquo;ll also need the &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; library. I chose it for several reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It seems to be in fairly wide use&lt;/li&gt;
&lt;li&gt;It seems to be fairly complete&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s relatively active&lt;/li&gt;
&lt;li&gt;It comes with example code and good documentation&lt;/li&gt;
&lt;li&gt;Its API is similar to WiringPi&amp;rsquo;s&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Another Go option is &lt;a href=&#34;https://github.com/periph/host&#34;&gt;periph&lt;/a&gt; (code) with &lt;a href=&#34;https://periph.io/&#34;&gt;documentation&lt;/a&gt;. It is more active and the documentation is very good, better than go-rpio. But for the LED examples I was able to find, go-rpio better matched what I was looking for, especially with regard to this project. But this is an excellent alternative to go-rpio and vice-versa.&lt;/p&gt;
&lt;p&gt;Finally, I&amp;rsquo;m assuming a basic knowledge of Linux if you want to veer away from the cookbook style of the Sunfounder docs. For example, I won&amp;rsquo;t be explaining what &lt;strong&gt;root privileges&lt;/strong&gt; are.&lt;/p&gt;
&lt;h2 id=&#34;information-that-would-have-been-helpful&#34;&gt;Information that would have been helpful&lt;/h2&gt;
&lt;p&gt;This project uses PWM (Pulse Width Modulation) on GPIO pins to achieve the desired effect, namely demonstrating how to create different colors with a simple RGB LED. Unfortunately the Sunfounder documentation leaves out information about PWM, like what is PWM and how is it implemented on a Raspberry Pi? I started to include in this section all the information I found missing from the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;Sunfounder project documentation&lt;/a&gt;, but it quickly became apparent that would better be left to a separate article. So if you don&amp;rsquo;t already have a good understanding of PWM I&amp;rsquo;d recommend reading my &lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies, with a Slice of Raspberry Pi&lt;/a&gt;&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; article before continuing with this article. I will be using terminology explained in that article throughout this one.&lt;/p&gt;
&lt;h2 id=&#34;rgb-led-in-c-software-pwm&#34;&gt;RGB LED in C (Software PWM)&lt;/h2&gt;
&lt;p&gt;Depending on your experience, you should consider reviewing the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;RGB LED&lt;/a&gt; project starting with &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/component_list.html&#34;&gt;Components List and Introduction&lt;/a&gt;. Peruse it up through the &lt;em&gt;Play with C&lt;/em&gt; section. If you&amp;rsquo;re experienced with basic electronics and components like breadboards and resistors you can skip it.&lt;/p&gt;
&lt;p&gt;You should set up the breadboard as described in the project documentation or in the diagram below:&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RgbLed.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder RGB LED breadboard setup&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The WiringPi &lt;code&gt;gpio&lt;/code&gt; utility can help with debugging if necessary. You already have this utility, you used it to verify the WiringPi installation in the &lt;a href=&#34;#prerequisites&#34;&gt;Prerequisites&lt;/a&gt; section above.&lt;/p&gt;
&lt;p&gt;The C code described in the Sunfounder &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;RGB LED project&lt;/a&gt; uses software PWM. When run, the colors of the RGB LED change as expected. Varying voltages to the respective RGB pins using software PWM produces light of varying brightness (off to full bright) which will produce a wide range of colors.&lt;/p&gt;
&lt;p&gt;Here is a slightly modified version of the Sunfounder C program that the controls an RGB LED:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/58aaaab75b2f16be7bd4a3621d17348b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Line 8 provides the command needed to build the program - &lt;code&gt;gcc -o rgbled rgbled.c  -lwiringPi -lpthread&lt;/code&gt;. The &lt;code&gt;-l&lt;/code&gt; flags reference the libraries needed to build the program. &lt;code&gt;-lwiringPi&lt;/code&gt; refers to the WiringPi library. It should be installed in the correct place along with WiringPi and the build command should just work. Libraries are usually located in &lt;code&gt;/usr/lib&lt;/code&gt;. Line 9 provides the command to run the program.&lt;/p&gt;
&lt;p&gt;Lines 18-20 specify, using the WiringPi pin numbering scheme, the GPIO pins 0, 1, and 2 for &lt;code&gt;LedPinRed&lt;/code&gt;, &lt;code&gt;LedPinGreen&lt;/code&gt;, and &lt;code&gt;LedPinBlue&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Line 24 contains the declaration of a signal handler for interrupt signals (SIGINT).&lt;/p&gt;
&lt;p&gt;Lines 27-29 use the &lt;code&gt;softPwmCreate()&lt;/code&gt; function to initialize the pins. The initial characters in the function name, &lt;code&gt;softPwm&lt;/code&gt;, indicate that the pins are being initialized for software PWM. The function&amp;rsquo;s first parameter is the pin number. The second parameter is the starting pulse width. The final parameter is the range. See &lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies, with a Slice of Raspberry Pi&lt;/a&gt; if you don&amp;rsquo;t understand these terms.&lt;/p&gt;
&lt;p&gt;Lines 33-35, &lt;code&gt;softPwmWrite()&lt;/code&gt; send the desired signal/voltage to the associated pin. The first parameter is the pin number, the same as in &lt;code&gt;softPwmCreate()&lt;/code&gt; above. The second parameter is the pulse width. Notice that the pulse width was &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;softPwmCreate()&lt;/code&gt;. This has the effect of setting the pin to zero volts. In &lt;code&gt;softPwmWrite()&lt;/code&gt; the pulse width is set to the values specified by &lt;code&gt;r_val&lt;/code&gt;, &lt;code&gt;g_val&lt;/code&gt;, and &lt;code&gt;b_val&lt;/code&gt;. These values represent the red, green, and blue values respectively. The maximum effective value for the pulse width is the range. This will result in full brightness/voltage. Any values greater than range will have no additional impact. It is important to note that the desired voltage will continue to flow to the pins until reset by another &lt;code&gt;softPwmWrite()&lt;/code&gt;.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/55e6a197e7da1d727e9d8cd616571c73.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The code snippet above is a continuation of the program. It shows the &lt;code&gt;main()&lt;/code&gt; function. Lines 2–5 initialize the WiringPi library. The program exits if this initialization fails.&lt;/p&gt;
&lt;p&gt;Line 7 specifies a signal handler to be called when SIGINT signal is received by the program. This is the signal set when the user enters ctl-C at the keyboard. This signal handler will terminate the program. This function was declared in the previous code snippet.&lt;/p&gt;
&lt;p&gt;The calls to &lt;code&gt;ledColorSet(...)&lt;/code&gt; within the &lt;code&gt;while(keepRunning)&lt;/code&gt; loop at line 11 use hex numbers to set the colors. These are used to generate the full range of available colors. They must fall in the range of &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;0xff&lt;/code&gt;, recall the range value was specified in &lt;code&gt;softPwmCreate()&lt;/code&gt;. I did change the values from the original Sunfounder code as the green LED used apparently has less resistance as it&amp;rsquo;s quite a bit brighter than the red and blue LEDs and therefore throws off the generated colors. Similarly, the blue LED seems to have more resistance as it is quite a bit dimmer than the other 2 LEDs. Changing the values, at least for my specific RGB LED, generated truer colors. The code loops, changing the LED color, until terminated via a ctl-C at the keyboard.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/7668e669ebbc578e9e7cafcc506ef203.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The code snippet above is a continuation of the previous code snippet. It contains the implementation of the interrupt handler described previously. It turns off all the RGB LED&amp;rsquo;s pins, resulting in the LED being completely off. &lt;code&gt;pinMode()&lt;/code&gt; sets the mode for the specified pin (first parameter) to &lt;code&gt;OUTPUT&lt;/code&gt; (second parameter). This changes the pin from a PWM pin to a pin that can only be set to ON or OFF. The voltage of an output pin cannot be varied. &lt;code&gt;digitalWrite()&lt;/code&gt; sets the voltage for the specified pin to zero (LOW).&lt;/p&gt;
&lt;p&gt;The program can be run, after compiling, using &lt;code&gt;./rgbled&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;rgb-led-in-c-hardware-pwm&#34;&gt;RGB LED in C (Hardware PWM)&lt;/h2&gt;
&lt;p&gt;Since the Sunfounder documentation doesn&amp;rsquo;t include a hardware PWM solution in C I decided to create one for myself. For this program modify the breadboard as shown below:&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RgbLedHardware.jpg&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder RGB LED breadboard setup&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;This time I&amp;rsquo;m using WiringPi pins 24, 1, and 23 for red, green, and blue, which correspond to BCM pins 19, 18, and 13 respectively. This is because these are 3 of the 4 hardware PWM pins on the Broadcomm BCM2835 board. Be sure to rewire the board to match these new pin assignments . The WiringPi &lt;code&gt;gpio&lt;/code&gt; utility can help with debugging if necessary. You already have this utility, you used it to verify the WiringPi installation in the &lt;a href=&#34;#prerequisites&#34;&gt;Prerequisites&lt;/a&gt; section above.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/1a249b318748b2ce7ec59ca445677d19.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This version of RGB LED is very similar to the software PWM version above. There are 2 significant differences.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Note the pin numbering used in lines 14-16. The WiringPi pin numbers used here correspond to the hardware PWM pins available on the GPIO board.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ledInit()&lt;/code&gt; and &lt;code&gt;ledColorSet()&lt;/code&gt; functions (lines 30-48) are quite different. In these functions pin mode is set to &lt;code&gt;PWM_OUTPUT&lt;/code&gt; vs. the use of &lt;code&gt;softPwmCreate&lt;/code&gt; and &lt;code&gt;pwmWrite&lt;/code&gt; is used instead of &lt;code&gt;softPwmWrite&lt;/code&gt;. Line 34 sets the range. Note that the pin number isn&amp;rsquo;t specified for the &lt;code&gt;pwmSetRange()&lt;/code&gt; call. There are 2 reasons for this. The first is that range is set at the channel level, not for individual pins. The second is that the WiringPi library doesn&amp;rsquo;t allow for the 2 channels to be specified separately. It sets both channels to the same value. Line 35, &lt;code&gt;pwmSetClock()&lt;/code&gt;, (indirectly) sets the frequency. It specifies a &lt;em&gt;divisor&lt;/em&gt;, in this case 2, that is used to divide the board&amp;rsquo;s oscillator&amp;rsquo;s clock frequency into the frequency used to control the pins. The divisor must be a number between 2 and 4095. As with &lt;code&gt;pwmSetRange()&lt;/code&gt;, &lt;code&gt;pwmSetClock()&lt;/code&gt; is specified at the channel level, not for individual pins. See &lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies, with a Slice of Raspberry Pi&lt;/a&gt; for more discussion about clocks, frequency, and divisor as they relate to PWM.&lt;/li&gt;
&lt;/ol&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/b46a3eccdbbab8cd577cbbda87824425.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The code snippet above contains the remainder of the program, &lt;code&gt;main()&lt;/code&gt; and the interrupt handler. The interrupt handler is exactly the same as the interrupt handler in the software PWM version. Like the software PWM version of the program, the program loops until interrupted via a ctl-C.&lt;/p&gt;
&lt;p&gt;The program is run using root privileges with &lt;code&gt;sudo ./rgbledHardware&lt;/code&gt;. &lt;code&gt;sudo&lt;/code&gt; is needed because direct hardware access is limited to users with root privileges. &lt;code&gt;sudo&lt;/code&gt; provides root privileges to commands prefixed with &lt;code&gt;sudo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When running the program you&amp;rsquo;ll notice that the RGB LED doesn&amp;rsquo;t produce the expected colors. Sometimes it might show purple when it should be showing blue. Sometimes it might be turned off completely when it&amp;rsquo;s supposed to be showing a color. This behavior occurs because BCM pin 13 (blue) and BCM pin 19 (red) are on the same hardware channel. As explained above, when a signal is sent to one channel it will propagate to both pins that share that channel. Green, on BCM pin 12, is unaffected. One behavior I don&amp;rsquo;t understand is why sometimes the LED is off when it should be showing a color. This only happens for red (BCM19) and blue (BCM 13) pins. Perhaps the pins that share a channel don&amp;rsquo;t produce a signal at exactly the same time. Imagine a case where the blue pin is set to 0xff and the red pin is set to 0x00. If the red pin&amp;rsquo;s signal comes in slightly after the blue signal it would override the blue pin signal turning the LED off. The takeaway from all this is that for all intents and purposes, there are only 2 hardware PWM pins can be in use at the same time, and they can&amp;rsquo;t be on the same channel.&lt;/p&gt;
&lt;h2 id=&#34;rgb-led-in-go-hardware-pwm&#34;&gt;RGB LED in Go (Hardware PWM)&lt;/h2&gt;
&lt;p&gt;This version of RGB LED will work with the same breadboard setup as the C hardware PWM version. That is, it uses the hardware PWM pins on the GPIO board. Unlike the Sunfounder C version, and the first C version in this article, the Go library only supports hardware PWM. In my &lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies, with a Slice of Raspberry Pi&lt;/a&gt; article I do include a software version of PWM in Go. It&amp;rsquo;s implemented in a companion program, &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/pwmdemo/pwmexplorer/apps/freqtest.go&#34;&gt;freqtest.go&lt;/a&gt; in the &lt;code&gt;runSoftwarePWM()&lt;/code&gt; function. Here is the code:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/072801bdf96d13eae5cba2e2774307e4.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Lines 27-29 define the pins to use for the red, green and blue elements of the LED.&lt;/p&gt;
&lt;p&gt;Lines 30-31 define default values to use for settings.&lt;/p&gt;
&lt;p&gt;Lines 35–75 set the Mode to PWM and theDutyCycle for the LED&amp;rsquo;s pins. In &lt;code&gt;DutyCycle()&lt;/code&gt;, the first parameter is the pulse width, called &lt;em&gt;duty&lt;/em&gt; by go-rpio. The second parameter is the range, called &lt;em&gt;cycle&lt;/em&gt; by go-rpio. The remainder of the lines contain comments and code that address the issues with trying to use 2 hardware PWM pins residing on the same channel as noted in the &lt;a href=&#34;#hardware-pwm-in-c&#34;&gt;Hardware PWM in C&lt;/a&gt; section above.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/11c97e8d84b134c40e3d15d6f3c639cf.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This code snippet is a continuation of the program above. This gist shows &lt;code&gt;ledInit()&lt;/code&gt;. It initializes the GPIO pins for use in the program. They set the mode (PWM), frequency, and duty cycle (providing parameters for pulse width and range (aka cycle)). As described in &lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies, with a Slice of Raspberry Pi&lt;/a&gt;, the specified frequency must be between 4688 and 9,600,000.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/youngkin/188d35218c26003cfc029b5ca7a3f838.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;This is part 3 of the program and shows the implementation of &lt;code&gt;main()&lt;/code&gt;. Lines 2-4 initialize the go-rpio library. Line 5 makes sure the resources used are released when the program exits.&lt;/p&gt;
&lt;p&gt;The remainder of the program prompts the user for the red, green, and blue values to use and the sets the pins approporiately.&lt;/p&gt;
&lt;p&gt;The full program, &lt;a href=&#34;https://github.com/youngkin/gpio/blob/main/rgbled/rgbled.go&#34;&gt;rgbled.go&lt;/a&gt;, can be found in the &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;gpio github repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;That&amp;rsquo;s it, I hope you found this article interesting. To quickly review, this article covered the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Setting up the physical environment needed to experiment with an RGB LED on a Raspberry Pi 3B+.&lt;/li&gt;
&lt;li&gt;Provided, via a link to another article&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, the detailed knowledge of PWM that&amp;rsquo;s missing from the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;Sunfounder RGB LED Project&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Provided and explained the C and Go code needed to set colors in an RGB LED using both hardware and software PWM.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/&#34;&gt;Pulse Width Modulation for Dummies, with a Slice of Raspberry Pi&lt;/a&gt; contains all you need to know about PWM on a Raspberry Pi, at least until you want to become a PWM expert! &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>Pulse Width Modulation for Dummies</title>
      <link>https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/</link>
      <pubDate>Thu, 21 Oct 2021 13:13:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/</guid>
      <description>&lt;p&gt;This is the second article in a series that explores &lt;a href=&#34;https://youngkin.github.io/categories/gpio/&#34;&gt;GPIO programming on a Raspberry Pi 3B+&lt;/a&gt;. This article provides some details about hardware and software based PWM on the Raspberry Pi, specifically the 3B+ with the &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;Broadcomm BCM2835 board&lt;/a&gt;. This article has an accompanying application, &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;PWM Explorer&lt;/a&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, that can be used to experiment with PWM settings and capabilities.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;I was writing an &lt;a href=&#34;https://youngkin.github.io/post/sunfoundergpionotesrgbled&#34;&gt;article&lt;/a&gt; as a companion to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;SunFounder RGB LED project&lt;/a&gt; to cover some areas that were missing in that project such as what is PWM, how does it work, and why the code was written as it was. I had no idea what PWM was or what I was doing or why. To fill the gap I started researching PWM and found numerous articles about PWM&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;, and also software libraries like &lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; (C)&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; (Go)&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;, &lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835&#34;&gt;BCM2835 by Mike McCalley&lt;/a&gt; (C)&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; and &lt;a href=&#34;https://abyz.me.uk/rpi/pigpio/pdif2.html&#34;&gt;pigpio&lt;/a&gt; (Python &amp;amp; C)&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;. So with my focus still on controlling an RGB LED via GPIO and PWM I started writing programs in C and Go. I quickly had difficulty in several areas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Terminology is used inconsistently across articles and the libraries. For example, some used the terms &lt;em&gt;Cycle&lt;/em&gt; and &lt;em&gt;Range&lt;/em&gt; for the same thing.&lt;/li&gt;
&lt;li&gt;The libraries were documented to varying degrees. Coupled with a lack of common terminology it was difficult to figure out how to use them.&lt;/li&gt;
&lt;li&gt;Going hand in hand with figuring out how to use the libraries, it was difficult to understand how different parameters affected the behavior of the hardware, in this case an RGB LED.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My intent in writing this is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Provide an overview of PWM and its main concepts.&lt;/li&gt;
&lt;li&gt;Provide a glossary that links the various PWM terms to a consistent definition.&lt;/li&gt;
&lt;li&gt;Explain how the various PWM settings interact with each other (not just &lt;em&gt;duty cycle&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;Provide the information needed (sometimes via external references) to install a GPIO test bed on a Raspberry Pi 3B+.&lt;/li&gt;
&lt;li&gt;Provide programs, written in Go and C, that demonstrate how to effectively use WiringPi&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; and go-rpio&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;Provide an application that can be used to experiment with the various PWM parameters in real time.&lt;/li&gt;
&lt;li&gt;Provide hard to find information on some of the concepts and PWM settings (e.g., minimum/maximum PWM frequencies).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lest anyone think I&amp;rsquo;m presenting myself as an expert in GPIO and PWM, I&amp;rsquo;m not. Despite my best attempts to summarize what I&amp;rsquo;ve learned, I&amp;rsquo;m sure I&amp;rsquo;ve made mistakes or made things more confusing. Any mistakes I&amp;rsquo;ve made are my own. If anyone comes across any mistakes topics that could be clarified, I&amp;rsquo;d appreciate comments so I can modify this article.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m not writing this to be a definitive source about all things PWM. There are better resources for that. This article lists those &lt;a href=&#34;#references&#34;&gt;resources&lt;/a&gt; that I found particularly helpful.&lt;/p&gt;
&lt;p&gt;Now to the outline of this article. The sections are as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#prerequisites&#34;&gt;Prerequisites&lt;/a&gt; covers areas like how to get the software libraries used in this article as well as things like the hardware needed by the &lt;em&gt;PWM Explorer&lt;/em&gt; application to illustrate behavior.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what-is-pwm&#34;&gt;What is PWM?&lt;/a&gt; provides a very basic introduction to PWM. It provides definitions of common terms and the aliases used in the articles and software libraries.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#overview-of-pwm-on-a-raspberry-pi-3b&#34;&gt;Overview of PWM on a Raspberry Pi 3B+&lt;/a&gt; provides an overview of how GPIO and PWM are implemented on a Raspberry Pi.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exploring-pwm-on-a-raspberry-pi&#34;&gt;Exploring PWM on a Raspberry Pi&lt;/a&gt; provides a description of the various PWM settings, how they interact with each other, some hard to find tidbits about the PWM settings, and an overview of the application, &lt;em&gt;PWM Explorer&lt;/em&gt;, that can be used to drive PWM on a Raspberry Pi to see how the settings interact with each other in real time.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;#summary&#34;&gt;Summary&lt;/a&gt; to wrap things up.&lt;/li&gt;
&lt;li&gt;And a set of useful &lt;a href=&#34;#references&#34;&gt;References&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;Stretch&amp;rsquo; version of the Raspbian OS. The Raspberry Pi website has instructions on how to &lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;setup a new Raspberry Pi from scratch&lt;/a&gt;&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt; if you decide to go that way vs. buying a complete kit.&lt;/p&gt;
&lt;p&gt;Other items you&amp;rsquo;ll need include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt; &lt;em&gt;(You may find &lt;a href=&#34;http://wiki.sunfounder.cc/index.php?title=Breadboard_Basics_%E2%80%93_Types&#34;&gt;this tutorial on breadboards&lt;/a&gt; helpful&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;)&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/EDGELEC-Tri-Color-Multicolor-Diffused-Resistors/dp/B077XGF3YR/ref=asc_df_B077XGF3YR/?tag=hyprod-20&amp;amp;linkCode=df0&amp;amp;hvadid=242051162351&amp;amp;hvpos=&amp;amp;hvnetw=g&amp;amp;hvrand=11064062033670066895&amp;amp;hvpone=&amp;amp;hvptwo=&amp;amp;hvqmt=&amp;amp;hvdev=c&amp;amp;hvdvcmdl=&amp;amp;hvlocint=&amp;amp;hvlocphy=9028749&amp;amp;hvtargid=pla-430228081645&amp;amp;psc=1&#34;&gt;a 220 Ohm resistor, and a RGB LED&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the T-Type adapter will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. Buying all these things separately will cost more than a kit however.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;amp;pd_rd_i=B06WP7169Y&amp;amp;pd_rd_w=OZVyf&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=0V0IH&amp;amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;Here&amp;rsquo;s a simple kit that has all of the above&lt;/a&gt;. I&amp;rsquo;m finding the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt; especially useful. NOTE: The Ultimate Starter Kit and the Raphael Kit are the same product.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;You will also need some basic C  and Go programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll also need familiarity with how to use an editor like vim or nano.&lt;/p&gt;
&lt;p&gt;To compile and run the C program you&amp;rsquo;ll need the WiringPi&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;11&lt;/a&gt;&lt;/sup&gt; library. It&amp;rsquo;s easy to get:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install wiringpi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then test the installation using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pi@pi-node1:~/go/src/github.com/youngkin/gpio/rgbled $ gpio -v
gpio version: 2.50
Copyright &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 2012-2018 Gordon Henderson
This is free software with ABSOLUTELY NO WARRANTY.
For details type: gpio -warranty

Raspberry Pi Details:
  Type: Pi 3B+, Revision: 03, Memory: 1024MB, Maker: Sony
  * Device tree is enabled.
  *--&amp;gt; Raspberry Pi &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; Model B Plus Rev 1.3
  * This Raspberry Pi supports user-level GPIO access.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the above you&amp;rsquo;ll notice &lt;code&gt;gpio version: 2.50&lt;/code&gt;. If you&amp;rsquo;re using a Rasberry Pi 4, use the instructions given in the Sunfounder &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/check_the_wiringpi_c.html&#34;&gt;Checking the WiringPi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;WiringPi is unique in that it includes a command line tool, &lt;code&gt;gpio&lt;/code&gt;, as shown above, that can be used to manage, control, and query the GPIO board. This can be very handy. See the &lt;a href=&#34;http://wiringpi.com/the-gpio-utility/&#34;&gt;gpio reference&lt;/a&gt; for more information on what it can do and how to use it.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in Go development on a Raspberry Pi you&amp;rsquo;ll need to install the development environment onto the Raspberry Pi. &lt;a href=&#34;https://www.jeremymorgan.com/tutorials/raspberry-pi/install-go-raspberry-pi/&#34;&gt;Here&amp;rsquo;s a simple source&lt;/a&gt; that explains how to accomplish this. This source is a little dated, but the only significant issue is with the version of Go to install. The source shows installing Go &lt;strong&gt;1.14.4.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.14.4.linuxarmv6l.tar.gz&lt;/strong&gt;. The current versions are &lt;strong&gt;1.17.1.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. For the Raspberry Pi 3B+ the correct choice will be &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. The other is intended for 64 bit systems like the Raspberry Pi 4 series. You can find current ARM versions of Go at the &lt;a href=&#34;https://golang.org/dl/&#34;&gt;Golang download site&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For Go development you&amp;rsquo;ll also need the &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt;&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; library.&lt;/p&gt;
&lt;p&gt;If you want to veer away from the cookbook style of the Sunfounder docs you&amp;rsquo;ll need some basic knowledge of Linux . For example, I won&amp;rsquo;t be explaining what &lt;strong&gt;root privileges&lt;/strong&gt; are.&lt;/p&gt;
&lt;p&gt;Finally, I wrote an application that supports experimenting with the various PWM settings on the Raspberry Pi 3B+. There are 2 options for getting the code. First, you can clone or fork the &lt;a href=&#34;https://github.com/youngkin/gpio.git&#34;&gt;project&lt;/a&gt; from GitHub. If you do that you&amp;rsquo;ll need to have experience with git and have it installed on the Raspberry Pi. See this &lt;a href=&#34;https://linuxize.com/post/how-to-install-git-on-raspberry-pi/&#34;&gt;article on installing git&lt;/a&gt; for more details. After installing &lt;code&gt;git&lt;/code&gt; you can download the project by running &lt;code&gt;git clone https://github.com/youngkin/gpio.git&lt;/code&gt;. If you would like to contribute the project please fork the respository instead. As an alternative to using git you can also download a &lt;em&gt;zip&lt;/em&gt; file of the project by navigating to the &lt;a href=&#34;https://github.com/youngkin/gpio.git&#34;&gt;project&amp;rsquo;s URL&lt;/a&gt;, clicking on the &lt;em&gt;Code&lt;/em&gt; button above and to the right of the file listing, and selecting &lt;em&gt;Download ZIP&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;what-is-pwm&#34;&gt;What is PWM?&lt;/h2&gt;
&lt;p&gt;At it&amp;rsquo;s most basic, PWM is used to simulate an analog signal using a digital source (like a GPIO pin). As an example, an LED&amp;rsquo;s brightness and/or color can be modified by varying the voltage supplied to the LED. A variety of analog devices, such as a motor&amp;rsquo;s speed, can be controlled in the same way. PWM simulates varying voltages by varying the length of the digital power pulse within a given duration.&lt;/p&gt;
&lt;p&gt;In addition to what&amp;rsquo;s presented here, &lt;a href=&#34;https://www.kompulsa.com/introduction-pwm-pulse-width-modulation-works/&#34;&gt;Introduction to PWM: How Pulse Width Modulation works&lt;/a&gt; describes some of the same concepts described here as well as a few more examples of how PWM can be used. The &lt;a href=&#34;#references&#34;&gt;References&lt;/a&gt; section has links to more sources of PWM information.&lt;/p&gt;
&lt;p&gt;The follow sections cover the main points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Terminology&#34;&gt;Terminology&lt;/a&gt; defines terms that will be used throughout the document&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Primary-concepts&#34;&gt;Primary concepts&lt;/a&gt; describes the major concepts&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;terminology&#34;&gt;Terminology&lt;/h3&gt;
&lt;p&gt;My research into PWM involved reading several articles&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; as well as examining the code of several PWM software libraries in various languages &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;. These various sources aren&amp;rsquo;t completely consistent in the terminology they use. Here are some of the common terms, their aliases, and definitions. See the diagram below for a visual representation of the terms.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/PWMPulsePeriod.png&#34; align=&#34;center&#34; width=&#34;800&#34; height=&#34;400&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;PWM timing diagram&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Frequency&lt;/strong&gt; - Per Wikipedia &lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;, &lt;em&gt;frequency is the number of occurrences of a repeating event per unit of time&lt;/em&gt;. In electronics an event is the peak of a wave to the next peak of the wave (analog). In digital terms an event is from the leading edge of one pulse to the leading edge of the next pulse. Frequency is measured in Hertz, which is the number of repeating events per second.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Period&lt;/strong&gt; - Also from Wikipedia &lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;, period is the duration of time of one cycle in a repeating event. Period is measured in seconds. So period is how long something takes vs. frequency which is how many times an event occurs in a given duration of time. This makes period the reciprocal of the frequency&lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt; and vice versa, ie., &lt;em&gt;unit of time per event&lt;/em&gt; vs. &lt;em&gt;events per unit of time&lt;/em&gt;. In the above diagram the period is 10 milliseconds (ms). So the frequency in the above diagram is &lt;code&gt;1/.01&lt;/code&gt; or 100. Since frequency is measured in Hertz, or events/second, the frequency in the above diagram is 100Hz.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock source&lt;/strong&gt;&lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt; - Also called a clock, it sets the rate at which the clock advances.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PWM clock&lt;/strong&gt; - Sometimes also called a clock so this gets a bit confusing. The PWM clock&amp;rsquo;s underlying input is the clock source. Different hardware devices, such as motors and servos, only work within specific period ranges. Often the source clock is too fast for these devices. The PWM clock is created by dividing the clock source&amp;rsquo;s frequency with a number that will result in the PWM clock operating at a frequency that&amp;rsquo;s appropriate for a given device. Different devices will need different PWM clock speeds. The number used as the denominator in this calculation is frequently called the &lt;strong&gt;divisor&lt;/strong&gt; in software libraries and the BCM2835 Data Sheet&lt;sup id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pulse&lt;/strong&gt; - From the &amp;ldquo;P&amp;rdquo; in PWM. This is the minimum length of time a PWM pin&amp;rsquo;s output is set to high or low. Its minimum length is governed by the speed of the PWM clock. I&amp;rsquo;ll use pulse throughout this document, mostly because it&amp;rsquo;s in the name.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Range&lt;/strong&gt; - Range can be thought of as a counter that counts PWM clock pulses. The ratio of range to PWM clock frequency can be thought of as the frequency of the signal sent to a PWM pin. I&amp;rsquo;ve also seen the term cycle length used as as an alias for range&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pulse width&lt;/strong&gt; - Pulse width is the duration of a pulse. In the various software libraries I&amp;rsquo;ve seen it called width&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, value&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, data&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt;, and duty length&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;primary-concepts&#34;&gt;Primary concepts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Duty cycle&lt;/strong&gt; is the ratio of Pulse Width to Range, i.e., &lt;code&gt;Pulse-Width/Range&lt;/code&gt;. For a range of 10 and a pulse of 5, the duty cycle is 5/10 or 50%. Duty cycle regulates the output voltage of a PWM device. For a 50% duty cycle and an input voltage of 5 volts, the output voltage will be 2.5 volts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software vs. Hardware PWM&lt;/strong&gt; - For the purposes of this article there are 2 ways to generate a PWM signal, software-based and hardware-based&lt;sup id=&#34;fnref:16&#34;&gt;&lt;a href=&#34;#fn:16&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;16&lt;/a&gt;&lt;/sup&gt;. Hardware-based PWM is generated by a dedicated hardware PWM device that can be configured to generate a PWM signal as described above&lt;sup id=&#34;fnref:16&#34;&gt;&lt;a href=&#34;#fn:16&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;16&lt;/a&gt;&lt;/sup&gt;. Hardware-based PWM produces a very uniform signal with regard to timing. A uniform signal is required, for example, to produce a flicker-free light source such as an LED. Software-based PWM is directly implemented in the executing program using a &lt;code&gt;while(true)&lt;/code&gt; for loop that never ends which controls the amount of time a pin is allowing current to flow (pulse) vs. the amount of time the pin isn&amp;rsquo;t allowing current to flow. In this case the uniformity of the signal is determined by the accuracy of a language&amp;rsquo;s &lt;code&gt;sleep()&lt;/code&gt; function and the OS (Linux) scheduler. A less uniform signal, for example, may result in a flickering light source. There is a more complete description of &lt;a href=&#34;https://raspberrypi.stackexchange.com/questions/100641/whats-the-difference-between-soft-pwm-and-pwm&#34;&gt;the difference between soft PWM and PWM&lt;/a&gt; and associated pros and cons on the Raspberry Pi Stack Exchange site.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Balanced vs. Mark/Space&lt;/strong&gt; refers to the method used to determine how the PWM output signals are to be generated. There are 2 algorithms, balanced and mark/space. Balanced indicates that the duty cycle will be evenly spread across the range. That is to say, the pulse width will be split into a set of shorter pulses that are distributed across the range. In contrast, in mark/space, the pulse is generated as a single signal called a &amp;ldquo;mark&amp;rdquo;. The time remaining in the range, &lt;code&gt;range-pulseWidth&lt;/code&gt; , is called the &amp;ldquo;space&amp;rdquo;. No signal is present in the space duration. Mark/Space is often good enough, but as periods get longer so does the absolute time difference between the mark and space durations. For large ratios of &lt;code&gt;range/PWMClockFrequency&lt;/code&gt;, e.g., 1 (&lt;em&gt;which equates to 1Hz since the denominator unit is frequency&lt;/em&gt;) and a duty-cycle of 50%, the space will be 500 milliseconds and the mark will be 500 milliseconds. This difference is large enough to be discernable in the behavior of the device. For example a motor might surge or a light flicker. In contrast, balanced mode will smooth out these differences. For the same 1Hz range and 50% duty-cycle, balanced mode might produce 500 1 millisecond signals every 2 milliseconds (&lt;code&gt;1/(500 * .002) = 1 = 1Hz&lt;/code&gt;). The same 50% duty-cycle is produced, but the output signal is much smoother. Hardware implementations like the BCM2835 support both algorithms. It is possible to support both algorithms in software, but depending on the algorithms are implemented they may consume a significant amout of CPU.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;overview-of-pwm-on-a-raspberry-pi-3b&#34;&gt;Overview of PWM on a Raspberry Pi 3B+&lt;/h2&gt;
&lt;p&gt;Physically PWM is implemented via the BCM2835&amp;rsquo;s GPIO pins. The BCM2835 board has 40 pins, a subset of which are GPIO pins. Of the GPIO pins&lt;sup id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;17&lt;/a&gt;&lt;/sup&gt; there are 4 hardware PWM pins, 13, 19, 12, and 18. The remaining GPIO pins, as well as the hardware GPIO pins, can be used for software PWM.&lt;/p&gt;
&lt;p&gt;There are several clock sources available on the BCM2835 board.  The clock source used by the GPIO libraries in this article is called the oscillator. It&amp;rsquo;s frequency as documented in several references&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; is 19.2MHz with a period of about 52 nanoseconds (1 / 19,200,000 = ~0.000000052 seconds).&lt;/p&gt;
&lt;p&gt;The BCM2835 board also implements something called a channel&lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt;. A hardware PWM pin is controlled by a channel. The PWM Clock, range, and pulse width are specified for a channel. All hardware pins connected to that channel will share the same range, pulse-width, and duty-cycle. The BCM2835 board has 2 channels. GPIO pins&lt;sup id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;17&lt;/a&gt;&lt;/sup&gt; 18 and 12 on one channel, 13 and 19 on the other. This means that a signal that&amp;rsquo;s sent to either pin that share a channel will go to both pins. For example, sending a signal on GPIO12 will also be shared with GPIO18 and vice versa&lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;15&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2 id=&#34;exploring-pwm-on-a-raspberry-pi&#34;&gt;Exploring PWM on a Raspberry Pi&lt;/h2&gt;
&lt;p&gt;The setup for this exercise is similar to a combination of the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;SunFounder Blinking LED&lt;/a&gt; and &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;Sunfounder RGB LED&lt;/a&gt; projects. If you&amp;rsquo;re familiar with wiring a breadboard the diagrams below may be all you need to get started. Otherwise it may be worth while looking at the Sunfounder LED projects and an &lt;a href=&#34;http://wiki.sunfounder.cc/index.php?title=Breadboard_Basics_%E2%80%93_Types&#34;&gt;introduction to breadboards&lt;/a&gt;&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;. The resistor used in both diagrams is 220 Ohms.&lt;/p&gt;
&lt;!--
&lt;p align=&#34;center&#34;&gt;
  &lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/redledimage.jpeg&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Red LED&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;

  &lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/redled.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
  &lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Red LED breadboard setup&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;/p&gt;
--&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;LED&lt;/th&gt;
&lt;th&gt;Breadboard setup&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/redledimage2.jpg&#34; width=&#34;600&#34;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/redled.png&#34; height=&#34;600&#34; width=&#34;600&#34;/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This setup will be used to demonstrate software PWM on a non-PWM pin. The black wires are the ground. The upper black wire connects the board &lt;em&gt;GND&lt;/em&gt; pin to the ground bus on the breadboard. The lower black wire connects the ground bus to the negative leg on the red LED (negative is the shorter leg). The red wire is for positive current. It connects GPIO6 to the positive leg on the red LED (positive is the longer leg). Note the 220 Ohm resistor bridging the red wire and the positive pin on the LED. This is required to avoid burning out the LED.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RGB LED&lt;/th&gt;
&lt;th&gt;Breadboard setup&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/rgbledimage.jpg&#34; width=&#34;300&#34;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/rgbled2.png&#34; height=&#34;800&#34; width=&#34;800&#34;/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This setup will be used to demonstrate hardware and software PWM on a hardware PWM pin. Looking down at the the breadboard the RGB LED the pins are set up as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The red pin is at the top of the RGB LED. It&amp;rsquo;s connected to GPIO pin 13 with the red wire.&lt;/li&gt;
&lt;li&gt;The ground is the next one down. It&amp;rsquo;s connected to the ground bus with the black wire.&lt;/li&gt;
&lt;li&gt;The green pin is 1 down from the ground. It&amp;rsquo;s connected to GPIO pin 18 with the white wire.&lt;/li&gt;
&lt;li&gt;The blue pin is at the bottom of the RGB LED. It&amp;rsquo;s connected to GPIO pin 19 with the blue wire.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As with the previous diagram, a 220 Ohm resistor bridges the GPIO pins to the red, green, and blue pins of the LED.&lt;/p&gt;
&lt;p&gt;This setup shows the green pin on the LED (white wire) connected to the GPIO hardware PWM pin 18. A different hardware PWM pin may be used such as 12, 13, and 19. Also, the use of an RGB LED isn&amp;rsquo;t required. Any type of LED will work. It will have to be wired up in a similar manner however, i.e., the LED positive lead should be connected to a hardware PWM pin (white wire) and the LED&amp;rsquo;s ground lead (the longest lead) to the board&amp;rsquo;s ground.&lt;/p&gt;
&lt;p&gt;If you do choose to use an RGB LED pin it&amp;rsquo;s important to note that only 2 of the colors can be controlled by hardware PWM. The pins need to be on different PWM channels. In the diagram above the red and blue pins attached to GPIO pins 13 and 19 (blue and red) to demonstrate this limitation. Recall that GPIO pins 13 and 19 share a channel. As a result, a signal sent to one pin be propagated to the other. To get the true RGB LED colors software PWM is required, along with a maximum of 2 hardware pins on different channels. While hardware pins can be used, it&amp;rsquo;s also possible to use all non-hardware pins.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;ll be easier to play with the different combinations of PWM settings when both of the above setups are wired up at the same time. It allows for any of the GPIO pins to be used by &lt;em&gt;PWM Explorer&lt;/em&gt;, with the exception that for hardware PWM the LED(s) must be installed on hardware PWM pins (GPIO pins 13, 19, 18, and 12). If more than one hardware pin is used they must be on different channels.&lt;/p&gt;
&lt;h3 id=&#34;driving-pwm-using-pwm-explorer&#34;&gt;Driving PWM using PWM Explorer&lt;/h3&gt;
&lt;p&gt;PWM Explorer supports C and Go. Choosing C you can experiment with both Mark/Space and Balanced PWM Modes. The Go library I used, go-rpio&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; only supports Mark/Space.&lt;/p&gt;
&lt;p&gt;As described in the &lt;a href=&#34;#prerequisites&#34;&gt;Prerequisites&lt;/a&gt; section above, I wrote an application, called &lt;em&gt;PWM Explorer&lt;/em&gt;, to experiment with PWM on a Raspberry Pi. This software can be used to drive PWM on both PWM and non-PWM pins. It also supports changing the various PWM parameters like divisor, range, and pulse width to provide visual feedback on the effect of these parameters on the behavior of the LEDs connected to the pins. This software is available on my &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;gpio GitHub repository&lt;/a&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/pwmexplorer.jpg&#34; align=&#34;center&#34; width=&#34;1000&#34; height=&#34;1000&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;PWM Explorer&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;The diagram above is a screenshot of the main program and has labels with brief descriptions of the various sections of the user interface. It&amp;rsquo;s a text based UI so that it can be run on a Raspberry Pi that doesn&amp;rsquo;t have the desktop capability installed. It can be run at the command line by navigating to the installation directory under the &lt;code&gt;gpio/pwmdemo/pwmexplorer&lt;/code&gt; directory and running &lt;code&gt;sudo /usr/local/go/bin/go run main.go&lt;/code&gt;. &lt;code&gt;sudo&lt;/code&gt; is needed because some of the GPIO access requires &lt;code&gt;root&lt;/code&gt; permissions. In addition to the main UI application there are 2 supporting programs in the &lt;code&gt;gpio/pwmdemo/pwmexplorer/apps&lt;/code&gt; directory, &lt;code&gt;freqtest.go&lt;/code&gt; and &lt;code&gt;freqtest.c&lt;/code&gt;. These are the actual implementations of the code required to interact with the PWM capabilities on the Raspberry Pi 3B+ using the go-rpio and WiringPi libraries. They are written in Go and C respectively. The C program must be built prior to running PWM Explorer. This is accomplished by changing to the &lt;code&gt;gpio/pwmdemo/pwmexplorer/apps&lt;/code&gt; directory and running &lt;code&gt;gcc -o freqtest freqtest.c -lwiringPi -lpthread&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are a variety of PWM parameters supported. These are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PWM Pin&lt;/strong&gt; - this item allows you to choose a PWM hardware pin to use. The pins available in the dropdown are specific to the language chosen. C uses the WiringPi&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; library which uses its own pin numbering scheme. Go uses the standard GPIO pin numbers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-PWM Pin&lt;/strong&gt; - this item allows you to specify a PWM pin to use, even a hardware pin. PWM Pin and Non-PWM Pin are mutually exclusive and the program will prevent you from specifying both. As with PWM Pin above, the numbering scheme is specific to the language, C or Go, chosen. The program offers no protection against using the wrong pin numbering scheme so be careful what you specify. If the pin chosen doesn&amp;rsquo;t behave as expected it may be that you used the wrong pin numbering scheme.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clock Frequency/Clock Divisor&lt;/strong&gt; - this item is used to set the PWM clock frequency. The go-rpio library supports specifying the PWM clock frequency directly. The C WiringPi library uses the concept of divisor defined above to set the PWM clock frequency. You can calculate the divisor to use by dividing the Raspberry Pi 3B&amp;rsquo;s oscillator clock&amp;rsquo;s frequency of 19,200,000 Hertz by the desired PWM clock frequency. For example. to get a 100kHz PWM clock frequency divide 19,200,000 by 100,000. This calculation gives the Clock Divisor to use, 192 in this case. To avoid confusion, when C is the chosen language the label will be &lt;em&gt;Clock Divisor&lt;/em&gt;. When Go is the chosen language this items label will be &lt;em&gt;Clock Frequency&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PWM Mode&lt;/strong&gt; - this item is used to specify whether Mark/Space or Balanced modes will be used. Note: some combinations of language, pin type (PWM vs. non-PWM), and PWM Type (hardware/software) don&amp;rsquo;t support Balanced mode. When this is the case a message will be displayed in the &lt;em&gt;Messages&lt;/em&gt; area. The Go go-rpio library doesn&amp;rsquo;t support balanced mode.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Range&lt;/strong&gt; - the desired range as defined in the &lt;a href=&#34;#Terminology&#34;&gt;Terminology&lt;/a&gt; section above.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pulse Width&lt;/strong&gt; - the desired pulse width as defined in the &lt;a href=&#34;#Terminology&#34;&gt;Terminology&lt;/a&gt; section above.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PWM Type&lt;/strong&gt; - this item is used to specify whether hardware or software PWM is to be used.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Depending on the terminal size some &lt;em&gt;Help&lt;/em&gt; and &lt;em&gt;Code&lt;/em&gt; text may not be visible. To address this, both the &lt;em&gt;Help&lt;/em&gt; and &lt;em&gt;Code&lt;/em&gt; sections are scrollable.&lt;/p&gt;
&lt;h4 id=&#34;experimenting-with-pwm-parameters&#34;&gt;Experimenting with PWM Parameters&lt;/h4&gt;
&lt;p&gt;As was stated earlier, the WiringPi and go-rpio libraries both use the Raspberry Pi 3B&amp;rsquo;s Oscillator clock which has a frequency is 19.2MHz. This is fixed and cannot be changed. But besides the pins chosen, the Clock Frequency/Divisor, PWM Mode, Range, Pulse Width, and PWM Type can all be modified. All of these interact with one another either directly or indirectly. In this section I will explain these relationships and how they interact. You can use the PWM Explorer to follow along and directly see the effects that I&amp;rsquo;ll explain.&lt;/p&gt;
&lt;p&gt;This section uses an LED to demonstrate the effect of the various parameters on a device. There is a property of the human eye that needs to be understood. The human eye perceives linear changes in in brightness in a logarithmic fashion. Specifically, at the lower end of a pulse width setting (lower voltage) changes in a given setting will produce what looks like a more significant result than the same change at the higher end (higher voltage)&lt;sup id=&#34;fnref:18&#34;&gt;&lt;a href=&#34;#fn:18&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;18&lt;/a&gt;&lt;/sup&gt;. The PWM Explorer doesn&amp;rsquo;t compensate for this.&lt;/p&gt;
&lt;h5 id=&#34;pwm-clock-frequency--clock-divisor&#34;&gt;PWM Clock Frequency / Clock Divisor&lt;/h5&gt;
&lt;p&gt;The first thing to decide is what frequency you want the PWM clock to run at. It&amp;rsquo;s frequency is specified directly when using Go and via the divisor when using C. Choosing this frequency is impacted by the type of PWM device being used, e.g., an LED or a motor. This article doesn&amp;rsquo;t cover how to calculate this frequency, but there are sources that do&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;. Instead I&amp;rsquo;ll focus on the general impact of clock frequency on LED devices.&lt;/p&gt;
&lt;p&gt;You may or may not be aware that the human eye can detect flickering starting at about 60Hz and below. Flickering is more apparent using peripheral vision. Given this, a PWM clock frequency to Range, &lt;code&gt;PWMClockFrequency / Range&lt;/code&gt;, below 60Hz isn&amp;rsquo;t ideal unless you&amp;rsquo;re trying to create a blinking LED. Assuming the range can&amp;rsquo;t be modified, choosing the right Clock Frequency/Divisor will directly impact whether an LED appears to be a steady light source, flickering, or blinking.&lt;/p&gt;
&lt;p&gt;Here are some settings to try this out &lt;em&gt;(these assume the LED is wired up to GPIO pin 18)&lt;/em&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Setting&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PWM Pin&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-PWM Pin&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clock Frequency/Clock Divisor&lt;/td&gt;
&lt;td&gt;5000 (10000)&lt;/td&gt;
&lt;td&gt;3840 (1920)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Mode&lt;/td&gt;
&lt;td&gt;markspace&lt;/td&gt;
&lt;td&gt;markspace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;td&gt;167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pulse Width&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Type&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Using the above settings will result in a 30Hz frequency at the pin. As this is well below 60Hz flickering will be apparent. Changing the PWM Clock Frequency/Clock Divisor will result in a pin frequency of 62.5Hz. The result will be that there is no apparent flickering.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; &lt;em&gt;The &amp;ldquo;General Purpose Clock Divisors&amp;rdquo; on the BCM2835 have a register width of 12 bits (see&lt;sup id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;, page 108, &lt;code&gt;DIVI&lt;/code&gt; field bits 23 thru 12). This means the maximum value of the Clock Divisor is 4095 (0 to 2^12-1). The go-rpio&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; further states that PWM Clock frequencies below 4688Hz will result in &amp;ldquo;unexpected behavior&amp;rdquo; (rpio.go, see comments for &lt;code&gt;SetFreq()&lt;/code&gt; function). Other sources&lt;sup id=&#34;fnref:19&#34;&gt;&lt;a href=&#34;#fn:19&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;19&lt;/a&gt;&lt;/sup&gt; state that 9.6Mhz is the highest available PWM Clock frequency (19.2Mhz/2). I&amp;rsquo;ve seen unexpected results with both frequencies below 4688Hz and above 9.6Mhz.&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&#34;range&#34;&gt;Range&lt;/h5&gt;
&lt;p&gt;Range effectively determines the frequency of the signal at the GPIO pin. This means that the frequency at the pin is defined by the ratio of &lt;code&gt;PWM Clock Frequency/Range&lt;/code&gt;. Another thing range determines is the resolution of the signal going to the device. Recall that Duty Cycle is the ratio of Pulse Width to Range. Starting with a lower value of range, say 4, limits duty cycle to 0%, 25%, 50%, 75%, or 100%. To say it a different way, with a Range of 4 the only values for Pulse Width that make sense are 0, 1, 2, 3, 4. This in turn limits things like the range of LED brightness or blinking that&amp;rsquo;s available.&lt;/p&gt;
&lt;p&gt;Since range impacts frequency at the pin &lt;em&gt;and&lt;/em&gt; the resolution, it is important to choose the correct PWM clock frequency, Range, and Pulse Width in combination. Starting with a low PWM Clock frequency limits the choice of range which in turn limits the available duty cycles.&lt;/p&gt;
&lt;p&gt;As an example let&amp;rsquo;s choose 2 extremes. For the first let&amp;rsquo;s choose a PWM Clock frequency of 5kHz and a range of 5. The resolution is 5. This means are only 5 available duty cycles including full on and full off. As described above this limits the available brightness settings for a light like an LED.&lt;/p&gt;
&lt;p&gt;Here are the settings to try this example &lt;em&gt;(the settings for the second example are in parentheses)&lt;/em&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Setting&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PWM Pin&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-PWM Pin&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clock Frequency/Clock Divisor&lt;/td&gt;
&lt;td&gt;5000 (600000)&lt;/td&gt;
&lt;td&gt;3840 (32)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Mode&lt;/td&gt;
&lt;td&gt;markspace&lt;/td&gt;
&lt;td&gt;markspace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;5 (10000)&lt;/td&gt;
&lt;td&gt;5 (10000)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pulse Width&lt;/td&gt;
&lt;td&gt;1 (5, 2, 100, 1000, 10000)&lt;/td&gt;
&lt;td&gt;1 (5, 2, 100, 1000, 10000)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Type&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Then change to Pulse Width to 5. This will be the brightest setting of the LED. While it is noticably brighter than a Pulse Width of 1, due to the narrow range it&amp;rsquo;s not that much brighter.&lt;/p&gt;
&lt;p&gt;At the other extreme let&amp;rsquo;s configure an LED for an extremely smooth transition from off to full brightness. This will require a higher resolution. Let&amp;rsquo;s go crazy and decide that we&amp;rsquo;d like to have 10,000 steps of brightness available. This translates to a range of 10,000. To avoid visible flickering we need to have at least a 60Hz signal at the GPIO pin. Since the ratio of &lt;code&gt;PWM Clock Frequency/Range&lt;/code&gt; determines the signal frequency at the pin, we will need a PWM Clock frequency of at least 600kHz. A range of 10000 times a minimum pin signal frequency of 60Hz is 600kHz (10,000 * 60 = 600,000). To check our work, &lt;code&gt;PWM Clock Frequency / Range&lt;/code&gt;, 600,000 / 10,000 = 60 (Hz).&lt;/p&gt;
&lt;h5 id=&#34;pulse-width&#34;&gt;Pulse width&lt;/h5&gt;
&lt;p&gt;At higher GPIO pin frequencies pulse width effects the brightness of an LED. At lower GPIO pin frequencies pulse width is visible as the length of time the LED is on vs. the blink rate. Let&amp;rsquo;s again use extreme examples to illustrate this.&lt;/p&gt;
&lt;p&gt;For the first example let&amp;rsquo;s use a PWM clock frequency of 1MHz and a range of 10,000. The frequency at the GPIO pin will be 100Hz 1,000,000/10,000), fast enough that no blinking or flickering will be visible. The range of 10,000 is likewise high enough that we won&amp;rsquo;t be able to discern discrete steps in the brightness of the LED.&lt;/p&gt;
&lt;p&gt;Here are the settings for the first example:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Setting&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PWM Pin&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-PWM Pin&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clock Frequency/Clock Divisor&lt;/td&gt;
&lt;td&gt;1000000 (5000)&lt;/td&gt;
&lt;td&gt;19 (3840)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Mode&lt;/td&gt;
&lt;td&gt;markspace&lt;/td&gt;
&lt;td&gt;markspace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pulse Width&lt;/td&gt;
&lt;td&gt;100 (5000)&lt;/td&gt;
&lt;td&gt;100 (5000)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Type&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For the second example change the Clock Frequency (Go) to 5000, Clock Divisor (C) to 3840, the Range to 10000 and the Pulse Width to 5000. The LED will flash for a very short period of time and will repeat flashing about once every 2 seconds (Clock Frequency/Range, 5000/10000 = 0.5Hz or once every 2 seconds). Now change the Pulse Width to 5000. Now the LED will be on for 1 second and off for 1 second. This changed the duty cycle from 2% to 50% with the corresponding change in the duration of the LED flash. This example shows how to create a blinking light using PWM, just choose a PWM Clock Frequency and range that result in a very low GPIO pin frequency, well below 60Hz.&lt;/p&gt;
&lt;h5 id=&#34;pwm-mode&#34;&gt;PWM Mode&lt;/h5&gt;
&lt;p&gt;The available PWM modes are balanced and mark/space. Recall that with mark/space the signal is either on or off (high or low) for a fixed duration within the range. For example, with a duty cycle of 50% and a range of 10, the signal will be on for 5 consecutive seconds and off for 5 consecutive seconds. As explained above, balanced mode will spread this 50% duty cycle evenly across the range which will make the effects of the duty cycle less apparent, except for a dimming of the LED (e.g., a 10ms pulse, every 10ms, 500 times over 10 seconds).&lt;/p&gt;
&lt;p&gt;To illustrate this behavior set the Clock Frequency to 4688 (Go), Clock Divisor to 4095 (C), the PWM Mode to markspace, the Range to 1000, the Pulse Width to 10, and the PWM Type to hardware. This results in a blinking LED at a pin frequency of about 4.69Hz, or almost 5/second. Now change the PWM Mode to balanced. The language must be C to use balanced mode as go-rpio only supports mark/space. Now the blinking is no longer apparent.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Setting&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PWM Pin&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-PWM Pin&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clock Frequency/Clock Divisor&lt;/td&gt;
&lt;td&gt;4688&lt;/td&gt;
&lt;td&gt;4095&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Mode&lt;/td&gt;
&lt;td&gt;markspace (&lt;del&gt;balanced&lt;/del&gt;)&lt;/td&gt;
&lt;td&gt;markspace (balanced)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pulse Width&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PWM Type&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;td&gt;hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;pwm-type&#34;&gt;PWM Type&lt;/h5&gt;
&lt;p&gt;The available PWM Types are &lt;em&gt;hardware&lt;/em&gt; and &lt;em&gt;software&lt;/em&gt;. The examples above used hardware PWM only. This is because true balanced mode is only available on hardware. In addition, the software PWM as implemented in Go and C is more akin to balanced mode and definitely not mark/space. Both the Go and C versions have a hardcoded 100MHz clock. Some of the examples in previous sections rely on mark/space behavior, especially the PWM Mode section.&lt;/p&gt;
&lt;h5 id=&#34;other-things-to-try&#34;&gt;Other things to try&lt;/h5&gt;
&lt;p&gt;To see how the above works with non-PWM pins, try some or all of the above on non-hardware PWM pins using a PWM Type of software. Monitoring CPU usage during these tests might show some differences between CPU usage for hardware vs. software PWM.&lt;/p&gt;
&lt;h5 id=&#34;pwm-explorer-code&#34;&gt;PWM Explorer code&lt;/h5&gt;
&lt;p&gt;The code in the &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;PWM Explorer&lt;/a&gt; GitHub respository is extensively commented. To avoid repeating what is best illustrated directly in the code there&amp;rsquo;s not much to say here. The structure of both programs is substantially similar although there are differences is how the Go and C libraries are used to accomplish the same task.&lt;/p&gt;
&lt;h5 id=&#34;key-takeaways&#34;&gt;Key takeaways&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;On the Raspberry Pi there are only 4 hardware PWM pins and 2 channels. There are 2 pins per channel. This reduces the number of effective hardware PWM pins to 2.&lt;/li&gt;
&lt;li&gt;Care must be taken when specifying the Clock Frequency or Clock Divisor. The acceptable range for PWM Clock frequency is 4688Hz to 9.6Mhz.&lt;/li&gt;
&lt;li&gt;Range determines both the frequency at the GPIO pin and the resolution of the signal to a device like an LED or motor. The first, frequency, is significant because at lower pin frequencies the on/off states of the pin become very apparent, as in a blinking LED light. The second, resolution, is important because it defines how fine grained the control of the device will be. For example, at low resolutions there are only a limited set of LED brightnesses that can be chosen and the differences are very apparent. At higher resolutions small changes in pulse width will result in a very small, hardly discernable, change in brightness. This is important when implementing something like a dimmer where the change in brightness from off to fully on should not change in large, discernable steps of brightness. I.e., a smoother transition through the range is desired.&lt;/li&gt;
&lt;li&gt;For higher resolutions (Range) a higher PWM clock frequency should be chosen. This ensures that the GPIO pin frequency won&amp;rsquo;t drop too low, e.g., below the 60Hz frequency needed to avoid a flickering LED light.&lt;/li&gt;
&lt;li&gt;At higher GPIO pin frequencies (e.g., above 60Hz) changing the pulse width will cause the LED to appear dimmer or brighter.&lt;/li&gt;
&lt;li&gt;At lower GPIO pin frequencies (e.g., below 60Hz, and especially below 10Hz) pulse width can be used to cause obvious pulsing, as in a blinking LED light. The length of time the light is on is directly proportional to the pulse width.&lt;/li&gt;
&lt;li&gt;Choice of PWM mode also impacts the &amp;ldquo;smoothness&amp;rdquo; of the signal. Even at low GPIO frequencies, which would normally cause an LED to blink, balanced mode will reduce that effect, often to the point of rendering it unnoticable.&lt;/li&gt;
&lt;li&gt;PWM type (software vs. hardware) can affect the consistency of the period of a PWM signal to the point that even above 60Hz an LED might noticably flicker. It can also result in an inordinate amount of CPU load needed to support the desired clock rate.&lt;/li&gt;
&lt;li&gt;Software PWM can be used, but the resulting signal can be too ragged to be used in some devices.&lt;/li&gt;
&lt;li&gt;Setting a range that is greater than the PWM Clock frequency may seem odd, but it can be used effectively to create a low frequency, pulsing signal that can be used for, among other things, causing an LED to blink.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Hopefully by now you have enough knowledge to start effectively using PWM on a Raspberry Pi 3B+, or perhaps on other Raspberry Pi models or even on other platforms entirely. Specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;ve gone through the various terms so you should now be able to read most of the literature on PWM and understand the concepts and terms used in those sources.&lt;/li&gt;
&lt;li&gt;If you followed along setting up and experimenting with PWM on your Raspberry Pi you now have a full, working, GPIO test bed installed on your Raspberry Pi.&lt;/li&gt;
&lt;li&gt;You should have an understanding of the various PWM settings and how they interact with each other.&lt;/li&gt;
&lt;li&gt;If you used the &lt;em&gt;PWM Explorer&lt;/em&gt; application you have valuable hands-on experience with using various combinations of PWM settings. You can continue to use the &lt;em&gt;PWM Explorer&lt;/em&gt; to experiment with various settings when you have questions or to test assumptions.&lt;/li&gt;
&lt;li&gt;By reading the Go and/or C code you now know how to effectively use the go-rpio and/or WiringPi libraries. Even if you decide to use other libraries, like pigpio&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;, you should understand the terminology well enough to use them effectively, or at least have a good start on learning how to use them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;PWM Explorer&lt;/a&gt; is an application that accompanies this article that can be used to experiment with various PWM settings. It demonstrates PWM using both Go and C libraries. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.allaboutcircuits.com/technical-articles/introduction-to-microcontroller-timers-pwm-timers/&#34;&gt;Introduction to Microcontroller Timers: Periodic Timers&lt;/a&gt; is a good general introduction to timers. PWM hardware is one type of periodic timer. It is useful to read this introduction. &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.allaboutcircuits.com/technical-articles/introduction-to-microcontroller-timers-pwm-timers/&#34;&gt;Pulse-width Modulation (PWM) Timers in Microcontrollers&lt;/a&gt; is a good detailed discussion about PWM timers. It&amp;rsquo;s an excellent read if you want more detail than presented here. &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.iot-programmer.com/index.php/books/22-raspberry-pi-and-the-iot-in-c/chapters-raspberry-pi-and-the-iot-in-c/60-raspberry-pi-and-the-iot-in-c-pulse-width-modulation-servos-and-more&#34;&gt;Raspberry Pi And The IoT In C - - Pulse Width Modulation, Servos And More&lt;/a&gt; is a detailed book about programming GPIO on the Raspberry Pi. There is a chapter devoted to PWM. &lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/WiringPi/WiringPi&#34;&gt;WiringPi&lt;/a&gt; is a C library for GPIO programming &lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; is a Go library for GPIO programming &lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.airspayce.com/mikem/bcm2835/&#34;&gt;bcm2835 by Mike McCalley&lt;/a&gt; is another C library for GPIO programming. &lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://abyz.me.uk/rpi/pigpio/pdif2.html&#34;&gt;pigpio&lt;/a&gt; is primarily a Python library. It also has a C library. It has the distinction of performing hardware PWM on any GPIO pin. I&amp;rsquo;m not sure how it does this. &lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up&#34;&gt;Setting up your Raspberry Pi&lt;/a&gt; is the official documentation for getting started with a Raspberry Pi including things like required hardware as well as how to install the OS and other important details. &lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://wiki.sunfounder.cc/index.php?title=Breadboard_Basics_%E2%80%93_Types&#34;&gt;Breadboard Basics - Types&lt;/a&gt; is a useful introduction to breadboards and how to use them. &lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:11&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://wiringpi.com/reference/&#34;&gt;WiringPi library reference guide&lt;/a&gt; documents the main WiringPi functions. The rest of the website also has some useful information. &lt;a href=&#34;#fnref:11&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:12&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Frequency#CITEREFSerwayFaughn1989&#34;&gt;Frequency page on Wikipedia&lt;/a&gt; discusses frequency and period &lt;a href=&#34;#fnref:12&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:13&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;A &lt;a href=&#34;https://www.sensorsone.com/frequency-to-period-calculator/&#34;&gt;Frequency to Period Calculator&lt;/a&gt; is handy for quick calculations, or validation, of frequency to period conversion (period = 1/frequency). &lt;a href=&#34;#fnref:13&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:14&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;The &lt;a href=&#34;https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf&#34;&gt;full Broadcom spec for the BCM2835&lt;/a&gt;, starting at page 138, for more details about how PWM is implemented on the BCM2835. &lt;a href=&#34;#fnref:14&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:15&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;There&amp;rsquo;s a detailed discussion about &lt;a href=&#34;https://www.raspberrypi.org/forums/viewtopic.php?t=150254&#34;&gt;Which pin(s) on RPi 3B is PWM capable&lt;/a&gt;. Specifically regarding the effect of sharing 2 PWM channels for 4 PWM pins. The Broadcom spec&lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt; also discusses this in section 9.4 on page 139, but in a less obvious way. &lt;a href=&#34;#fnref:15&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:16&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;There is a 3rd way to generate PWM signals, &lt;a href=&#34;https://stackoverflow.com/questions/50427275/raspberry-how-does-the-pwm-via-dma-work&#34;&gt;DMA or Direct Memory Access&lt;/a&gt;. It won&amp;rsquo;t be discussed here in this article. &lt;a href=&#34;#fnref:16&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:17&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://pinout.xyz/&#34;&gt;RaspberryPPi Pinout&lt;/a&gt; is a good source that describes each pins&amp;rsquo; role, physical pin number, and for GPIO pins the GPIO pin number for the BCM2835 board. It has tabs that can be used to highlight which pins serve which purpose, e.g., PWM pins. &lt;a href=&#34;#fnref:17&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:18&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://jared.geek.nz/2013/feb/linear-led-pwm&#34;&gt;Linear LED PWM&lt;/a&gt; provides guidelines/formulas for getting linear scaling when changing the brightness of an LED via PWM. Googling &amp;ldquo;LED PWM linear brightness&amp;rdquo; brings up several other articles as well. &lt;a href=&#34;#fnref:18&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:19&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://raspberrypi.stackexchange.com/questions/53854/driving-pwm-output-frequency&#34;&gt;Driving PWM output frequency&lt;/a&gt; provides some interesting information and discussion on Raspberry Pis with 26 and 40 GPIO pins. &lt;a href=&#34;#fnref:19&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>Raspberry Pi GPIO in Go and C - Blinking LED</title>
      <link>https://youngkin.github.io/post/sunfoundergpionotesled/</link>
      <pubDate>Fri, 01 Oct 2021 13:13:42 -0600</pubDate>
      
      <guid>https://youngkin.github.io/post/sunfoundergpionotesled/</guid>
      <description>&lt;p&gt;This is the first article in a series that explores GPIO programming on a Raspberry Pi 3B+. You can find the full series &lt;a href=&#34;../../categories/gpio&#34;&gt;here&lt;/a&gt;. It is a supplement to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;Sunfounder Blinking LED project&lt;/a&gt;. The code samples will be in Go and C.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;I recently became interested in GPIO programming on a Raspberry Pi. It&amp;rsquo;s a nice way to see something concrete controlled by software. It&amp;rsquo;s also a nice way to learn a little bit about electronics. This is the first article in a series I intend to write to document my journey in GPIO programming.&lt;/p&gt;
&lt;p&gt;To lower the bar to getting started I decided to purchase a GPIO/electronics kit and repurpose one of my Raspberry Pis. I chose &lt;a href=&#34;https://www.sunfounder.com/&#34;&gt;Sunfounder&lt;/a&gt;, mostly because they seem to be well regarded and their kits get good reviews. I ended up choosing the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt; (AKA Raphael)  because it has a good number of interesting electronic components and associated projects.&lt;/p&gt;
&lt;p&gt;One thing I noticed right away is that most GPIO articles assume Python for the programming language. Sunfounder&amp;rsquo;s kits and associated documentation support a number of languages including Python and C, but they lean towards Python and more projects are available in Python and not so many in C. I&amp;rsquo;m primarily a Go developer so I&amp;rsquo;m also interested in implementing GPIO projects in Go.&lt;/p&gt;
&lt;p&gt;Some of the Sunfounder kit reviews mention that the project documentation is a little sparse and short on explaining how things work. I&amp;rsquo;m just getting started and I&amp;rsquo;ve seen a little of this, but the first project, &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;Sunfounder Blinking LED project&lt;/a&gt;, is pretty well documented. I only got hung up in a couple of spots and it didn&amp;rsquo;t take long for me to figure out what I did wrong. The second project, &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;RGB LED&lt;/a&gt; was a bit different. It&amp;rsquo;s more complicated and much less detailed regarding explaining how and why things work. If all you want to do is follow a cookbook to implement the project it works well enough. But it&amp;rsquo;s lacking if you want to understand how and why it works in more detail. I spent quite a while working on this one trying to fill in the information missing from the project documentation. The point of this series is to fill that gap, from both coding and electronic perspectives.&lt;/p&gt;
&lt;p&gt;The focus of this article is the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;Sunfounder Blinking LED project&lt;/a&gt;. It&amp;rsquo;s the first project in a &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/introduction.html&#34;&gt;set of projects targeting the Ultimate Starter/Raphael kit&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;If you don&amp;rsquo;t have one, you&amp;rsquo;ll need a Raspberry Pi. I used a Raspberry Pi 3B+ with the &amp;lsquo;stretch&amp;rsquo; version of the Raspbian OS. Given that the Sunfounder Ultimate Starter Kit is advertised to work with a Raspberry Pi 4, I would expect the 4 series to work as well. I&amp;rsquo;m less sure about other Raspberry Pi versions, especially versions with 26 vs. 40 GPIO pins.&lt;/p&gt;
&lt;p&gt;Next you&amp;rsquo;ll need is a &lt;a href=&#34;https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;amp;pd_rd_i=B082KBF7MM&amp;amp;pd_rd_w=1tGTV&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=fX8JB&amp;amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;breadboard&lt;/a&gt;, some &lt;a href=&#34;https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;jumper wires&lt;/a&gt;, &lt;a href=&#34;https://www.amazon.com/ELEGOO-Electronics-Component-resistors-Potentiometer/dp/B01ERPXFZK/ref=sr_1_7_sspa?crid=3EJQNCOWP00IF&amp;amp;dchild=1&amp;amp;keywords=resistors&amp;amp;qid=1631478270&amp;amp;s=industrial&amp;amp;sprefix=resis%2Cindustrial%2C219&amp;amp;sr=1-7-spons&amp;amp;psc=1&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEzTktVSzNYMkxMSDlKJmVuY3J5cHRlZElkPUEwMjAzMDY0NVRERkFLVjVRTUFWJmVuY3J5cHRlZEFkSWQ9QTA5MjM2NjUxUFZYQUlETVAzRDA3JndpZGdldE5hbWU9c3BfbXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;a 220 Ohm resistor, and an LED&lt;/a&gt;. You should also consider getting a &lt;a href=&#34;https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;amp;pd_rd_i=B082PRVRYR&amp;amp;pd_rd_w=8mKhr&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=e9psa&amp;amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;40 pin female to female with a T-Type adapter&lt;/a&gt; to attach the GPIO outputs to the breadboard. You can use only jumper wires, but the cable will make things easier and will help prevent damage to the GPIO pins on the Raspberry Pi. If you elect not to buy the 40 pin cable with T-Type adapter you&amp;rsquo;ll need to buy &lt;a href=&#34;https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;amp;pd_rd_wg=tT1U0&amp;amp;pd_rd_i=B08M3QLL3Q&amp;amp;psc=1&#34;&gt;male-to-female jumper wires&lt;/a&gt;. Buying all these things separately will cost more than a kit however. &lt;a href=&#34;https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;amp;pd_rd_i=B06WP7169Y&amp;amp;pd_rd_w=OZVyf&amp;amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;amp;pd_rd_wg=0V0IH&amp;amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==&#34;&gt;Here&amp;rsquo;s a simple kit that has all of the above&lt;/a&gt;. If you expect to follow this series I recommend buying the &lt;a href=&#34;https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;amp;psc=1&#34;&gt;Sunfounder Raspberry Pi Ultimate Starter Kit&lt;/a&gt;.&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/RaphaelKit.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Ultimate Starter/Raphael kit&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;To compile and run the C program you&amp;rsquo;ll need the WiringPi libary. It&amp;rsquo;s easy to get:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install wiringpi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then test the installation using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pi@pi-node1:~/go/src/github.com/youngkin/gpio/rgbled $ gpio -v
gpio version: 2.50
Copyright (c) 2012-2018 Gordon Henderson
This is free software with ABSOLUTELY NO WARRANTY.
For details type: gpio -warranty

Raspberry Pi Details:
  Type: Pi 3B+, Revision: 03, Memory: 1024MB, Maker: Sony
  * Device tree is enabled.
  *--&amp;gt; Raspberry Pi 3 Model B Plus Rev 1.3
  * This Raspberry Pi supports user-level GPIO access.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the above you&amp;rsquo;ll notice &lt;code&gt;gpio version: 2.50&lt;/code&gt;. If you&amp;rsquo;re using a Rasberry Pi 4, use the instructions given in the Sunfounder &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/check_the_wiringpi_c.html&#34;&gt;Checking the WiringPi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You will also need some basic C and Go programming knowledge as well as familiarity with logging on to a Raspberry Pi terminal, or into the desktop GUI that comes with some OS versions. Depending on the approach you take, you may need to connect a keyboard and monitor to the Raspberry Pi. I simply SSH into the Pi. You&amp;rsquo;ll also need familiarity with how to use an editor like Vi or nano.&lt;/p&gt;
&lt;p&gt;I chose not to download the code from the Sunfounder site, preferring to write my own instead, even if all I did was copy directly from the project documentation. Due to this I created my own location to create the code. In fact, &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;my code is in Github&lt;/a&gt;. If you do like downloading code you have the option of downloading, cloning, or forking it from my Github repository. As an added bonus, the project code written in Go is also located there. The code for this project is located at &lt;a href=&#34;https://github.com/youngkin/gpio/tree/main/ledblink&#34;&gt;gpio/ledblink&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in Go development on a Raspberry Pi you&amp;rsquo;ll need to install the development environment onto the Raspberry Pi. &lt;a href=&#34;https://www.jeremymorgan.com/tutorials/raspberry-pi/install-go-raspberry-pi/&#34;&gt;Here&amp;rsquo;s a simple source&lt;/a&gt; that explains how to accomplish this. This source is a little dated, but the only significant issue is with the version of Go to install. The source shows installing Go &lt;strong&gt;1.14.4.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.14.4.linuxarmv6l.tar.gz&lt;/strong&gt;. The current versions are &lt;strong&gt;1.17.1.linux-arm64.tar.gz&lt;/strong&gt; and &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. For the Raspberry Pi 3B+ the correct choice will be &lt;strong&gt;1.17.1.linuxarmv6l.tar.gz&lt;/strong&gt;. The other is intended for 64 bit systems like the Raspberry Pi 4 series.&lt;/p&gt;
&lt;p&gt;Finally, I&amp;rsquo;m assuming a basic knowledge of Linux if you want to veer away from the cookbook style of the Sunfounder docs. For example, I won&amp;rsquo;t be explaining what &lt;strong&gt;root privileges&lt;/strong&gt; are.&lt;/p&gt;
&lt;h2 id=&#34;blinking-led-in-c&#34;&gt;Blinking LED in C&lt;/h2&gt;
&lt;p&gt;As mentioned above, this article is about the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.1_blinking_led_c.html&#34;&gt;Blinking LED project&lt;/a&gt;. The Sunfounder documentation for this project is quite good. You should start with the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/introduction.html&#34;&gt;Introduction&lt;/a&gt; and work your way through the following sections up to and including the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/play_with_c.html&#34;&gt;Play with C&lt;/a&gt; section. You should set up the breadboard as described in the project documentation or in the diagram below:&lt;/p&gt;
&lt;img style=&#34;border:1px solid black&#34; src=&#34;https://youngkin.github.io/images/pwmfordummies/blinkingLED.png&#34; align=&#34;center&#34; width=&#34;600&#34; height=&#34;300&#34;/&gt;
&lt;figcaption align=&#34;left&#34;&gt;&lt;center&gt;&lt;i style=&#34;color:black;&#34;&gt;Sunfounder Blinking LED breadboard setup&lt;/i&gt;&lt;/center&gt;&lt;/figcaption&gt;
&lt;p&gt;Since the Sunfounder project documentation is so good, I only have a couple of comments.&lt;/p&gt;
&lt;h3 id=&#34;information-that-would-have-been-helpful&#34;&gt;Information that would have been helpful&lt;/h3&gt;
&lt;p&gt;The documentation for the project states &amp;ldquo;&lt;em&gt;Therefore, to turn on an LED, we need to make GPIO17 low (0V) level.&lt;/em&gt;&amp;rdquo;. What it doesn&amp;rsquo;t explain is why. The reason is that the 220 Ohm resistor is connected on one side to a 3.3 volt power source and the LED anode (positive terminal) on the other. And GPIO17 is connected to the LED&amp;rsquo;s cathode (negative terminal). LEDs only illuminate when current flows from the anode to the cathode. GPIO pins on the Raspberry Pi, e.g., GPIO17, generally have a default state of HIGH (3.3 volts). With the connection of the 3.3 volt power source to the anode and the 3.3 volt GPIO17 pin on the cathode side, no current will flow through the circuit. So the LED will not turn on. Setting GPIO17 to LOW, 0 volts, allows the current to flow, lighting the LED.&lt;/p&gt;
&lt;p&gt;This is a minor point, but the program does not need to be run with root (sudo) privileges. Simply running &lt;code&gt;./BlinkingLed&lt;/code&gt;, vs. &lt;code&gt;sudo ./BlinkingLed&lt;/code&gt;, will work. This is not always true for GPIO programs. I&amp;rsquo;ll point that out when running a program that does require root privileges.&lt;/p&gt;
&lt;h2 id=&#34;blinking-led-in-go&#34;&gt;Blinking LED in Go&lt;/h2&gt;
&lt;p&gt;This version of Blinking LED will work with the same breadboard setup as the C version.&lt;/p&gt;
&lt;p&gt;First things first, we need a Go library to drive the GPIO interface. I&amp;rsquo;m using &lt;a href=&#34;https://github.com/stianeikeland/go-rpio&#34;&gt;go-rpio&lt;/a&gt; for several reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It seems to be in fairly wide use&lt;/li&gt;
&lt;li&gt;It seems to be fairly complete&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s relatively active&lt;/li&gt;
&lt;li&gt;It comes with example code and good documentation&lt;/li&gt;
&lt;li&gt;Its API is similar to WiringPi&amp;rsquo;s&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Another option is &lt;a href=&#34;https://github.com/periph/host&#34;&gt;periph&lt;/a&gt; (code) with &lt;a href=&#34;https://periph.io/&#34;&gt;documentation&lt;/a&gt;. It is more active and the documentation is very good, better than go-rpio. This project would be trivial to do using periph. Overall, for the LED examples I was able to find, go-rpio better matched what I was looking for, especially with regard to the &lt;a href=&#34;https://docs.sunfounder.com/projects/raphael-kit/en/latest/1.1.2_rgb_led_c.html&#34;&gt;RGB LED&lt;/a&gt; using Pulse Width Modulation (PWM, more on this in the next article in the series). But this is an excellent alternative to go-rpio and vice-versa.&lt;/p&gt;
&lt;p&gt;You can just use the &lt;a href=&#34;https://github.com/stianeikeland/go-rpio/blob/master/examples/blinker/blinker.go&#34;&gt;rpio-go blinker.go example&lt;/a&gt;. It uses &lt;code&gt;rpio.Pin.Toggle()&lt;/code&gt;. I created a &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;Github respository&lt;/a&gt; that contains examples in both C and Go. My Go version of &lt;code&gt;blinker&lt;/code&gt; uses direct writes instead of &lt;code&gt;rpio.Pin.Toggle&lt;/code&gt;. I thought showing an optional way to do this would be helpful, especially since later projects will use direct writes. My &lt;a href=&#34;https://github.com/youngkin/gpio&#34;&gt;gpio respository&lt;/a&gt; uses Go&amp;rsquo;s module system which will automatically download the &lt;code&gt;rpio-go&lt;/code&gt; library when built. Here&amp;rsquo;s my version of &lt;code&gt;blinker&lt;/code&gt;. I won&amp;rsquo;t be explaining Go sytax as I&amp;rsquo;m assuming familiarity with Go.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Copyright (c) 2021 Richard Youngkin. All rights reserved.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Use of this source code is governed by a MIT-style
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// license that can be found in the LICENSE file.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Run using &amp;#39;go run blinkingled.go&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
  &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
 &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;     &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;     &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;     &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;     &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/stianeikeland/go-rpio/v4&amp;#34;&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; )
 &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
 &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// Initialize the go-rpio library. By default it uses BCM pin numbering.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rpio&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(); &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
 &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
 &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Exit&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
 &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;     }
 &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// Release resources held by the go-rpio library obtained above after
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#39;main()&amp;#39; exits.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rpio&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;()
 &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// Select the GPIO pin to use, BCM pin 17
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rpio&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;)
 &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// Set the pin (BCM pin 17) to OUTPUT mode to allow writes to the pin,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;33&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// e.g., set the pin to LOW or HIGH
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt;()
 &lt;span style=&#34;color:#ae81ff&#34;&gt;35&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
 &lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;// Setting the GPIO pin to LOW allows current to flow from the power source thru
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;38&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;// the anode to cathode turning on the LED.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;39&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Low&lt;/span&gt;()
 &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;//        pin.Write(rpio.Low)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;41&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;LED on, Pin value should be 0: %d\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;())
 &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Millisecond&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;)
 &lt;span style=&#34;color:#ae81ff&#34;&gt;43&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;High&lt;/span&gt;()
 &lt;span style=&#34;color:#ae81ff&#34;&gt;44&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;//        pin.Write(rpio.High)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\tLED off, Pin value should be 1: %d\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Read&lt;/span&gt;())
 &lt;span style=&#34;color:#ae81ff&#34;&gt;46&lt;/span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Millisecond&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;)
 &lt;span style=&#34;color:#ae81ff&#34;&gt;47&lt;/span&gt;     }
 &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;
 &lt;span style=&#34;color:#ae81ff&#34;&gt;49&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// Turn off the LED
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;pin&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;High&lt;/span&gt;()
 &lt;span style=&#34;color:#ae81ff&#34;&gt;51&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Line 15 imports the &lt;code&gt;rpio-go&lt;/code&gt; library&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;     &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/stianeikeland/go-rpio/v4&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The rest of the program is explained through embedded comments. The program can be run typing &lt;code&gt;go run blinkingled.go&lt;/code&gt; at the command prompt and hitting enter.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;This article has shown how to configure a breadboard with an LED that can be controlled by programs written in both C and Go. Feel free to suggest changes or ask questions in the comments section below.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>